--- source-engine-base/ivp/ivp_utility/ivu_string.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_utility/ivu_string.cxx	2025-11-26 18:48:42
@@ -1,6 +1,7 @@
 // Copyright (C) Ipion Software GmbH 1999-2000. All rights reserved.
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 
 #include <stdlib.h>
 #include <stdarg.h>
--- source-engine-base/ivp/ivp_utility/ivu_min_list.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_utility/ivu_min_list.cxx	2025-11-26 18:48:42
@@ -5,6 +5,7 @@
 #	pragma implementation "ivu_min_list.hxx"
 #endif
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 #include "ivu_min_list.hxx"
 						 
 IVP_U_Min_List::IVP_U_Min_List(int start_size)
--- source-engine-base/ivp/ivp_controller/ivp_multidimensional_interp.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_controller/ivp_multidimensional_interp.cxx	2025-11-26 18:48:42
@@ -1,5 +1,6 @@
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 
 #if defined(LINUX)||defined(SUN)||(__MWERKS__ && __POWERPC__)
 #   include <alloca.h>
--- source-engine-base/ivp/ivp_controller/ivp_controller_buoyancy.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_controller/ivp_controller_buoyancy.cxx	2025-11-26 18:48:42
@@ -1,6 +1,7 @@
 // Copyright (C) Ipion Software GmbH 1999-2000. All rights reserved.
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 
 #if defined(LINUX) || defined(SUN) || (defined(__MWERKS__) && defined(__POWERPC__))
 #   include <alloca.h>
--- source-engine-base/ivp/ivp_controller/ivp_constraint_local.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_controller/ivp_constraint_local.cxx	2025-11-26 18:47:19
@@ -6,6 +6,7 @@
 #   include <alloca.h>
 #endif
 
+#include <stdlib.h>
 #if !defined(WIN32)
 #     pragma implementation "ivp_constraint_local.hxx"
 #endif
--- source-engine-base/ivp/ivp_collision/ivp_mindist_minimize.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_collision/ivp_mindist_minimize.cxx	2025-11-26 18:48:42
@@ -1,6 +1,7 @@
 // Copyright (C) Ipion Software GmbH 1999-2000. All rights reserved.
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 
 #if defined(LINUX) || defined(SUN) || (__MWERKS__ && __POWERPC__)
 #   include <alloca.h>
--- source-engine-base/ivp/ivp_intern/ivp_friction_gaps.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_intern/ivp_friction_gaps.cxx	2025-11-26 18:48:42
@@ -4,6 +4,7 @@
 // IVP_EXPORT_PRIVATE
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 
 #include <ivu_memory.hxx>
 #include <ivp_great_matrix.hxx>
--- source-engine-base/ivp/ivp_intern/ivp_great_matrix.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_intern/ivp_great_matrix.cxx	2025-11-26 18:44:14
@@ -10,6 +10,7 @@
 #if defined(LINUX) || defined(SUN) || (__MWERKS__ && __POWERPC__)
 #	include <alloca.h>
 #endif
+#include <stdlib.h>
 #include <ivp_great_matrix.hxx>
 #include <ivp_debug_manager.hxx>
 #include <ivu_memory.hxx>
--- source-engine-base/ivp/ivp_intern/ivp_friction.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_intern/ivp_friction.cxx	2025-11-26 18:45:06
@@ -1,705 +1,756 @@
 // Copyright (C) Ipion Software GmbH 1999-2000. All rights reserved.
 
-
 #include <ivp_physics.hxx>
 
 #if defined(LINUX) || defined(SUN) || (__MWERKS__ && __POWERPC__)
-#	include <alloca.h>
+#include <alloca.h>
 #endif
+#include <stdlib.h>
 
 // IVP_EXPORT_PRIVATE
 
-
-#include <ivu_memory.hxx>
-#include <ivp_great_matrix.hxx>
-#include <ivp_sim_unit.hxx>
-#include <ivp_physic_private.hxx>
 #include <ivp_core_macros.hxx>
-#include <ivp_material.hxx>
+#include <ivp_great_matrix.hxx>
 #include <ivp_impact.hxx>
+#include <ivp_material.hxx>
+#include <ivp_physic_private.hxx>
+#include <ivp_sim_unit.hxx>
+#include <ivu_memory.hxx>
 
+
 #include <ivp_mindist_intern.hxx> // because of Mindist
 
+#include <ivp_debug_manager.hxx> // bvecause of debug psi_synchrone
 #include <ivp_friction.hxx>
 #include <ivp_friction_solver.hxx>
-#include <ivp_debug_manager.hxx> // bvecause of debug psi_synchrone
 
+
 #include <ivp_compact_ledge.hxx>
 #include <ivp_compact_ledge_solver.hxx>
 #include <ivp_listener_collision.hxx>
 
-#include <ivp_hull_manager.hxx> //because of Mindist.
+#include <ivp_constraint_car.hxx>
+#include <ivp_hull_manager.hxx>   //because of Mindist.
 #include <ivp_mindist_macros.hxx> //because of Mindist
 #include <ivp_solver_core_reaction.hxx>
-#include <ivp_constraint_car.hxx>
 
-void IVP_Synapse_Friction::remove_friction_synapse_from_object(){
-    if (next) next->prev = prev;
-    if (prev){
-	prev->next = next;
-    }else{
-	l_obj->friction_synapses = get_next();
-    }
+
+void IVP_Synapse_Friction::remove_friction_synapse_from_object() {
+  if (next)
+    next->prev = prev;
+  if (prev) {
+    prev->next = next;
+  } else {
+    l_obj->friction_synapses = get_next();
+  }
 }
 
-int IVP_Friction_System::friction_global_counter=0;
+int IVP_Friction_System::friction_global_counter = 0;
 
+void IVP_Synapse_Friction::init_synapse_friction(
+    IVP_Contact_Point *friction, IVP_Real_Object *object,
+    const IVP_Compact_Edge *edge_in, IVP_SYNAPSE_POLYGON_STATUS status_in) {
+  l_obj = object;
+  set_contact_point(friction);
+  next = object->friction_synapses;
+  prev = NULL;
+  if (next)
+    next->prev = this;
+  object->friction_synapses = this;
 
-
-void IVP_Synapse_Friction::init_synapse_friction( IVP_Contact_Point *friction,
-						  IVP_Real_Object *object,
-						  const IVP_Compact_Edge 	*edge_in,
-						  IVP_SYNAPSE_POLYGON_STATUS status_in) {
-    l_obj = object;
-    set_contact_point(friction);
-	next = object->friction_synapses;
-	prev = NULL;
-	if (next) next->prev = this;
-	object->friction_synapses = this;
-
-	status = status_in;
-	edge = edge_in;
+  status = status_in;
+  edge = edge_in;
 }
 
-
-
-
-IVP_Contact_Point::IVP_Contact_Point( IVP_Mindist *md)
-{
-    IVP_Synapse_Real *syn0 = md->get_sorted_synapse(0);
-    synapse[0].init_synapse_friction(this, syn0->get_object(), syn0->edge, syn0->get_status());
-#ifdef IVP_USE_S_VALS_FOR_PRETENSION    
-    s_coords[0] = s_coords[1] = 0.0f;
+IVP_Contact_Point::IVP_Contact_Point(IVP_Mindist *md) {
+  IVP_Synapse_Real *syn0 = md->get_sorted_synapse(0);
+  synapse[0].init_synapse_friction(this, syn0->get_object(), syn0->edge,
+                                   syn0->get_status());
+#ifdef IVP_USE_S_VALS_FOR_PRETENSION
+  s_coords[0] = s_coords[1] = 0.0f;
 #endif
-    IVP_Synapse_Real *syn1 = md->get_sorted_synapse(1);
-    synapse[1].init_synapse_friction(this, syn1->get_object(), syn1->edge, syn1->get_status());
+  IVP_Synapse_Real *syn1 = md->get_sorted_synapse(1);
+  synapse[1].init_synapse_friction(this, syn1->get_object(), syn1->edge,
+                                   syn1->get_status());
 
-    IVP_Environment *env = md->get_environment();
-    this->last_time_of_recalc_friction_s_vals = env->get_current_time();
+  IVP_Environment *env = md->get_environment();
+  this->last_time_of_recalc_friction_s_vals = env->get_current_time();
 
-    //this->l_environment = mindist->l_environment;
-    IVP_IF(1) {
-	IVP_IF(env->get_debug_manager()->check_fs) {
-	    fprintf(env->get_debug_manager()->out_deb_file,"create_mindist %f %lx cores %lx %lx\n",
-		    env->get_current_time().get_time(),
-		    (long)this,
-		    (long)syn0->l_obj->physical_core,
-		    (long)syn0->l_obj->physical_core);
-	}
+  // this->l_environment = mindist->l_environment;
+  IVP_IF(1) {
+    IVP_IF(env->get_debug_manager()->check_fs) {
+      fprintf(env->get_debug_manager()->out_deb_file,
+              "create_mindist %f %lx cores %lx %lx\n",
+              env->get_current_time().get_time(), (long)this,
+              (long)syn0->l_obj->physical_core,
+              (long)syn0->l_obj->physical_core);
     }
-    if ( syn1->get_status() == IVP_ST_TRIANGLE){
-	const IVP_Compact_Edge *e1 = syn1->edge;
-	IVP_U_Point wHesse_vecF_Fos;
-	IVP_CLS.calc_hesse_vec_object_not_normized(e1, e1->get_compact_ledge(), &wHesse_vecF_Fos);
-	inv_triangle_det = 1.0f / wHesse_vecF_Fos.real_length();
-    }
+  }
+  if (syn1->get_status() == IVP_ST_TRIANGLE) {
+    const IVP_Compact_Edge *e1 = syn1->edge;
+    IVP_U_Point wHesse_vecF_Fos;
+    IVP_CLS.calc_hesse_vec_object_not_normized(e1, e1->get_compact_ledge(),
+                                               &wHesse_vecF_Fos);
+    inv_triangle_det = 1.0f / wHesse_vecF_Fos.real_length();
+  }
 
-    this->old_energy_dynamic_fr=0.0f;
-    this->now_friction_pressure=0.0f;
-    this->integrated_destroyed_energy = 0.0f;
-    this->cp_status = IVP_CPBS_NEEDS_RECHECK;
-    //printf("initing_mindist_fr %lx\n",(long)this);
+  this->old_energy_dynamic_fr = 0.0f;
+  this->now_friction_pressure = 0.0f;
+  this->integrated_destroyed_energy = 0.0f;
+  this->cp_status = IVP_CPBS_NEEDS_RECHECK;
+  // printf("initing_mindist_fr %lx\n",(long)this);
 
-    this->span_friction_s[0]=0.0f;
-    this->span_friction_s[1]=0.0f;
+  this->span_friction_s[0] = 0.0f;
+  this->span_friction_s[1] = 0.0f;
 
-    this->last_gap_len=ivp_mindist_settings.friction_dist; //at first PSI-iteration there is no energy from complex //maybe drop it
-    has_negative_pull_since=0;
-    //force_push_complex_last_psi=0.0f; //evtl. nicht noetig    
-    slowly_turn_on_keeper = IVP_SLOWLY_TURN_ON_KEEPER;
-    l_friction_system=NULL;
-    two_friction_values=IVP_FALSE;
-    
+  this->last_gap_len =
+      ivp_mindist_settings.friction_dist; // at first PSI-iteration there is no
+                                          // energy from complex //maybe drop it
+  has_negative_pull_since = 0;
+  // force_push_complex_last_psi=0.0f; //evtl. nicht noetig
+  slowly_turn_on_keeper = IVP_SLOWLY_TURN_ON_KEEPER;
+  l_friction_system = NULL;
+  two_friction_values = IVP_FALSE;
 }
 
-
 // everything in world coords
-IVP_DOUBLE IVP_Contact_Point::two_values_friction(IVP_U_Float_Point *real_world_friction_vec) {
-    IVP_Material *mtl[2];
-    get_material_info(mtl);
-    IVP_Impact_Solver_Long_Term *info = tmp_contact_info;
+IVP_DOUBLE IVP_Contact_Point::two_values_friction(
+    IVP_U_Float_Point *real_world_friction_vec) {
+  IVP_Material *mtl[2];
+  get_material_info(mtl);
+  IVP_Impact_Solver_Long_Term *info = tmp_contact_info;
 
-    int i;
-    for(i=0;i<2;i++) {
-        if(mtl[i]->second_friction_x_enabled) {
-	    IVP_U_Float_Point x_direction;
-	    IVP_Core *core=get_synapse(i)->l_obj->friction_core;
-	    IVP_U_Matrix *mat=&core->m_world_f_core_last_psi;
-	    mat->get_col(IVP_INDEX_X,&x_direction);
-	    IVP_U_Float_Point *surf_normal=&info->surf_normal;
+  int i;
+  for (i = 0; i < 2; i++) {
+    if (mtl[i]->second_friction_x_enabled) {
+      IVP_U_Float_Point x_direction;
+      IVP_Core *core = get_synapse(i)->l_obj->friction_core;
+      IVP_U_Matrix *mat = &core->m_world_f_core_last_psi;
+      mat->get_col(IVP_INDEX_X, &x_direction);
+      IVP_U_Float_Point *surf_normal = &info->surf_normal;
 
-	    IVP_IF(1) {
-		IVP_U_Point base_p;
-		base_p.set(&mat->vv);
-		IVP_U_Float_Point vec_p;
-		vec_p.set(&x_direction);
-		char *out_text=p_make_string("x_vec");
-		core->environment->add_draw_vector(&base_p,&vec_p,out_text,1);
-		P_FREE(out_text);
-		vec_p.set(0.0f,-1.0f,0.0f);
-		core->environment->add_draw_vector(&base_p,&vec_p,"grav",3);
-	    }
-	    
-	    IVP_U_Float_Point x_in_surface;
-	    x_in_surface.set_orthogonal_part(&x_direction,surf_normal);
-	    
-	    IVP_DOUBLE relevance_factor=x_in_surface.real_length();
-	    IVP_DOUBLE second_friction_val=mtl[i]->get_second_friction_factor();
-	    IVP_DOUBLE other_factor=mtl[1-i]->get_friction_factor();
-	    IVP_DOUBLE using_friction=other_factor*second_friction_val;
-	    IVP_DOUBLE difference_in_friction=real_friction_factor - using_friction;
-	    IVP_DOUBLE effective_friction=real_friction_factor - difference_in_friction * relevance_factor;
+      IVP_IF(1) {
+        IVP_U_Point base_p;
+        base_p.set(&mat->vv);
+        IVP_U_Float_Point vec_p;
+        vec_p.set(&x_direction);
+        char *out_text = p_make_string("x_vec");
+        core->environment->add_draw_vector(&base_p, &vec_p, out_text, 1);
+        P_FREE(out_text);
+        vec_p.set(0.0f, -1.0f, 0.0f);
+        core->environment->add_draw_vector(&base_p, &vec_p, "grav", 3);
+      }
 
-	    if(real_friction_factor<P_DOUBLE_EPS) {
-	        return 0.0f;
-	    }
-	    IVP_DOUBLE max_len_in_x_direction = IVP_MINIMAL_REAL_FRICTION_LEN * effective_friction/real_friction_factor;
-	    IVP_U_Float_Point friction_vec;
+      IVP_U_Float_Point x_in_surface;
+      x_in_surface.set_orthogonal_part(&x_direction, surf_normal);
 
-	    IVP_Impact_Solver_Long_Term *info_this = this->tmp_contact_info;
-	    friction_vec.set_multiple(&info_this->span_friction_v[0],this->span_friction_s[0]);
-	    friction_vec.add_multiple(&info_this->span_friction_v[1],this->span_friction_s[1]);
+      IVP_DOUBLE relevance_factor = x_in_surface.real_length();
+      IVP_DOUBLE second_friction_val = mtl[i]->get_second_friction_factor();
+      IVP_DOUBLE other_factor = mtl[1 - i]->get_friction_factor();
+      IVP_DOUBLE using_friction = other_factor * second_friction_val;
+      IVP_DOUBLE difference_in_friction = real_friction_factor - using_friction;
+      IVP_DOUBLE effective_friction =
+          real_friction_factor - difference_in_friction * relevance_factor;
 
-	    IVP_IF(1) {
-		IVP_U_Point base_p;
-		base_p.set(&tmp_contact_info->contact_point_ws);
-		IVP_U_Float_Point vec_p;
-		vec_p.set(&friction_vec);
-	        vec_p.mult(10.0f);
-		char *out_text=p_make_string("f_vec");
-		core->environment->add_draw_vector(&base_p,&vec_p,out_text,1);
-		P_FREE(out_text);
-	    }
-	    
-	    x_in_surface.normize();
-	    IVP_U_Float_Point x_in_surface_float;
-	    x_in_surface_float.set(&x_in_surface);
-	    IVP_DOUBLE len_direction_x=friction_vec.dot_product(&x_in_surface_float);
-	    IVP_DOUBLE abs_len=IVP_Inline_Math::fabsd(len_direction_x);
+      if (real_friction_factor < P_DOUBLE_EPS) {
+        return 0.0f;
+      }
+      IVP_DOUBLE max_len_in_x_direction = IVP_MINIMAL_REAL_FRICTION_LEN *
+                                          effective_friction /
+                                          real_friction_factor;
+      IVP_U_Float_Point friction_vec;
 
-	    if((abs_len>max_len_in_x_direction)&&1) {
-	        //we have to shorten the friction
-		
-	        IVP_U_Float_Point vec_full_friction;
-		vec_full_friction.set(&friction_vec);
-		vec_full_friction.add_multiple(&x_in_surface,-len_direction_x);
-		IVP_U_Float_Point vec_second_dir;
-		vec_second_dir.set_multiple(&x_in_surface,max_len_in_x_direction);
-		if(len_direction_x<0.0f) {
-		    vec_second_dir.mult(-1.0f);
-		}
-		IVP_U_Float_Point resulting_vec;
-		resulting_vec.set(&vec_full_friction);
-		resulting_vec.add(&vec_second_dir);
-		*real_world_friction_vec=resulting_vec;
-		this->span_friction_s[0]=resulting_vec.dot_product(&info->span_friction_v[0]);
-		this->span_friction_s[1]=resulting_vec.dot_product(&info->span_friction_v[1]);
-	    }
-	}
-    }
-    
-    IVP_U_Float_Point friction_vec;
+      IVP_Impact_Solver_Long_Term *info_this = this->tmp_contact_info;
+      friction_vec.set_multiple(&info_this->span_friction_v[0],
+                                this->span_friction_s[0]);
+      friction_vec.add_multiple(&info_this->span_friction_v[1],
+                                this->span_friction_s[1]);
 
-    friction_vec.set_multiple(&info->span_friction_v[0],this->span_friction_s[0]);
-    friction_vec.add_multiple(&info->span_friction_v[1],this->span_friction_s[1]);
-    real_world_friction_vec->set(&friction_vec);
-    return real_world_friction_vec->real_length_plus_normize();
-}
+      IVP_IF(1) {
+        IVP_U_Point base_p;
+        base_p.set(&tmp_contact_info->contact_point_ws);
+        IVP_U_Float_Point vec_p;
+        vec_p.set(&friction_vec);
+        vec_p.mult(10.0f);
+        char *out_text = p_make_string("f_vec");
+        core->environment->add_draw_vector(&base_p, &vec_p, out_text, 1);
+        P_FREE(out_text);
+      }
 
-// calculates friction pointer, pointing away from first obj, also returns length of this pointer and afterwards does normization
-// #+# kill . TL: ??
-IVP_DOUBLE IVP_Contact_Point::get_and_set_real_friction_len(IVP_U_Float_Point *real_world_friction_vec) {
-    IVP_Impact_Solver_Long_Term *info = this->tmp_contact_info;
-    real_world_friction_vec->set_multiple(&info->span_friction_v[0],this->span_friction_s[0]);
-    real_world_friction_vec->add_multiple(&info->span_friction_v[1],this->span_friction_s[1]);
-    
-    IVP_DOUBLE len_of_spring = real_world_friction_vec->real_length_plus_normize();
+      x_in_surface.normize();
+      IVP_U_Float_Point x_in_surface_float;
+      x_in_surface_float.set(&x_in_surface);
+      IVP_DOUBLE len_direction_x =
+          friction_vec.dot_product(&x_in_surface_float);
+      IVP_DOUBLE abs_len = IVP_Inline_Math::fabsd(len_direction_x);
 
-    if(this->two_friction_values==IVP_TRUE) {
-	return two_values_friction(real_world_friction_vec);
+      if ((abs_len > max_len_in_x_direction) && 1) {
+        // we have to shorten the friction
+
+        IVP_U_Float_Point vec_full_friction;
+        vec_full_friction.set(&friction_vec);
+        vec_full_friction.add_multiple(&x_in_surface, -len_direction_x);
+        IVP_U_Float_Point vec_second_dir;
+        vec_second_dir.set_multiple(&x_in_surface, max_len_in_x_direction);
+        if (len_direction_x < 0.0f) {
+          vec_second_dir.mult(-1.0f);
+        }
+        IVP_U_Float_Point resulting_vec;
+        resulting_vec.set(&vec_full_friction);
+        resulting_vec.add(&vec_second_dir);
+        *real_world_friction_vec = resulting_vec;
+        this->span_friction_s[0] =
+            resulting_vec.dot_product(&info->span_friction_v[0]);
+        this->span_friction_s[1] =
+            resulting_vec.dot_product(&info->span_friction_v[1]);
+      }
     }
-    
-    return len_of_spring;
+  }
+
+  IVP_U_Float_Point friction_vec;
+
+  friction_vec.set_multiple(&info->span_friction_v[0],
+                            this->span_friction_s[0]);
+  friction_vec.add_multiple(&info->span_friction_v[1],
+                            this->span_friction_s[1]);
+  real_world_friction_vec->set(&friction_vec);
+  return real_world_friction_vec->real_length_plus_normize();
 }
 
+// calculates friction pointer, pointing away from first obj, also returns
+// length of this pointer and afterwards does normization
+// #+# kill . TL: ??
+IVP_DOUBLE IVP_Contact_Point::get_and_set_real_friction_len(
+    IVP_U_Float_Point *real_world_friction_vec) {
+  IVP_Impact_Solver_Long_Term *info = this->tmp_contact_info;
+  real_world_friction_vec->set_multiple(&info->span_friction_v[0],
+                                        this->span_friction_s[0]);
+  real_world_friction_vec->add_multiple(&info->span_friction_v[1],
+                                        this->span_friction_s[1]);
 
-void IVP_Contact_Point::static_friction_single(const IVP_Event_Sim *es,IVP_FLOAT desired_gap,IVP_FLOAT speedup_factor) {
-    IVP_Impact_Solver_Long_Term *info = this->tmp_contact_info;
-    IVP_DOUBLE closing_speed = info->get_closing_speed();
-    IVP_DOUBLE gap_diff = desired_gap - this->get_gap_length();
-    IVP_DOUBLE a = IVP_Friction_Solver::calc_desired_gap_speed(closing_speed, gap_diff,speedup_factor);
-    IVP_DOUBLE b = info->virtual_mass;
-    IVP_DOUBLE impulse = a * b;
+  IVP_DOUBLE len_of_spring =
+      real_world_friction_vec->real_length_plus_normize();
 
-    if(impulse > 0.0f) {
-	this->now_friction_pressure = impulse * es->i_delta_time;    
-	IVP_Friction_Solver::apply_impulse( info, impulse );
-    } else {
-	this->now_friction_pressure=0.0f;
-    }
+  if (this->two_friction_values == IVP_TRUE) {
+    return two_values_friction(real_world_friction_vec);
+  }
+
+  return len_of_spring;
 }
 
-bool IVP_Contact_Point::friction_force_local_constraint_2d_wheel( IVP_Core *core_a, IVP_Impact_Solver_Long_Term *info,
-																  const IVP_Event_Sim *es, IVP_FLOAT &flEnergy )
-{
-	IVP_Constraint_Car_Object *wheel = core_a->car_wheel;
-	IVP_Constraint_Solver_Car *solver = wheel->solver_car;
+void IVP_Contact_Point::static_friction_single(const IVP_Event_Sim *es,
+                                               IVP_FLOAT desired_gap,
+                                               IVP_FLOAT speedup_factor) {
+  IVP_Impact_Solver_Long_Term *info = this->tmp_contact_info;
+  IVP_DOUBLE closing_speed = info->get_closing_speed();
+  IVP_DOUBLE gap_diff = desired_gap - this->get_gap_length();
+  IVP_DOUBLE a = IVP_Friction_Solver::calc_desired_gap_speed(
+      closing_speed, gap_diff, speedup_factor);
+  IVP_DOUBLE b = info->virtual_mass;
+  IVP_DOUBLE impulse = a * b;
 
-    IVP_DOUBLE maximum_impulse_force = this->now_friction_pressure * this->real_friction_factor * es->delta_time;
+  if (impulse > 0.0f) {
+    this->now_friction_pressure = impulse * es->i_delta_time;
+    IVP_Friction_Solver::apply_impulse(info, impulse);
+  } else {
+    this->now_friction_pressure = 0.0f;
+  }
+}
 
-	IVP_U_Float_Point axis_bs; 
-	wheel->target_position_bs.get_col( IVP_COORDINATE_INDEX( solver->x_idx ), &axis_bs );
-	IVP_U_Float_Point axis_ws;
-	const IVP_U_Matrix *m_world_f_core = solver->body_object->get_core()->get_m_world_f_core_PSI();
-	m_world_f_core->vmult3( &axis_bs, &axis_ws );
+bool IVP_Contact_Point::friction_force_local_constraint_2d_wheel(
+    IVP_Core *core_a, IVP_Impact_Solver_Long_Term *info,
+    const IVP_Event_Sim *es, IVP_FLOAT &flEnergy) {
+  IVP_Constraint_Car_Object *wheel = core_a->car_wheel;
+  IVP_Constraint_Solver_Car *solver = wheel->solver_car;
 
-	// search new span system for which one axis.dot(axis_ws) == 0
-	IVP_U_Float_Point span_v_0; // span which is orthogonal to any car body influences
-	IVP_U_Float_Point span_v_1; // span which is influences by car body weight
+  IVP_DOUBLE maximum_impulse_force =
+      this->now_friction_pressure * this->real_friction_factor * es->delta_time;
 
-	span_v_0.calc_cross_product( &axis_ws, &info->surf_normal);
-	if ( span_v_0.quad_length() < 0.001f )
-		return false;
+  IVP_U_Float_Point axis_bs;
+  wheel->target_position_bs.get_col(IVP_COORDINATE_INDEX(solver->x_idx),
+                                    &axis_bs);
+  IVP_U_Float_Point axis_ws;
+  const IVP_U_Matrix *m_world_f_core =
+      solver->body_object->get_core()->get_m_world_f_core_PSI();
+  m_world_f_core->vmult3(&axis_bs, &axis_ws);
 
-	span_v_0.normize();
-	span_v_1.calc_cross_product( &span_v_0, &info->surf_normal );
+  // search new span system for which one axis.dot(axis_ws) == 0
+  IVP_U_Float_Point
+      span_v_0; // span which is orthogonal to any car body influences
+  IVP_U_Float_Point span_v_1; // span which is influences by car body weight
 
-	IVP_DOUBLE dot_old0_new0 = info->span_friction_v[0].dot_product( &span_v_0 );
-	IVP_DOUBLE dot_old0_new1 = info->span_friction_v[0].dot_product( &span_v_1 );
-	IVP_DOUBLE dot_old1_new0 = info->span_friction_v[1].dot_product( &span_v_0 );
-	IVP_DOUBLE dot_old1_new1 = info->span_friction_v[1].dot_product( &span_v_1 );
+  span_v_0.calc_cross_product(&axis_ws, &info->surf_normal);
+  if (span_v_0.quad_length() < 0.001f)
+    return false;
 
-	IVP_DOUBLE span_s_0 = span_friction_s[0] * dot_old0_new0 + span_friction_s[1] * dot_old1_new0;
-	IVP_DOUBLE span_s_1 = span_friction_s[0] * dot_old0_new1 + span_friction_s[1] * dot_old1_new1;
-	
-	// calculate pushing behaviour between wheel and car in wheel axis direction
-	IVP_DOUBLE p_wheel;
-	IVP_DOUBLE p_body;
-	
-	IVP_DOUBLE wheel_vel;
-	IVP_DOUBLE body_vel;
+  span_v_0.normize();
+  span_v_1.calc_cross_product(&span_v_0, &info->surf_normal);
 
-    IVP_Solver_Core_Reaction tcb;
-	tcb.init_reaction_solver_translation_ws( core_a, NULL, info->contact_point_ws, &span_v_0, &span_v_1, NULL );
-	{
-		p_wheel = tcb.m_velocity_ds_f_impulse_ds.get_elem( 1, 1 );
-		wheel_vel = tcb.delta_velocity_ds.k[1];
-	}
+  IVP_DOUBLE dot_old0_new0 = info->span_friction_v[0].dot_product(&span_v_0);
+  IVP_DOUBLE dot_old0_new1 = info->span_friction_v[0].dot_product(&span_v_1);
+  IVP_DOUBLE dot_old1_new0 = info->span_friction_v[1].dot_product(&span_v_0);
+  IVP_DOUBLE dot_old1_new1 = info->span_friction_v[1].dot_product(&span_v_1);
 
-	{
-		IVP_Solver_Core_Reaction sc_body;
-		sc_body.init_reaction_solver_translation_ws( solver->body_object->get_core(), NULL, info->contact_point_ws, &span_v_1, NULL, NULL );
-		p_body = sc_body.m_velocity_ds_f_impulse_ds.get_elem( 0, 0 );
-		body_vel = sc_body.delta_velocity_ds.k[0];
-	}
-	
-	IVP_DOUBLE a = span_s_0 * es->i_delta_time - tcb.delta_velocity_ds.k[0];
-	//IVP_DOUBLE b = span_s_1 * es->i_delta_time - tcb.delta_velocity_ds.k[1];
-	IVP_DOUBLE b = span_s_1 * es->i_delta_time - 1.0f * ( wheel_vel * 1.0f + body_vel * 0.0f);
-		
-	IVP_U_Matrix3 &tpm = tcb.m_velocity_ds_f_impulse_ds;
-	
-	IVP_DOUBLE inv_mat2x2[4];
-	
-	const IVP_DOUBLE tpm00 = tpm.get_elem( 0, 0 );
-	const IVP_DOUBLE tpm01 = tpm.get_elem( 0, 1 );
-	const IVP_DOUBLE tpm10 = tpm.get_elem( 1, 0 );
-	const IVP_DOUBLE tpm11 = tpm.get_elem( 1, 1 );
-	
-	IVP_RETURN_TYPE ret = IVP_Inline_Math::invert_2x2_matrix( tpm00, tpm01, tpm01, tpm11, &inv_mat2x2[0], &inv_mat2x2[1],&inv_mat2x2[2],&inv_mat2x2[3] );
-	if ( ret != IVP_OK ) 
-	{
-		flEnergy = 0.0f;
-		return true;
-	}
+  IVP_DOUBLE span_s_0 =
+      span_friction_s[0] * dot_old0_new0 + span_friction_s[1] * dot_old1_new0;
+  IVP_DOUBLE span_s_1 =
+      span_friction_s[0] * dot_old0_new1 + span_friction_s[1] * dot_old1_new1;
 
-    IVP_U_Float_Point impulses;
-	impulses.k[0] = inv_mat2x2[0] * a + inv_mat2x2[1] * b;
-	impulses.k[1] = inv_mat2x2[2] * a + inv_mat2x2[3] * b;
-	
-	IVP_DOUBLE project_span_v1 = IVP_Inline_Math::fabsd( span_v_1.dot_product( &axis_ws ) );
+  // calculate pushing behaviour between wheel and car in wheel axis direction
+  IVP_DOUBLE p_wheel;
+  IVP_DOUBLE p_body;
 
-	// 
-	IVP_DOUBLE relaxation_coefficient = 0.3f;  // ~1.0f tends to oscillate
-	IVP_DOUBLE body_impulse_factor =  ( project_span_v1 * p_wheel/ p_body + 1.0f ) * relaxation_coefficient; 
-	
-	IVP_DOUBLE imp0_sqrd = impulses.k[0] * impulses.k[0];
-	IVP_DOUBLE imp1_sqrd = impulses.k[1] * impulses.k[1];
+  IVP_DOUBLE wheel_vel;
+  IVP_DOUBLE body_vel;
 
-	// check for sliding with body push
-	core_a->car_wheel->last_contact_position_ws.set( &info->contact_point_ws );
-	core_a->car_wheel->last_skid_time = es->environment->get_current_time();
+  IVP_Solver_Core_Reaction tcb;
+  tcb.init_reaction_solver_translation_ws(core_a, NULL, info->contact_point_ws,
+                                          &span_v_0, &span_v_1, NULL);
+  {
+    p_wheel = tcb.m_velocity_ds_f_impulse_ds.get_elem(1, 1);
+    wheel_vel = tcb.delta_velocity_ds.k[1];
+  }
 
-	// handbrake !!!
-    IVP_DOUBLE square_impulse;
-	if ( core_a->car_wheel->fix_wheel_constraint )
-	{
-		square_impulse = ( imp0_sqrd + imp1_sqrd ) * body_impulse_factor * body_impulse_factor;
-		
-		if ( square_impulse > maximum_impulse_force * maximum_impulse_force ) // test for sliding
-		{
-			// sliding handbrake
-			IVP_DOUBLE isum_impulse = IVP_Inline_Math::isqrt_float( square_impulse ); // body push
-			IVP_DOUBLE f = maximum_impulse_force * isum_impulse * body_impulse_factor;
-			impulses.k[0] *= f;
-			impulses.k[1] *= f;
-			
-			f /= body_impulse_factor;
-			
-			span_friction_s[0] *= f; // update reference point
-			span_friction_s[1] *= f;
-			
-			core_a->car_wheel->last_skid_value = ( 1.0f - f ) * this->now_friction_pressure * solver->body_object->get_core()->get_inv_mass();
-			//ivp_message( "handbrake factor %f\n", f);
-		}
-		else
-		{
-			// still handbrake
-			IVP_DOUBLE impulse_factor = .5f;// reduce real values to avoid jitter effects
-			impulses.k[0] *= body_impulse_factor * impulse_factor; 
-			impulses.k[1] *= body_impulse_factor * impulse_factor;
-			core_a->car_wheel->last_skid_value = 0.0f;
-		}
-	}
-	else
-	{
-		square_impulse = imp0_sqrd + imp1_sqrd * body_impulse_factor * body_impulse_factor;
-		if ( 1 && ( square_impulse > maximum_impulse_force * maximum_impulse_force ) ) 
-		{
-			// check for sliding with no body push
-			IVP_DOUBLE square2 = imp0_sqrd + imp1_sqrd;
-			if ( 1 && ( square2 > maximum_impulse_force*maximum_impulse_force ) )
-			{
-				// clip impulse on a circle
-				IVP_DOUBLE isum_impulse = IVP_Inline_Math::isqrt_float( square2 ); // no body push
-				IVP_DOUBLE f = maximum_impulse_force * isum_impulse;
-				impulses.k[0] *= f;
-				impulses.k[1] *= f;
-				
-				span_friction_s[0] *= f; // update reference point
-				span_friction_s[1] *= f;
-				core_a->car_wheel->last_skid_value = ( 1.0f - f ) * this->now_friction_pressure * solver->body_object->get_core()->get_inv_mass();
-				//ivp_message(" sliding %f factor %f\n", impulses.k[1], f );
-			}
-			else
-			{
-				// reduce body push until no sliding (clipping impulse on a elipse)
-				IVP_DOUBLE y = IVP_Inline_Math::sqrtd( maximum_impulse_force * maximum_impulse_force - imp0_sqrd );
-				IVP_DOUBLE old1 = impulses.k[1];
-				if ( impulses.k[1] > 0)
-				{
-					impulses.k[1] = y;
-				}
-				else
-				{
-					impulses.k[1] = -y;
-				}
-				
-				if ( 1 ) // update reference point
-				{
-					//span_s_1 *= 0.95f;
-					static IVP_DOUBLE extra_factor = .9f;
-					IVP_DOUBLE s_factor = extra_factor * impulses.k[1] / ( old1 * body_impulse_factor );
-					core_a->car_wheel->last_skid_value = 0.3f * ( 1.0f - s_factor ) * this->now_friction_pressure * solver->body_object->get_core()->get_inv_mass();
-					if ( s_factor < 1.0f )
-					{
-						span_s_1 *= s_factor;
-						IVP_DOUBLE s0 = span_s_0 * dot_old0_new0 + span_s_1 * dot_old0_new1;
-						IVP_DOUBLE s1 = span_s_0 * dot_old1_new0 + span_s_1 * dot_old1_new1;
-						span_friction_s[0] = s0;
-						span_friction_s[1] = s1;
-					}
-					//ivp_message(" reduced body push %f  s_factor %f\n", impulses.k[1], s_factor );
-				}
-			}
+  {
+    IVP_Solver_Core_Reaction sc_body;
+    sc_body.init_reaction_solver_translation_ws(solver->body_object->get_core(),
+                                                NULL, info->contact_point_ws,
+                                                &span_v_1, NULL, NULL);
+    p_body = sc_body.m_velocity_ds_f_impulse_ds.get_elem(0, 0);
+    body_vel = sc_body.delta_velocity_ds.k[0];
+  }
+
+  IVP_DOUBLE a = span_s_0 * es->i_delta_time - tcb.delta_velocity_ds.k[0];
+  // IVP_DOUBLE b = span_s_1 * es->i_delta_time - tcb.delta_velocity_ds.k[1];
+  IVP_DOUBLE b =
+      span_s_1 * es->i_delta_time - 1.0f * (wheel_vel * 1.0f + body_vel * 0.0f);
+
+  IVP_U_Matrix3 &tpm = tcb.m_velocity_ds_f_impulse_ds;
 
-			square_impulse = maximum_impulse_force * maximum_impulse_force;
-		}
-		else // no sliding
-		{
-			//impulses.k[1] *= body_impulse_factor;
-			//ivp_message("normal %f\n", impulses.k[1] );
-		}
-	}
+  IVP_DOUBLE inv_mat2x2[4];
 
-	tcb.exert_impulse_dim2( core_a, /*core_b*/NULL, impulses );
+  const IVP_DOUBLE tpm00 = tpm.get_elem(0, 0);
+  const IVP_DOUBLE tpm01 = tpm.get_elem(0, 1);
+  const IVP_DOUBLE tpm10 = tpm.get_elem(1, 0);
+  const IVP_DOUBLE tpm11 = tpm.get_elem(1, 1);
 
-	flEnergy = 0.0f; // current_energy
-	return true;
-}
+  IVP_RETURN_TYPE ret = IVP_Inline_Math::invert_2x2_matrix(
+      tpm00, tpm01, tpm01, tpm11, &inv_mat2x2[0], &inv_mat2x2[1],
+      &inv_mat2x2[2], &inv_mat2x2[3]);
+  if (ret != IVP_OK) {
+    flEnergy = 0.0f;
+    return true;
+  }
 
-IVP_FLOAT IVP_Contact_Point::friction_force_local_constraint_2d(const IVP_Event_Sim *es) 
-{
-    IVP_Impact_Solver_Long_Term *info = this->tmp_contact_info;
-    IVP_DOUBLE maximum_impulse_force = this->now_friction_pressure * this->real_friction_factor * es->delta_time;
-    if ( maximum_impulse_force < P_FLOAT_RES )
-		return 0.0f;
-    
-    IVP_Core *core_a = info->contact_core[0];
-    IVP_Core *core_b = info->contact_core[1];	
-	
-    if ( 1 && core_a && core_a->car_wheel && !core_b && ( next_dist_in_friction == NULL || next_dist_in_friction->now_friction_pressure == 0.0f ) )
-	{
-		IVP_FLOAT flEnergy = 0.0f;
-		if ( friction_force_local_constraint_2d_wheel( core_a, info, es, flEnergy ) )
-			return flEnergy;		
-    }
+  IVP_U_Float_Point impulses;
+  impulses.k[0] = inv_mat2x2[0] * a + inv_mat2x2[1] * b;
+  impulses.k[1] = inv_mat2x2[2] * a + inv_mat2x2[3] * b;
 
-    IVP_Solver_Core_Reaction tcb;
-	tcb.init_reaction_solver_translation_ws( core_a, core_b, info->contact_point_ws, &info->span_friction_v[0], &info->span_friction_v[1], NULL );
-	
-	IVP_DOUBLE a = span_friction_s[0] * es->i_delta_time - tcb.delta_velocity_ds.k[0];
-	IVP_DOUBLE b = span_friction_s[1] * es->i_delta_time - tcb.delta_velocity_ds.k[1];
-	
-	IVP_U_Matrix3 &tpm = tcb.m_velocity_ds_f_impulse_ds;
-	
-	IVP_DOUBLE inv_mat2x2[4];
-	
-	const IVP_DOUBLE tpm00 = tpm.get_elem( 0, 0 );
-	const IVP_DOUBLE tpm01 = tpm.get_elem( 0, 1 );
-	const IVP_DOUBLE tpm10 = tpm.get_elem( 1, 0 );
-	const IVP_DOUBLE tpm11 = tpm.get_elem( 1, 1 );
-	
-	IVP_RETURN_TYPE ret = IVP_Inline_Math::invert_2x2_matrix( tpm00, tpm01, tpm01, tpm11, &inv_mat2x2[0], &inv_mat2x2[1],&inv_mat2x2[2],&inv_mat2x2[3] );
-	if( ret != IVP_OK ) 
-		return 0.0f;
-	
-    IVP_U_Float_Point impulses;
-	impulses.k[0] = inv_mat2x2[0] * a + inv_mat2x2[1] * b;
-	impulses.k[1] = inv_mat2x2[2] * a + inv_mat2x2[3] * b;
-	
-    IVP_DOUBLE square_impulse;
-	square_impulse = impulses.k[0] * impulses.k[0] + impulses.k[1] * impulses.k[1];
-	
-	if( square_impulse > maximum_impulse_force*maximum_impulse_force ) 
-	{
-		IVP_DOUBLE isum_impulse = IVP_Inline_Math::isqrt_float(square_impulse);
-		IVP_DOUBLE f = maximum_impulse_force * isum_impulse;
-		impulses.k[0] *= f;
-		impulses.k[1] *= f;
-	}
+  IVP_DOUBLE project_span_v1 =
+      IVP_Inline_Math::fabsd(span_v_1.dot_product(&axis_ws));
 
-	tcb.exert_impulse_dim2( core_a, core_b, impulses );
+  //
+  IVP_DOUBLE relaxation_coefficient = 0.3f; // ~1.0f tends to oscillate
+  IVP_DOUBLE body_impulse_factor =
+      (project_span_v1 * p_wheel / p_body + 1.0f) * relaxation_coefficient;
 
-	// calc  current energy:
-	IVP_FLOAT e = square_impulse * es->delta_time * es->delta_time;
-	e *= ( span_friction_s[0] * span_friction_s[0] + span_friction_s[1] * span_friction_s[1] );
-	e = 0.5f * IVP_Inline_Math::ivp_sqrtf( e );  // #+# sqrt ???
-	IVP_FLOAT diff_e= e - this->old_energy_dynamic_fr;
-	this->old_energy_dynamic_fr=e;
-	return diff_e;
-}
+  IVP_DOUBLE imp0_sqrd = impulses.k[0] * impulses.k[0];
+  IVP_DOUBLE imp1_sqrd = impulses.k[1] * impulses.k[1];
 
-void IVP_Contact_Point::friction_force_local_constraint_1d(const IVP_Event_Sim *es) 
-{
-    IVP_U_Float_Point world_offset_contact;
-    IVP_DOUBLE spring_len = get_and_set_real_friction_len(&world_offset_contact);
+  // check for sliding with body push
+  core_a->car_wheel->last_contact_position_ws.set(&info->contact_point_ws);
+  core_a->car_wheel->last_skid_time = es->environment->get_current_time();
 
-    IVP_Core *core[2];
-    core[0]=this->get_synapse(0)->get_object()->friction_core;
-    core[1]=this->get_synapse(1)->get_object()->friction_core;
-    
-    IVP_IF(0) {
-      IVP_U_Float_Point debug_way_world;
-      debug_way_world.set_multiple(&world_offset_contact,spring_len);
-      //printf("lenofspring %f\n",spring_len);
-      IVP_U_Point base_p;
-      base_p.set(&tmp_contact_info->contact_point_ws);
-      IVP_U_Float_Point vec_p;
-      vec_p.set(&world_offset_contact);
-      vec_p.mult(spring_len*10000.0f);
-      char *out_text=p_make_string("f_vec");
-      core[0]->environment->add_draw_vector(&base_p,&vec_p,out_text,3);
-      P_FREE(out_text);
-    }
-    
-    IVP_DOUBLE maximum_impulse_force = this->now_friction_pressure * this->real_friction_factor *
-	es->delta_time;
-    
-    int i;
-    IVP_U_Float_Point world_speed[2];
-    for(i=0;i<2;i++) {
-	IVP_Core *c = core[i];
-	if(!c->physical_unmoveable){
-	    c->get_surface_speed(&tmp_contact_info->contact_point_cs[i],&world_speed[i]);
-	} else {
-	    world_speed[i].set_to_zero();
-	}
-    }
+  // handbrake !!!
+  IVP_DOUBLE square_impulse;
+  if (core_a->car_wheel->fix_wheel_constraint) {
+    square_impulse =
+        (imp0_sqrd + imp1_sqrd) * body_impulse_factor * body_impulse_factor;
 
-    IVP_U_Float_Point rel_world_speed;
-    rel_world_speed.subtract(&world_speed[0],&world_speed[1]);
+    if (square_impulse >
+        maximum_impulse_force * maximum_impulse_force) // test for sliding
+    {
+      // sliding handbrake
+      IVP_DOUBLE isum_impulse =
+          IVP_Inline_Math::isqrt_float(square_impulse); // body push
+      IVP_DOUBLE f = maximum_impulse_force * isum_impulse * body_impulse_factor;
+      impulses.k[0] *= f;
+      impulses.k[1] *= f;
 
-    IVP_DOUBLE now_speed_direction=world_offset_contact.dot_product(&rel_world_speed);
-    
-    IVP_U_Float_Point translation_vec[2],rotation_vec[2],push_core_vec[2];
-    IVP_DOUBLE speed_change_on_push=0.0f;
-    IVP_DOUBLE sign=1.0f;
-    
-    for(i=0;i<2;i++) {
-	IVP_Core *c = core[i];
+      f /= body_impulse_factor;
 
-	translation_vec[i].set_to_zero();
-	rotation_vec[i].set_to_zero();
-	
-	if(!c->physical_unmoveable) {
-	    IVP_U_Matrix *mat=&c->m_world_f_core_last_psi;
-	   
-	    IVP_U_Float_Point push_world_vec;
-	    push_world_vec.set(&world_offset_contact);
-	    push_world_vec.mult(sign);
-	    mat->vimult3(&push_world_vec,&push_core_vec[i]);
-	    IVP_U_Float_Point test_trans,test_rot;
-	    c->test_push_core(&tmp_contact_info->contact_point_cs[i],&push_core_vec[i],&push_world_vec,&test_trans,&test_rot);
-	    translation_vec[i].set(&test_trans);
-	    rotation_vec[i].set(&test_rot);
-	    IVP_U_Float_Point test_world;
-	    c->get_surface_speed_on_test(&tmp_contact_info->contact_point_cs[i],&test_trans,&test_rot,&test_world);
-	    speed_change_on_push+=test_world.dot_product(&push_world_vec);
-	}	
-	sign *= -1.0f;
-    }
+      span_friction_s[0] *= f; // update reference point
+      span_friction_s[1] *= f;
 
-    IVP_DOUBLE desired_speed = spring_len * es->delta_time;
-    IVP_DOUBLE diff_speed = desired_speed-now_speed_direction;
-
-    IVP_DOUBLE push_val;
-    if(speed_change_on_push>P_DOUBLE_EPS) {
-	push_val=diff_speed/speed_change_on_push;
+      core_a->car_wheel->last_skid_value =
+          (1.0f - f) * this->now_friction_pressure *
+          solver->body_object->get_core()->get_inv_mass();
+      // ivp_message( "handbrake factor %f\n", f);
     } else {
-	return;
-    }
-	
-    if(IVP_Inline_Math::fabsd(push_val) > maximum_impulse_force) {
-	push_val=maximum_impulse_force;
+      // still handbrake
+      IVP_DOUBLE impulse_factor =
+          .5f; // reduce real values to avoid jitter effects
+      impulses.k[0] *= body_impulse_factor * impulse_factor;
+      impulses.k[1] *= body_impulse_factor * impulse_factor;
+      core_a->car_wheel->last_skid_value = 0.0f;
     }
-					       
-    for(i=0;i<2;i++) {
-	IVP_Core *c = core[i];
-	
-	if(!c->physical_unmoveable) {
-	    c->speed.add_multiple(&translation_vec[i],push_val);
-	    c->rot_speed.add_multiple(&rotation_vec[i],push_val);
-	}
-    }
+  } else {
+    square_impulse =
+        imp0_sqrd + imp1_sqrd * body_impulse_factor * body_impulse_factor;
+    if (1 && (square_impulse > maximum_impulse_force * maximum_impulse_force)) {
+      // check for sliding with no body push
+      IVP_DOUBLE square2 = imp0_sqrd + imp1_sqrd;
+      if (1 && (square2 > maximum_impulse_force * maximum_impulse_force)) {
+        // clip impulse on a circle
+        IVP_DOUBLE isum_impulse =
+            IVP_Inline_Math::isqrt_float(square2); // no body push
+        IVP_DOUBLE f = maximum_impulse_force * isum_impulse;
+        impulses.k[0] *= f;
+        impulses.k[1] *= f;
 
-}
+        span_friction_s[0] *= f; // update reference point
+        span_friction_s[1] *= f;
+        core_a->car_wheel->last_skid_value =
+            (1.0f - f) * this->now_friction_pressure *
+            solver->body_object->get_core()->get_inv_mass();
+        // ivp_message(" sliding %f factor %f\n", impulses.k[1], f );
+      } else {
+        // reduce body push until no sliding (clipping impulse on a elipse)
+        IVP_DOUBLE y = IVP_Inline_Math::sqrtd(
+            maximum_impulse_force * maximum_impulse_force - imp0_sqrd);
+        IVP_DOUBLE old1 = impulses.k[1];
+        if (impulses.k[1] > 0) {
+          impulses.k[1] = y;
+        } else {
+          impulses.k[1] = -y;
+        }
 
+        if (1) // update reference point
+        {
+          // span_s_1 *= 0.95f;
+          static IVP_DOUBLE extra_factor = .9f;
+          IVP_DOUBLE s_factor =
+              extra_factor * impulses.k[1] / (old1 * body_impulse_factor);
+          core_a->car_wheel->last_skid_value =
+              0.3f * (1.0f - s_factor) * this->now_friction_pressure *
+              solver->body_object->get_core()->get_inv_mass();
+          if (s_factor < 1.0f) {
+            span_s_1 *= s_factor;
+            IVP_DOUBLE s0 = span_s_0 * dot_old0_new0 + span_s_1 * dot_old0_new1;
+            IVP_DOUBLE s1 = span_s_0 * dot_old1_new0 + span_s_1 * dot_old1_new1;
+            span_friction_s[0] = s0;
+            span_friction_s[1] = s1;
+          }
+          // ivp_message(" reduced body push %f  s_factor %f\n", impulses.k[1],
+          // s_factor );
+        }
+      }
 
-// get maximum (un)sharpness
-IVP_FLOAT IVP_Contact_Point::get_possible_friction_slide_way(const IVP_Event_Sim *) {
-    IVP_FLOAT way_passed_through_pressure;
-    way_passed_through_pressure = now_friction_pressure * real_friction_factor * inv_virt_mass_mindist_no_dir;
-    return way_passed_through_pressure;
-}
-
-IVP_FLOAT IVP_Friction_Core_Pair::get_sum_slide_way(const IVP_Event_Sim *es) {
-    IVP_FLOAT sum=0.0f;
-    for (int i = fr_dists.len()-1; i>=0; i--){
-	IVP_Contact_Point *my_fr = fr_dists.element_at(i);
-        sum += my_fr->get_possible_friction_slide_way(es);
+      square_impulse = maximum_impulse_force * maximum_impulse_force;
+    } else // no sliding
+    {
+      // impulses.k[1] *= body_impulse_factor;
+      // ivp_message("normal %f\n", impulses.k[1] );
     }
-    return sum * es->delta_time * es->delta_time;
+  }
+
+  tcb.exert_impulse_dim2(core_a, /*core_b*/ NULL, impulses);
+
+  flEnergy = 0.0f; // current_energy
+  return true;
 }
 
+IVP_FLOAT
+IVP_Contact_Point::friction_force_local_constraint_2d(const IVP_Event_Sim *es) {
+  IVP_Impact_Solver_Long_Term *info = this->tmp_contact_info;
+  IVP_DOUBLE maximum_impulse_force =
+      this->now_friction_pressure * this->real_friction_factor * es->delta_time;
+  if (maximum_impulse_force < P_FLOAT_RES)
+    return 0.0f;
 
-void IVP_Contact_Point::calc_pretension(IVP_FLOAT len)	{ // clip pretension
-  //this->cp_status = IVP_CPBS_NEEDS_RECHECK;    
-  IVP_DOUBLE qlen_of_spring = span_friction_s[0] * span_friction_s[0] + span_friction_s[1] * span_friction_s[1];
-  if( qlen_of_spring > len * len + P_FLOAT_RES )    {
-    IVP_DOUBLE ilen_of_spring = IVP_Inline_Math::isqrt_float(qlen_of_spring);
-    this->integrated_destroyed_energy += (qlen_of_spring * ilen_of_spring - len) * real_friction_factor * now_friction_pressure;
-    IVP_DOUBLE percent_of_old = len * ilen_of_spring;
-    span_friction_s[0] *= percent_of_old;
-    span_friction_s[1] *= percent_of_old;
-    this->cp_status = IVP_CPBS_NEEDS_RECHECK;    
+  IVP_Core *core_a = info->contact_core[0];
+  IVP_Core *core_b = info->contact_core[1];
+
+  if (1 && core_a && core_a->car_wheel && !core_b &&
+      (next_dist_in_friction == NULL ||
+       next_dist_in_friction->now_friction_pressure == 0.0f)) {
+    IVP_FLOAT flEnergy = 0.0f;
+    if (friction_force_local_constraint_2d_wheel(core_a, info, es, flEnergy))
+      return flEnergy;
   }
-}
 
-// some comments about two friction values:
-//   At the moment the direction of the friction spring is adjusted in a way it is
-//   shortened in direction of the lower second value.
-//   For the old friction_force_local_constraint this has not the desired effect.
-//   The contact points are pushed in a 2D manner (friction_span_vectors to span 2D)
-//   to reach the desired positions. This means more force in direction of the lower
-//   friction is applied.
-//   Therefore now the two friction case is handled with a 1D local constraint.
-//   That means that no unallowed force toward second friction direction is applied
-//   However, the 1D local constraint is inaccurate and looses contact over the time :-(
-//   The best solution would be to make a 2D local constraint for the two value case
-//   and span the 2D with the vector of second direction and an orthogonal one. Then
-//   we have to clip the force done on the second direction.
+  IVP_Solver_Core_Reaction tcb;
+  tcb.init_reaction_solver_translation_ws(
+      core_a, core_b, info->contact_point_ws, &info->span_friction_v[0],
+      &info->span_friction_v[1], NULL);
 
-void IVP_Friction_Core_Pair::pair_calc_friction_forces(const IVP_Event_Sim *es) {
-    IVP_FLOAT max_local_spring_len = get_sum_slide_way(es);
+  IVP_DOUBLE a =
+      span_friction_s[0] * es->i_delta_time - tcb.delta_velocity_ds.k[0];
+  IVP_DOUBLE b =
+      span_friction_s[1] * es->i_delta_time - tcb.delta_velocity_ds.k[1];
 
-    IVP_FLOAT sum_delta_energy=0.0f;
-    
-    for (int k = fr_dists.len()-1; k>=0; k--){
-	IVP_Contact_Point *my_fr = fr_dists.element_at(k);
-	my_fr->calc_pretension( max_local_spring_len );
-	
-	IVP_ASSERT(my_fr->tmp_contact_info->coll_time_is_valid == IVP_FALSE);
-	if(my_fr->two_friction_values!=IVP_TRUE) {
-	    sum_delta_energy += my_fr->friction_force_local_constraint_2d(es);
-	} else {
-	    my_fr->friction_force_local_constraint_1d(es);
-	}
-    }
+  IVP_U_Matrix3 &tpm = tcb.m_velocity_ds_f_impulse_ds;
 
-    if((sum_delta_energy>0.0f)) {
-	integrated_anti_energy+=sum_delta_energy;
-    }
-}
+  IVP_DOUBLE inv_mat2x2[4];
 
-void IVP_Friction_System::calc_friction_forces(const IVP_Event_Sim *es) {
-    for (int i = fr_pairs_of_objs.len()-1; i>=0; i--){
-	IVP_Friction_Core_Pair *my_pair = fr_pairs_of_objs.element_at(i);
-    //printf("having_core_pairs  ");
-	IVP_IF(my_pair->fr_dists.len() == 0) {
-	    printf("\n\n\n warngin: empty core pair\n");
-	}
-	my_pair->pair_calc_friction_forces(es);
-    }
-    //printf("\n");
-}
+  const IVP_DOUBLE tpm00 = tpm.get_elem(0, 0);
+  const IVP_DOUBLE tpm01 = tpm.get_elem(0, 1);
+  const IVP_DOUBLE tpm10 = tpm.get_elem(1, 0);
+  const IVP_DOUBLE tpm11 = tpm.get_elem(1, 1);
 
-IVP_FLOAT IVP_Contact_Point::get_friction_factor() {
-	return span_friction_s[0] * span_friction_s[1];
-}
+  IVP_RETURN_TYPE ret = IVP_Inline_Math::invert_2x2_matrix(
+      tpm00, tpm01, tpm01, tpm11, &inv_mat2x2[0], &inv_mat2x2[1],
+      &inv_mat2x2[2], &inv_mat2x2[3]);
+  if (ret != IVP_OK)
+    return 0.0f;
 
-void IVP_Contact_Point::set_friction_to_neutral(){
-    span_friction_s[0] = 0.0f;
-    span_friction_s[1] = 0.0f;    
-}
+  IVP_U_Float_Point impulses;
+  impulses.k[0] = inv_mat2x2[0] * a + inv_mat2x2[1] * b;
+  impulses.k[1] = inv_mat2x2[2] * a + inv_mat2x2[3] * b;
 
-void IVP_Friction_Info_For_Core::set_all_dists_of_obj_neutral()
-{
-    for (int i = friction_springs.len()-1; i>=0; i--){
-	IVP_Contact_Point *minfr = friction_springs.element_at(i);
-	minfr->set_friction_to_neutral();
-    }
-}
+  IVP_DOUBLE square_impulse;
+  square_impulse =
+      impulses.k[0] * impulses.k[0] + impulses.k[1] * impulses.k[1];
 
+  if (square_impulse > maximum_impulse_force * maximum_impulse_force) {
+    IVP_DOUBLE isum_impulse = IVP_Inline_Math::isqrt_float(square_impulse);
+    IVP_DOUBLE f = maximum_impulse_force * isum_impulse;
+    impulses.k[0] *= f;
+    impulses.k[1] *= f;
+  }
 
-void IVP_Contact_Point::ease_the_friction_force(IVP_U_Float_Point *ease_diff_vec){
-    IVP_Impact_Solver_Long_Term *info = tmp_contact_info;
-    this->span_friction_s[0] += ease_diff_vec->dot_product(&info->span_friction_v[0]);
-    this->span_friction_s[1] += ease_diff_vec->dot_product(&info->span_friction_v[1]);
-    return;
+  tcb.exert_impulse_dim2(core_a, core_b, impulses);
+
+  // calc  current energy:
+  IVP_FLOAT e = square_impulse * es->delta_time * es->delta_time;
+  e *= (span_friction_s[0] * span_friction_s[0] +
+        span_friction_s[1] * span_friction_s[1]);
+  e = 0.5f * IVP_Inline_Math::ivp_sqrtf(e); // #+# sqrt ???
+  IVP_FLOAT diff_e = e - this->old_energy_dynamic_fr;
+  this->old_energy_dynamic_fr = e;
+  return diff_e;
 }
 
-void IVP_Friction_Solver::ease_test_two_mindists(IVP_Contact_Point *dist0,IVP_Contact_Point *dist1,IVP_U_Float_Point *world_surf_normal)
-{
-    IVP_USE(dist1);
-    IVP_USE(dist0);
-    IVP_USE(world_surf_normal);
-#ifdef NOEASING
-    return;
-#endif
-#if 0   
-    IVP_Core *rev_core; 
-    rev_core=dist0->synapse[0]->l_obj->to_real()->physical_core; //forces seen relative to this core
+void IVP_Contact_Point::friction_force_local_constraint_1d(
+    const IVP_Event_Sim *es) {
+  IVP_U_Float_Point world_offset_contact;
+  IVP_DOUBLE spring_len = get_and_set_real_friction_len(&world_offset_contact);
+
+  IVP_Core *core[2];
+  core[0] = this->get_synapse(0)->get_object()->friction_core;
+  core[1] = this->get_synapse(1)->get_object()->friction_core;
+
+  IVP_IF(0) {
+    IVP_U_Float_Point debug_way_world;
+    debug_way_world.set_multiple(&world_offset_contact, spring_len);
+    // printf("lenofspring %f\n",spring_len);
+    IVP_U_Point base_p;
+    base_p.set(&tmp_contact_info->contact_point_ws);
+    IVP_U_Float_Point vec_p;
+    vec_p.set(&world_offset_contact);
+    vec_p.mult(spring_len * 10000.0f);
+    char *out_text = p_make_string("f_vec");
+    core[0]->environment->add_draw_vector(&base_p, &vec_p, out_text, 3);
+    P_FREE(out_text);
+  }
+
+  IVP_DOUBLE maximum_impulse_force =
+      this->now_friction_pressure * this->real_friction_factor * es->delta_time;
+
+  int i;
+  IVP_U_Float_Point world_speed[2];
+  for (i = 0; i < 2; i++) {
+    IVP_Core *c = core[i];
+    if (!c->physical_unmoveable) {
+      c->get_surface_speed(&tmp_contact_info->contact_point_cs[i],
+                           &world_speed[i]);
+    } else {
+      world_speed[i].set_to_zero();
+    }
+  }
+
+  IVP_U_Float_Point rel_world_speed;
+  rel_world_speed.subtract(&world_speed[0], &world_speed[1]);
+
+  IVP_DOUBLE now_speed_direction =
+      world_offset_contact.dot_product(&rel_world_speed);
+
+  IVP_U_Float_Point translation_vec[2], rotation_vec[2], push_core_vec[2];
+  IVP_DOUBLE speed_change_on_push = 0.0f;
+  IVP_DOUBLE sign = 1.0f;
+
+  for (i = 0; i < 2; i++) {
+    IVP_Core *c = core[i];
+
+    translation_vec[i].set_to_zero();
+    rotation_vec[i].set_to_zero();
+
+    if (!c->physical_unmoveable) {
+      IVP_U_Matrix *mat = &c->m_world_f_core_last_psi;
+
+      IVP_U_Float_Point push_world_vec;
+      push_world_vec.set(&world_offset_contact);
+      push_world_vec.mult(sign);
+      mat->vimult3(&push_world_vec, &push_core_vec[i]);
+      IVP_U_Float_Point test_trans, test_rot;
+      c->test_push_core(&tmp_contact_info->contact_point_cs[i],
+                        &push_core_vec[i], &push_world_vec, &test_trans,
+                        &test_rot);
+      translation_vec[i].set(&test_trans);
+      rotation_vec[i].set(&test_rot);
+      IVP_U_Float_Point test_world;
+      c->get_surface_speed_on_test(&tmp_contact_info->contact_point_cs[i],
+                                   &test_trans, &test_rot, &test_world);
+      speed_change_on_push += test_world.dot_product(&push_world_vec);
+    }
+    sign *= -1.0f;
+  }
+
+  IVP_DOUBLE desired_speed = spring_len * es->delta_time;
+  IVP_DOUBLE diff_speed = desired_speed - now_speed_direction;
+
+  IVP_DOUBLE push_val;
+  if (speed_change_on_push > P_DOUBLE_EPS) {
+    push_val = diff_speed / speed_change_on_push;
+  } else {
+    return;
+  }
+
+  if (IVP_Inline_Math::fabsd(push_val) > maximum_impulse_force) {
+    push_val = maximum_impulse_force;
+  }
+
+  for (i = 0; i < 2; i++) {
+    IVP_Core *c = core[i];
+
+    if (!c->physical_unmoveable) {
+      c->speed.add_multiple(&translation_vec[i], push_val);
+      c->rot_speed.add_multiple(&rotation_vec[i], push_val);
+    }
+  }
+}
+
+// get maximum (un)sharpness
+IVP_FLOAT
+IVP_Contact_Point::get_possible_friction_slide_way(const IVP_Event_Sim *) {
+  IVP_FLOAT way_passed_through_pressure;
+  way_passed_through_pressure = now_friction_pressure * real_friction_factor *
+                                inv_virt_mass_mindist_no_dir;
+  return way_passed_through_pressure;
+}
+
+IVP_FLOAT IVP_Friction_Core_Pair::get_sum_slide_way(const IVP_Event_Sim *es) {
+  IVP_FLOAT sum = 0.0f;
+  for (int i = fr_dists.len() - 1; i >= 0; i--) {
+    IVP_Contact_Point *my_fr = fr_dists.element_at(i);
+    sum += my_fr->get_possible_friction_slide_way(es);
+  }
+  return sum * es->delta_time * es->delta_time;
+}
+
+void IVP_Contact_Point::calc_pretension(IVP_FLOAT len) { // clip pretension
+  // this->cp_status = IVP_CPBS_NEEDS_RECHECK;
+  IVP_DOUBLE qlen_of_spring = span_friction_s[0] * span_friction_s[0] +
+                              span_friction_s[1] * span_friction_s[1];
+  if (qlen_of_spring > len * len + P_FLOAT_RES) {
+    IVP_DOUBLE ilen_of_spring = IVP_Inline_Math::isqrt_float(qlen_of_spring);
+    this->integrated_destroyed_energy +=
+        (qlen_of_spring * ilen_of_spring - len) * real_friction_factor *
+        now_friction_pressure;
+    IVP_DOUBLE percent_of_old = len * ilen_of_spring;
+    span_friction_s[0] *= percent_of_old;
+    span_friction_s[1] *= percent_of_old;
+    this->cp_status = IVP_CPBS_NEEDS_RECHECK;
+  }
+}
+
+// some comments about two friction values:
+//   At the moment the direction of the friction spring is adjusted in a way it
+//   is shortened in direction of the lower second value. For the old
+//   friction_force_local_constraint this has not the desired effect. The
+//   contact points are pushed in a 2D manner (friction_span_vectors to span 2D)
+//   to reach the desired positions. This means more force in direction of the
+//   lower friction is applied. Therefore now the two friction case is handled
+//   with a 1D local constraint. That means that no unallowed force toward
+//   second friction direction is applied However, the 1D local constraint is
+//   inaccurate and looses contact over the time :-( The best solution would be
+//   to make a 2D local constraint for the two value case and span the 2D with
+//   the vector of second direction and an orthogonal one. Then we have to clip
+//   the force done on the second direction.
+
+void IVP_Friction_Core_Pair::pair_calc_friction_forces(
+    const IVP_Event_Sim *es) {
+  IVP_FLOAT max_local_spring_len = get_sum_slide_way(es);
+
+  IVP_FLOAT sum_delta_energy = 0.0f;
+
+  for (int k = fr_dists.len() - 1; k >= 0; k--) {
+    IVP_Contact_Point *my_fr = fr_dists.element_at(k);
+    my_fr->calc_pretension(max_local_spring_len);
+
+    IVP_ASSERT(my_fr->tmp_contact_info->coll_time_is_valid == IVP_FALSE);
+    if (my_fr->two_friction_values != IVP_TRUE) {
+      sum_delta_energy += my_fr->friction_force_local_constraint_2d(es);
+    } else {
+      my_fr->friction_force_local_constraint_1d(es);
+    }
+  }
+
+  if ((sum_delta_energy > 0.0f)) {
+    integrated_anti_energy += sum_delta_energy;
+  }
+}
+
+void IVP_Friction_System::calc_friction_forces(const IVP_Event_Sim *es) {
+  for (int i = fr_pairs_of_objs.len() - 1; i >= 0; i--) {
+    IVP_Friction_Core_Pair *my_pair = fr_pairs_of_objs.element_at(i);
+    // printf("having_core_pairs  ");
+    IVP_IF(my_pair->fr_dists.len() == 0) {
+      printf("\n\n\n warngin: empty core pair\n");
+    }
+    my_pair->pair_calc_friction_forces(es);
+  }
+  // printf("\n");
+}
+
+IVP_FLOAT IVP_Contact_Point::get_friction_factor() {
+  return span_friction_s[0] * span_friction_s[1];
+}
+
+void IVP_Contact_Point::set_friction_to_neutral() {
+  span_friction_s[0] = 0.0f;
+  span_friction_s[1] = 0.0f;
+}
+
+void IVP_Friction_Info_For_Core::set_all_dists_of_obj_neutral() {
+  for (int i = friction_springs.len() - 1; i >= 0; i--) {
+    IVP_Contact_Point *minfr = friction_springs.element_at(i);
+    minfr->set_friction_to_neutral();
+  }
+}
+
+void IVP_Contact_Point::ease_the_friction_force(
+    IVP_U_Float_Point *ease_diff_vec) {
+  IVP_Impact_Solver_Long_Term *info = tmp_contact_info;
+  this->span_friction_s[0] +=
+      ease_diff_vec->dot_product(&info->span_friction_v[0]);
+  this->span_friction_s[1] +=
+      ease_diff_vec->dot_product(&info->span_friction_v[1]);
+  return;
+}
+
+void IVP_Friction_Solver::ease_test_two_mindists(
+    IVP_Contact_Point *dist0, IVP_Contact_Point *dist1,
+    IVP_U_Float_Point *world_surf_normal) {
+  IVP_USE(dist1);
+  IVP_USE(dist0);
+  IVP_USE(world_surf_normal);
+#ifdef NOEASING
+  return;
+#endif
+#if 0   
+    IVP_Core *rev_core; 
+    rev_core=dist0->synapse[0]->l_obj->to_real()->physical_core; //forces seen relative to this core
     
     IVP_real_friction_data fr_data0,fr_data1;
     dist0->get_world_friction_forces_dist(&fr_data0,0);
@@ -742,209 +793,220 @@
 	printf("diff %f l0 %f l1 %f\n",lendiff,force0_vec.real_length(),force1_vec.real_length());
 	printf("   parallel_ease %f %f %f   %f %f %f\n",force0_vec.k[0],force0_vec.k[1],force0_vec.k[2],force1_vec.k[0],force1_vec.k[1],force1_vec.k[2]);
     }
-#endif    
+#endif
 }
 
-void IVP_Friction_Solver::ease_two_mindists(IVP_Contact_Point *dist0,IVP_Contact_Point *dist1,
-					    IVP_U_Float_Point *ease_diff_vec0,IVP_U_Float_Point *ease_diff_vec1,
-					    IVP_DOUBLE ease_factor) 
-{    
-    IVP_Core *rev_core=dist0->get_synapse(0)->l_obj->physical_core; //forces seen relative to this core
+void IVP_Friction_Solver::ease_two_mindists(IVP_Contact_Point *dist0,
+                                            IVP_Contact_Point *dist1,
+                                            IVP_U_Float_Point *ease_diff_vec0,
+                                            IVP_U_Float_Point *ease_diff_vec1,
+                                            IVP_DOUBLE ease_factor) {
+  IVP_Core *rev_core =
+      dist0->get_synapse(0)
+          ->l_obj->physical_core; // forces seen relative to this core
 
-    int second_core_reversed;
-    IVP_FLOAT reverse_factor;
-    if(rev_core!=dist1->get_synapse(0)->l_obj->physical_core) {
-	second_core_reversed=1;
-	reverse_factor = -1.0f;
-    } else {
-	second_core_reversed=0;
-	reverse_factor = 1.0f;
-    }
-    
-    IVP_Impact_Solver_Long_Term *info0 = dist0->tmp_contact_info;
-    IVP_Impact_Solver_Long_Term *info1 = dist1->tmp_contact_info;
+  int second_core_reversed;
+  IVP_FLOAT reverse_factor;
+  if (rev_core != dist1->get_synapse(0)->l_obj->physical_core) {
+    second_core_reversed = 1;
+    reverse_factor = -1.0f;
+  } else {
+    second_core_reversed = 0;
+    reverse_factor = 1.0f;
+  }
 
-    IVP_U_Float_Point world_vec0,world_vec1;
-    world_vec0.set_multiple(&info0->span_friction_v[0],dist0->span_friction_s[0]);
-    world_vec0.add_multiple(&info0->span_friction_v[1],dist0->span_friction_s[1]);
+  IVP_Impact_Solver_Long_Term *info0 = dist0->tmp_contact_info;
+  IVP_Impact_Solver_Long_Term *info1 = dist1->tmp_contact_info;
 
-    world_vec1.set_multiple(&info1->span_friction_v[0],dist1->span_friction_s[0]);
-    world_vec1.add_multiple(&info1->span_friction_v[1],dist1->span_friction_s[1]);
+  IVP_U_Float_Point world_vec0, world_vec1;
+  world_vec0.set_multiple(&info0->span_friction_v[0],
+                          dist0->span_friction_s[0]);
+  world_vec0.add_multiple(&info0->span_friction_v[1],
+                          dist0->span_friction_s[1]);
 
-    IVP_U_Point *world_point[2];
-    world_point[0] = &info0->contact_point_ws;
-    world_point[1] = &info1->contact_point_ws;
-    
-    IVP_U_Float_Point world_connection;
-    world_connection.subtract(world_point[0],world_point[1]);
+  world_vec1.set_multiple(&info1->span_friction_v[0],
+                          dist1->span_friction_s[0]);
+  world_vec1.add_multiple(&info1->span_friction_v[1],
+                          dist1->span_friction_s[1]);
 
-    IVP_IF(0) {
-	const char *out_text=p_make_string("ease");
-	rev_core->environment->add_draw_vector(world_point[1],&world_connection,out_text,3);
-	P_FREE(out_text);
-    }
+  IVP_U_Point *world_point[2];
+  world_point[0] = &info0->contact_point_ws;
+  world_point[1] = &info1->contact_point_ws;
 
-    world_connection.fast_normize();
-    
-    IVP_U_Float_Point ease_part0,ease_part1;
-    IVP_DOUBLE part_val0 = world_connection.dot_product(&world_vec0);    
-    IVP_DOUBLE part_val1 = world_connection.dot_product(&world_vec1);
-    
-    ease_part0.set_multiple(&world_connection,part_val0);
-    ease_part1.set_multiple(&world_connection,part_val1 * reverse_factor);
+  IVP_U_Float_Point world_connection;
+  world_connection.subtract(world_point[0], world_point[1]);
 
-    IVP_U_Float_Point optimal_vec;
-    optimal_vec.add(&ease_part0,&ease_part1);
-    optimal_vec.mult(0.5f);
+  IVP_IF(0) {
+    const char *out_text = p_make_string("ease");
+    rev_core->environment->add_draw_vector(world_point[1], &world_connection,
+                                           out_text, 3);
+    P_FREE(out_text);
+  }
 
-    IVP_U_Float_Point diff_vec0,diff_vec1;
-    diff_vec0.inline_subtract_and_mult(&optimal_vec,&ease_part0,ease_factor); //no full easing
-    diff_vec1.inline_subtract_and_mult(&optimal_vec,&ease_part1,ease_factor * reverse_factor);
+  world_connection.fast_normize();
 
-    ease_diff_vec0->add(&diff_vec0);
-    ease_diff_vec1->add(&diff_vec1);
+  IVP_U_Float_Point ease_part0, ease_part1;
+  IVP_DOUBLE part_val0 = world_connection.dot_product(&world_vec0);
+  IVP_DOUBLE part_val1 = world_connection.dot_product(&world_vec1);
+
+  ease_part0.set_multiple(&world_connection, part_val0);
+  ease_part1.set_multiple(&world_connection, part_val1 * reverse_factor);
+
+  IVP_U_Float_Point optimal_vec;
+  optimal_vec.add(&ease_part0, &ease_part1);
+  optimal_vec.mult(0.5f);
+
+  IVP_U_Float_Point diff_vec0, diff_vec1;
+  diff_vec0.inline_subtract_and_mult(&optimal_vec, &ease_part0,
+                                     ease_factor); // no full easing
+  diff_vec1.inline_subtract_and_mult(&optimal_vec, &ease_part1,
+                                     ease_factor * reverse_factor);
+
+  ease_diff_vec0->add(&diff_vec0);
+  ease_diff_vec1->add(&diff_vec1);
 }
 
-void IVP_Friction_Solver::ease_friction_pair(IVP_Friction_Core_Pair *my_pair,IVP_U_Memory *my_mem)
-{
-    //IVP_U_Float_Point average_v;
-    //my_pair->get_average_friction_vector(&average_v);
-    //my_pair->set_friction_vectors(&average_v);
-    //return;
-    
-    int total_n = my_pair->number_of_pair_dists();
-    IVP_Contact_Point **all_my_dists=(IVP_Contact_Point**)my_mem->get_mem(total_n*sizeof(IVP_Contact_Point*));
+void IVP_Friction_Solver::ease_friction_pair(IVP_Friction_Core_Pair *my_pair,
+                                             IVP_U_Memory *my_mem) {
+  // IVP_U_Float_Point average_v;
+  // my_pair->get_average_friction_vector(&average_v);
+  // my_pair->set_friction_vectors(&average_v);
+  // return;
 
-    IVP_DOUBLE easing_factor = 1.0f/((IVP_DOUBLE)total_n + P_DOUBLE_EPS);
-    
+  int total_n = my_pair->number_of_pair_dists();
+  IVP_Contact_Point **all_my_dists = (IVP_Contact_Point **)my_mem->get_mem(
+      total_n * sizeof(IVP_Contact_Point *));
+
+  IVP_DOUBLE easing_factor = 1.0f / ((IVP_DOUBLE)total_n + P_DOUBLE_EPS);
+
 #if defined(IVP_NO_ALLOCA)
-    IVP_U_Float_Point *ease_diff_force_vec_stack = (IVP_U_Float_Point*)my_mem->get_mem(total_n*sizeof(IVP_U_Float_Point));
+  IVP_U_Float_Point *ease_diff_force_vec_stack =
+      (IVP_U_Float_Point *)my_mem->get_mem(total_n * sizeof(IVP_U_Float_Point));
 #else
-    IVP_U_Float_Point *ease_diff_force_vec_stack=(IVP_U_Float_Point*)alloca(total_n*sizeof(IVP_U_Float_Point));
-#endif    
-    
-    int i=0;
-    for (i = my_pair->fr_dists.len()-1; i>=0;i--){
-	IVP_Contact_Point *fr_dist = my_pair->fr_dists.element_at(i);
-	all_my_dists[i]=fr_dist;
-	ease_diff_force_vec_stack[i].set_to_zero();
+  IVP_U_Float_Point *ease_diff_force_vec_stack =
+      (IVP_U_Float_Point *)alloca(total_n * sizeof(IVP_U_Float_Point));
+#endif
+
+  int i = 0;
+  for (i = my_pair->fr_dists.len() - 1; i >= 0; i--) {
+    IVP_Contact_Point *fr_dist = my_pair->fr_dists.element_at(i);
+    all_my_dists[i] = fr_dist;
+    ease_diff_force_vec_stack[i].set_to_zero();
+  }
+
+  IVP_IF(0) {
+    printf("ease_testt\n");
+    for (i = 0; i < total_n - 1; i++) {
+      IVP_Contact_Point *fr_dist = all_my_dists[i];
+      if ((fr_dist->now_friction_pressure > P_DOUBLE_EPS) || 1) {
+        for (int j = i + 1; j < total_n; j++) {
+          IVP_Contact_Point *fr_dist2;
+          fr_dist2 = all_my_dists[j];
+          if ((fr_dist2->now_friction_pressure > P_DOUBLE_EPS) || 1) {
+            IVP_DOUBLE dir_conform = fr_dist->get_lt()->surf_normal.dot_product(
+                &fr_dist2->get_lt()->surf_normal); // near -1.0f or near 1.0f
+            dir_conform = IVP_Inline_Math::fabsd(dir_conform) - 1.0f;
+            dir_conform = IVP_Inline_Math::fabsd(dir_conform);
+            // printf("dirconform %f\n",dir_conform);
+            if ((dir_conform < 1E-3f) ||
+                0) // due to random stray in distances the vectors between
+                   // point-surface and edge-edge are not really parallel
+            {
+              // printf("teest ");
+              ease_test_two_mindists(fr_dist2, fr_dist,
+                                     &fr_dist->get_lt()->surf_normal);
+              // ease_two_mindists(fr_dist2,fr_dist,&world_normal1);
+              // ease_two_mindists(fr_dist2,fr_dist,&world_normal1);
+              // printf("three_eases done \n");
+            } else {
+              // printf("noeasingstarted\n");
+            }
+          }
+        }
+      }
     }
-    
-    IVP_IF(0)    {
-	printf("ease_testt\n");
-	for(i=0;i<total_n-1;i++)
-	{
-	    IVP_Contact_Point *fr_dist=all_my_dists[i];
-	    if((fr_dist->now_friction_pressure>P_DOUBLE_EPS)||1)
-	    {
-		for(int j=i+1;j<total_n;j++)
-		{
-		    IVP_Contact_Point *fr_dist2;
-		    fr_dist2=all_my_dists[j];
-		    if((fr_dist2->now_friction_pressure>P_DOUBLE_EPS)||1)
-		    {
-			IVP_DOUBLE dir_conform=fr_dist->get_lt()->surf_normal.dot_product(&fr_dist2->get_lt()->surf_normal); //near -1.0f or near 1.0f
-			dir_conform=IVP_Inline_Math::fabsd(dir_conform)-1.0f;
-			dir_conform=IVP_Inline_Math::fabsd(dir_conform);
-			//printf("dirconform %f\n",dir_conform);
-			if((dir_conform<1E-3f)||0) //due to random stray in distances the vectors between point-surface and edge-edge are not really parallel
-			{
-			    //printf("teest ");
-			    ease_test_two_mindists(fr_dist2,fr_dist,&fr_dist->get_lt()->surf_normal);
-			    //ease_two_mindists(fr_dist2,fr_dist,&world_normal1);
-			    //ease_two_mindists(fr_dist2,fr_dist,&world_normal1);
-			    //printf("three_eases done \n");
-			} else {
-			    //printf("noeasingstarted\n");
-			}
-		    }
-		}
-	    }
-	}
-    }
-    //printf("real_easing\n");
+  }
+  // printf("real_easing\n");
 
-    IVP_IF(1) {
-	my_pair->debug_store_vector_before_ease();
+  IVP_IF(1) { my_pair->debug_store_vector_before_ease(); }
+
+  for (i = 0; i < total_n - 1; i++) {
+    IVP_Contact_Point *fr_dist = all_my_dists[i];
+    if ((fr_dist->now_friction_pressure > P_DOUBLE_EPS) || 1) {
+      for (int j = i + 1; j < total_n; j++) {
+        // printf("epair %d %d\n",i,j);
+        IVP_Contact_Point *fr_dist2 = all_my_dists[j];
+        if ((fr_dist2->now_friction_pressure > P_DOUBLE_EPS) || 1) {
+          IVP_DOUBLE dir_conform = fr_dist->get_lt()->surf_normal.dot_product(
+              &fr_dist2->get_lt()->surf_normal); // near -1.0f or near 1.0f
+
+          dir_conform = IVP_Inline_Math::fabsd(dir_conform) - 1.0f;
+          dir_conform = IVP_Inline_Math::fabsd(dir_conform);
+          // printf("dirconform %f\n",dir_conform);
+          if ((dir_conform < 1E-3f) ||
+              0) // due to random stray in distances the vectors between
+                 // point-surface and edge-edge are not really parallel
+          {
+            // printf("eaase ");
+            ease_two_mindists(fr_dist2, fr_dist, &ease_diff_force_vec_stack[j],
+                              &ease_diff_force_vec_stack[i], easing_factor);
+            // ease_two_mindists(fr_dist2,fr_dist,&world_normal1);
+            // ease_two_mindists(fr_dist2,fr_dist,&world_normal1);
+            // printf("three_eases done \n");
+          } else {
+            // printf("noeasingstarted\n");
+          }
+        }
+      }
     }
-    
-    for(i=0;i<total_n-1;i++){
-	IVP_Contact_Point *fr_dist=all_my_dists[i];
-	if((fr_dist->now_friction_pressure>P_DOUBLE_EPS)||1){
-	    for(int j=i+1;j<total_n;j++){
-		//printf("epair %d %d\n",i,j);
-		IVP_Contact_Point *fr_dist2 = all_my_dists[j];
-		if((fr_dist2->now_friction_pressure>P_DOUBLE_EPS)||1){
-		    IVP_DOUBLE dir_conform=fr_dist->get_lt()->surf_normal.dot_product(&fr_dist2->get_lt()->surf_normal); //near -1.0f or near 1.0f
-		    
-		    dir_conform=IVP_Inline_Math::fabsd(dir_conform)-1.0f;
-		    dir_conform=IVP_Inline_Math::fabsd(dir_conform);
-		    //printf("dirconform %f\n",dir_conform);
-		    if((dir_conform<1E-3f)||0) //due to random stray in distances the vectors between point-surface and edge-edge are not really parallel
-		    {
-		        //printf("eaase ");
-			ease_two_mindists(fr_dist2,fr_dist,&ease_diff_force_vec_stack[j],&ease_diff_force_vec_stack[i],easing_factor);
-			//ease_two_mindists(fr_dist2,fr_dist,&world_normal1);
-			//ease_two_mindists(fr_dist2,fr_dist,&world_normal1);
-			//printf("three_eases done \n");
-		    } else {
-			//printf("noeasingstarted\n");
-		    }
-		}
-	    }
-	}
-    }
+  }
 
-    if(1)    {
-	//printf("set_the_friction_force\n");
-	for(i=0;i<total_n;i++)	{
-	    IVP_Contact_Point *fr_dist=all_my_dists[i];
-	    if((fr_dist->now_friction_pressure>P_DOUBLE_EPS)||1)	    {
-		fr_dist->ease_the_friction_force(&ease_diff_force_vec_stack[i]);
-	    }
-	}
+  if (1) {
+    // printf("set_the_friction_force\n");
+    for (i = 0; i < total_n; i++) {
+      IVP_Contact_Point *fr_dist = all_my_dists[i];
+      if ((fr_dist->now_friction_pressure > P_DOUBLE_EPS) || 1) {
+        fr_dist->ease_the_friction_force(&ease_diff_force_vec_stack[i]);
+      }
     }
+  }
 
-    IVP_IF(1) {
-	my_pair->debug_read_vector_after_ease();
+  IVP_IF(1) { my_pair->debug_read_vector_after_ease(); }
+
+  IVP_IF(0) {
+    printf("ease_testt\n");
+    for (i = 0; i < total_n - 1; i++) {
+      IVP_Contact_Point *fr_dist = all_my_dists[i];
+      if ((fr_dist->now_friction_pressure > P_DOUBLE_EPS) || 1) {
+        for (int j = i + 1; j < total_n; j++) {
+          IVP_Contact_Point *fr_dist2;
+          fr_dist2 = all_my_dists[j];
+          if ((fr_dist2->now_friction_pressure > P_DOUBLE_EPS) || 1) {
+            IVP_DOUBLE dir_conform = fr_dist->get_lt()->surf_normal.dot_product(
+                &fr_dist2->get_lt()->surf_normal); // near -1.0f or near 1.0f
+            dir_conform = IVP_Inline_Math::fabsd(dir_conform) - 1.0f;
+            dir_conform = IVP_Inline_Math::fabsd(dir_conform);
+            // printf("dirconform %f\n",dir_conform);
+            if ((dir_conform < 1E-3f) ||
+                0) // due to random stray in distances the vectors between
+                   // point-surface and edge-edge are not really parallel
+            {
+              // printf("teest ");
+              IVP_Friction_Solver::ease_test_two_mindists(
+                  fr_dist2, fr_dist, &fr_dist->get_lt()->surf_normal);
+              // ease_two_mindists(fr_dist2,fr_dist,&world_normal1);
+              // ease_two_mindists(fr_dist2,fr_dist,&world_normal1);
+              // printf("three_eases done \n");
+            } else {
+              // printf("noeasingstarted\n");
+            }
+          }
+        }
+      }
     }
-    
-    IVP_IF(0)
-    {    
-	printf("ease_testt\n");
-	for(i=0;i<total_n-1;i++){
-	    IVP_Contact_Point *fr_dist=all_my_dists[i];
-	    if((fr_dist->now_friction_pressure>P_DOUBLE_EPS)||1)
-	    {
-		for(int j=i+1;j<total_n;j++)
-		{
-		    IVP_Contact_Point *fr_dist2;
-		    fr_dist2=all_my_dists[j];
-		    if((fr_dist2->now_friction_pressure>P_DOUBLE_EPS)||1)
-		    {
-			IVP_DOUBLE dir_conform=fr_dist->get_lt()->surf_normal.dot_product(&fr_dist2->get_lt()->surf_normal); //near -1.0f or near 1.0f
-			dir_conform=IVP_Inline_Math::fabsd(dir_conform)-1.0f;
-			dir_conform=IVP_Inline_Math::fabsd(dir_conform);
-			//printf("dirconform %f\n",dir_conform);
-			if((dir_conform<1E-3f)||0) //due to random stray in distances the vectors between point-surface and edge-edge are not really parallel
-			{
-			    //printf("teest ");
-			    IVP_Friction_Solver::ease_test_two_mindists(fr_dist2,fr_dist,&fr_dist->get_lt()->surf_normal);
-			    //ease_two_mindists(fr_dist2,fr_dist,&world_normal1);
-			    //ease_two_mindists(fr_dist2,fr_dist,&world_normal1);
-			    //printf("three_eases done \n");
-			} else {
-			    //printf("noeasingstarted\n");
-			}
-		    }
-		}
-	    }
-	}
-    }
+  }
 }
 
-
-
 #if 0 /* not needed any more (snief), but function is correct */
 	 //given rot and trans of a core and a surface normal. wanted virtual center p in surface where no translation exists (relative to surface  2D!) 
 IVP_RETURN_TYPE IVP_Friction_Solver::calc_virtual_rotation_center(IVP_Core *core,IVP_U_Float_Point *rotation,IVP_U_Float_Point *translation,IVP_U_Float_Point *surf_normal,IVP_U_Float_Point *obj_p_out)
@@ -979,286 +1041,291 @@
 #endif
 
 // move points of synapses in a way unnecessary forces are reduced
-void IVP_Friction_System::ease_friction_forces()
-{
-    IVP_Friction_System *fs=this;
-    for (int i = fr_pairs_of_objs.len()-1; i>=0; i--){
+void IVP_Friction_System::ease_friction_forces() {
+  IVP_Friction_System *fs = this;
+  for (int i = fr_pairs_of_objs.len() - 1; i >= 0; i--) {
     IVP_Friction_Core_Pair *my_pairs = fr_pairs_of_objs.element_at(i);
-	my_pairs->next_ease_nr_psi--;
-	if(my_pairs->next_ease_nr_psi==0) {
-	    //printf("easefr_pair %lx %lx\n",(long)my_pairs->objs[0]&0x0000ffff,(long)my_pairs->objs[1]&0x0000ffff);
-	    IVP_Friction_Solver::ease_friction_pair(my_pairs,fs->l_environment->get_memory_manager());
-	    my_pairs->next_ease_nr_psi=IVP_EASE_EVERY_NTH_PSI; //do only 5 times a second
-	}
+    my_pairs->next_ease_nr_psi--;
+    if (my_pairs->next_ease_nr_psi == 0) {
+      // printf("easefr_pair %lx
+      // %lx\n",(long)my_pairs->objs[0]&0x0000ffff,(long)my_pairs->objs[1]&0x0000ffff);
+      IVP_Friction_Solver::ease_friction_pair(
+          my_pairs, fs->l_environment->get_memory_manager());
+      my_pairs->next_ease_nr_psi =
+          IVP_EASE_EVERY_NTH_PSI; // do only 5 times a second
     }
+  }
 }
 
-IVP_Contact_Point::~IVP_Contact_Point(){
-    IVP_Environment *env = get_synapse(0)->get_object()->get_environment();
+IVP_Contact_Point::~IVP_Contact_Point() {
+  IVP_Environment *env = get_synapse(0)->get_object()->get_environment();
 
-    IVP_Synapse_Friction *syn0 = get_synapse(0);
-    syn0->get_object()->get_surface_manager()->remove_reference_to_ledge(syn0->edge->get_compact_ledge());
-    IVP_Synapse_Friction *syn1 = get_synapse(1);
-    syn1->get_object()->get_surface_manager()->remove_reference_to_ledge(syn1->edge->get_compact_ledge());
-    {
-	IVP_Event_Friction event_friction;
-        event_friction.environment= env;
+  IVP_Synapse_Friction *syn0 = get_synapse(0);
+  syn0->get_object()->get_surface_manager()->remove_reference_to_ledge(
+      syn0->edge->get_compact_ledge());
+  IVP_Synapse_Friction *syn1 = get_synapse(1);
+  syn1->get_object()->get_surface_manager()->remove_reference_to_ledge(
+      syn1->edge->get_compact_ledge());
+  {
+    IVP_Event_Friction event_friction;
+    event_friction.environment = env;
 
-	IVP_Real_Object *obj0 = get_synapse(0)->l_obj;
-	IVP_Real_Object *obj1 = get_synapse(1)->l_obj;
-	IVP_Contact_Situation contact_situation;
-	contact_situation.objects[0] = obj0;
-	contact_situation.objects[1] = obj1;
+    IVP_Real_Object *obj0 = get_synapse(0)->l_obj;
+    IVP_Real_Object *obj1 = get_synapse(1)->l_obj;
+    IVP_Contact_Situation contact_situation;
+    contact_situation.objects[0] = obj0;
+    contact_situation.objects[1] = obj1;
 
-	contact_situation.compact_edges[0] = get_synapse(0)->edge;
-	contact_situation.compact_edges[1] = get_synapse(1)->edge;
+    contact_situation.compact_edges[0] = get_synapse(0)->edge;
+    contact_situation.compact_edges[1] = get_synapse(1)->edge;
 
-	event_friction.contact_situation=&contact_situation;
-	
-	event_friction.friction_handle = this;
-	event_friction.environment->fire_event_friction_deleted(&event_friction);
-	{
-	    if (obj0->flags.collision_listener_exists){
-		IVP_Cluster_Manager *clus_man = env->get_cluster_manager();
-		clus_man->fire_event_friction_deleted(obj0, &event_friction);
-	    }
-	    if (obj1->flags.collision_listener_exists){
-		IVP_Cluster_Manager *clus_man = env->get_cluster_manager();
-		clus_man->fire_event_friction_deleted(obj1, &event_friction);
-	    }
-	}
+    event_friction.contact_situation = &contact_situation;
+
+    event_friction.friction_handle = this;
+    event_friction.environment->fire_event_friction_deleted(&event_friction);
+    {
+      if (obj0->flags.collision_listener_exists) {
+        IVP_Cluster_Manager *clus_man = env->get_cluster_manager();
+        clus_man->fire_event_friction_deleted(obj0, &event_friction);
+      }
+      if (obj1->flags.collision_listener_exists) {
+        IVP_Cluster_Manager *clus_man = env->get_cluster_manager();
+        clus_man->fire_event_friction_deleted(obj1, &event_friction);
+      }
     }
-   {
-     IVP_Core *core0,*core1;
-        IVP_IF( env->get_debug_manager()->check_fs ) {
-	    core0=get_synapse(0)->l_obj->friction_core;
-	    core1=get_synapse(1)->l_obj->friction_core;
-	}
-	
-	get_synapse(0)->remove_friction_synapse_from_object();
-	get_synapse(1)->remove_friction_synapse_from_object();
+  }
+  {
+    IVP_Core *core0, *core1;
+    IVP_IF(env->get_debug_manager()->check_fs) {
+      core0 = get_synapse(0)->l_obj->friction_core;
+      core1 = get_synapse(1)->l_obj->friction_core;
+    }
 
-	IVP_IF( env->get_debug_manager()->check_fs ) {
-	    if(core0->physical_unmoveable) {
-	        core0->unmovable_core_debug_friction_hash();
-	    }
-	    if(core1->physical_unmoveable) {
-	        core1->unmovable_core_debug_friction_hash();
-	    }
-	}
+    get_synapse(0)->remove_friction_synapse_from_object();
+    get_synapse(1)->remove_friction_synapse_from_object();
+
+    IVP_IF(env->get_debug_manager()->check_fs) {
+      if (core0->physical_unmoveable) {
+        core0->unmovable_core_debug_friction_hash();
+      }
+      if (core1->physical_unmoveable) {
+        core1->unmovable_core_debug_friction_hash();
+      }
     }
+  }
 }
 
-
-IVP_FLOAT IVP_Contact_Point_API::get_eliminated_energy(IVP_Contact_Point *friction_handle){
-    return friction_handle->integrated_destroyed_energy;
+IVP_FLOAT IVP_Contact_Point_API::get_eliminated_energy(
+    IVP_Contact_Point *friction_handle) {
+  return friction_handle->integrated_destroyed_energy;
 }
 
-void  IVP_Contact_Point_API::reset_eliminated_energy(IVP_Contact_Point *friction_handle){
-    friction_handle->integrated_destroyed_energy = 0.0f;
+void IVP_Contact_Point_API::reset_eliminated_energy(
+    IVP_Contact_Point *friction_handle) {
+  friction_handle->integrated_destroyed_energy = 0.0f;
 }
 
-
-IVP_FLOAT IVP_Contact_Point_API::get_vert_force(IVP_Contact_Point *friction_handle){
-    return friction_handle->now_friction_pressure;
+IVP_FLOAT
+IVP_Contact_Point_API::get_vert_force(IVP_Contact_Point *friction_handle) {
+  return friction_handle->now_friction_pressure;
 };
 
-
-void IVP_Contact_Point_API::get_surface_normal_ws(IVP_Contact_Point* friction_handle, IVP_U_Float_Point* normal){
-	*normal = friction_handle->tmp_contact_info->surf_normal;
+void IVP_Contact_Point_API::get_surface_normal_ws(
+    IVP_Contact_Point *friction_handle, IVP_U_Float_Point *normal) {
+  *normal = friction_handle->tmp_contact_info->surf_normal;
 }
 
-void IVP_Friction_Info_For_Core::friction_info_insert_friction_dist(IVP_Contact_Point *dist)
-{
-    friction_springs.add(dist);
+void IVP_Friction_Info_For_Core::friction_info_insert_friction_dist(
+    IVP_Contact_Point *dist) {
+  friction_springs.add(dist);
 }
 
-void IVP_Friction_Info_For_Core::friction_info_delete_friction_dist(IVP_Contact_Point *dist)     
-{
-    friction_springs.remove(dist);
+void IVP_Friction_Info_For_Core::friction_info_delete_friction_dist(
+    IVP_Contact_Point *dist) {
+  friction_springs.remove(dist);
 }
 
-int IVP_Friction_Info_For_Core::dist_number()
-{
-    return friction_springs.len();
-}
+int IVP_Friction_Info_For_Core::dist_number() { return friction_springs.len(); }
 
-
-IVP_Friction_Solver::IVP_Friction_Solver(IVP_Friction_System *fri_sys, const IVP_Event_Sim *es_in)
-{
-    l_environment=fri_sys->l_environment;
-    es = es_in;
+IVP_Friction_Solver::IVP_Friction_Solver(IVP_Friction_System *fri_sys,
+                                         const IVP_Event_Sim *es_in) {
+  l_environment = fri_sys->l_environment;
+  es = es_in;
 #ifdef DEBUG
-                gauss_succed=0;
+  gauss_succed = 0;
 #endif
 
-    IVP_U_Memory *my_mem = fri_sys->l_environment->get_memory_manager();
-    dist_change_mat.columns = fri_sys->friction_dist_number - fri_sys->complex_not_necessary_number;    
-    dist_change_mat.calc_aligned_row_len();
+  IVP_U_Memory *my_mem = fri_sys->l_environment->get_memory_manager();
+  dist_change_mat.columns =
+      fri_sys->friction_dist_number - fri_sys->complex_not_necessary_number;
+  dist_change_mat.calc_aligned_row_len();
 
-    dist_change_mat.matrix_values =(IVP_DOUBLE*)my_mem->get_mem((size_t)(dist_change_mat.aligned_row_len*dist_change_mat.columns+IVP_VECFPU_SIZE-1)*sizeof(IVP_DOUBLE));
-    dist_change_mat.desired_vector=(IVP_DOUBLE*)my_mem->get_mem((size_t)dist_change_mat.aligned_row_len*sizeof(IVP_DOUBLE));
-    dist_change_mat.result_vector =(IVP_DOUBLE*)my_mem->get_mem((size_t)dist_change_mat.aligned_row_len*sizeof(IVP_DOUBLE));
-    dist_change_mat.align_matrix_values();
+  dist_change_mat.matrix_values = (IVP_DOUBLE *)my_mem->get_mem(
+      (size_t)(dist_change_mat.aligned_row_len * dist_change_mat.columns +
+               IVP_VECFPU_SIZE - 1) *
+      sizeof(IVP_DOUBLE));
+  dist_change_mat.desired_vector = (IVP_DOUBLE *)my_mem->get_mem(
+      (size_t)dist_change_mat.aligned_row_len * sizeof(IVP_DOUBLE));
+  dist_change_mat.result_vector = (IVP_DOUBLE *)my_mem->get_mem(
+      (size_t)dist_change_mat.aligned_row_len * sizeof(IVP_DOUBLE));
+  dist_change_mat.align_matrix_values();
 }
 
+void IVP_Friction_System::delete_friction_distance(
+    IVP_Contact_Point *old_dist) {
+  // ensure objects have time to move a little bit (e.g. fall down) after
+  // contact lost (do not freeze them)
+  IVP_Core *core0, *core1;
+  core0 = old_dist->synapse[0].l_obj->get_core();
+  core1 = old_dist->synapse[1].l_obj->get_core();
 
+  core0->reset_freeze_check_values();
+  core1->reset_freeze_check_values();
 
-void IVP_Friction_System::delete_friction_distance(IVP_Contact_Point *old_dist) {
-    //ensure objects have time to move a little bit (e.g. fall down) after contact lost (do not freeze them)
-    IVP_Core *core0,*core1;
-    core0=old_dist->synapse[0].l_obj->get_core();
-    core1=old_dist->synapse[1].l_obj->get_core();
-    
-    core0->reset_freeze_check_values();
-    core1->reset_freeze_check_values();
+  this->remove_dist_from_system(old_dist);
+  if (this->dist_removed_update_pair_info(old_dist) == IVP_TRUE) {
+    this->union_find_necessary = IVP_TRUE;
+  }
+  IVP_Friction_Info_For_Core *fr_info0, *fr_info1;
+  fr_info0 = core0->get_friction_info(this);
+  fr_info1 = core1->get_friction_info(this);
 
-    this->remove_dist_from_system(old_dist);
-    if(this->dist_removed_update_pair_info(old_dist)==IVP_TRUE)
-    {
-	this->union_find_necessary=IVP_TRUE;
-    }
-    IVP_Friction_Info_For_Core *fr_info0,*fr_info1;
-    fr_info0=core0->get_friction_info(this);
-    fr_info1=core1->get_friction_info(this);
+  fr_info0->friction_info_delete_friction_dist(old_dist);
+  if (fr_info0->dist_number() == 0) {
+    core0->delete_friction_info(fr_info0);
+    this->remove_core_from_system(core0);
+    core0->sim_unit_of_core->union_find_needed_for_sim_unit = IVP_TRUE;
+  }
+  fr_info1->friction_info_delete_friction_dist(old_dist);
+  if (fr_info1->dist_number() == 0) {
+    core1->delete_friction_info(fr_info1);
+    this->remove_core_from_system(core1);
+    core1->sim_unit_of_core->union_find_needed_for_sim_unit = IVP_TRUE;
+  }
 
-    fr_info0->friction_info_delete_friction_dist(old_dist);
-    if(fr_info0->dist_number()==0)
-    {
-	core0->delete_friction_info(fr_info0);
-	this->remove_core_from_system(core0);
-	core0->sim_unit_of_core->union_find_needed_for_sim_unit=IVP_TRUE;
+  for (int i = 0; i < 0; i++) {
+    IVP_Synapse_Friction *my_syn = old_dist->get_synapse(i);
+    if (my_syn->prev) {
+      my_syn->prev->next = my_syn->next;
+    } else {
+      my_syn->l_obj->friction_synapses = my_syn->get_next();
     }
-    fr_info1->friction_info_delete_friction_dist(old_dist);
-    if(fr_info1->dist_number()==0)
-    {
-	core1->delete_friction_info(fr_info1);
-	this->remove_core_from_system(core1);
-	core1->sim_unit_of_core->union_find_needed_for_sim_unit=IVP_TRUE;
+    if (my_syn->next) {
+      my_syn->next->prev = my_syn->prev;
     }
-    
-    for(int i=0;i<0;i++) {
-	IVP_Synapse_Friction *my_syn=old_dist->get_synapse(i);
-	if(my_syn->prev) {
-	    my_syn->prev->next=my_syn->next;
-	} else {
-	    my_syn->l_obj->friction_synapses = my_syn->get_next();
-	}
-	if(my_syn->next) {
-	    my_syn->next->prev=my_syn->prev;
-	}
-    }
+  }
 
-    //printf("deleting_frdist %lx o %lx c %lx  o %lx c %lx\n",(long)old_dist,(long)old_dist->synapse[0]->l_obj,(long)old_dist->synapse[0]->l_obj->to_real()->physical_core,(long)old_dist->synapse[1]->l_obj,(long)old_dist->synapse[1]->l_obj->to_real()->physical_core);
-    P_DELETE(old_dist);
+  // printf("deleting_frdist %lx o %lx c %lx  o %lx c
+  // %lx\n",(long)old_dist,(long)old_dist->synapse[0]->l_obj,(long)old_dist->synapse[0]->l_obj->to_real()->physical_core,(long)old_dist->synapse[1]->l_obj,(long)old_dist->synapse[1]->l_obj->to_real()->physical_core);
+  P_DELETE(old_dist);
 }
 
+void IVP_Friction_System::apply_real_friction(const IVP_Event_Sim *es) {
+  // fr_solver.mem_friction.init_mem(); // is freed in do_friction_system
+  // printf("whole_mindists %ld\n",this->friction_dist_number);
 
-
-void IVP_Friction_System::apply_real_friction(const IVP_Event_Sim *es)
-{
-    //fr_solver.mem_friction.init_mem(); // is freed in do_friction_system
-    //printf("whole_mindists %ld\n",this->friction_dist_number);
-    
-    this->calc_friction_forces(es);
-    this->ease_friction_forces();
-
+  this->calc_friction_forces(es);
+  this->ease_friction_forces();
 }
 
-
 // throws second sys in first one
-// Optimize: leave pair_info valid, don't process with with dist_added_update_pair_info
-void IVP_Friction_System::fusion_friction_systems(IVP_Friction_System *second_sys)
-{
-    IVP_Friction_System *first_sys=this;
-    
-    IVP_Simulation_Unit *s1,*s2;
-    s1=first_sys->cores_of_friction_system.element_at(0)->sim_unit_of_core;
-    s2=second_sys->cores_of_friction_system.element_at(0)->sim_unit_of_core;
-  
-    IVP_IF(1) {
-        IVP_Environment *env=first_sys->l_environment;
-	IVP_IF(env->get_debug_manager()->check_fs) {
-	    printf("fusion_fs %f %lx %lx  cores ",env->get_current_time().get_time(),(long)first_sys,(long)second_sys);
-	    for (int k = first_sys->cores_of_friction_system.len()-1; k>=0; k--){
-		IVP_Core *my_core = first_sys->cores_of_friction_system.element_at(k);
-	        printf("%lx ",(long)my_core);
-	    }
-	    printf(" ");
-	    for (int l = second_sys->cores_of_friction_system.len()-1; l>=0; l--){
-		IVP_Core *my_core = second_sys->cores_of_friction_system.element_at(l);
-	        printf("%lx ",(long)my_core);
-	    }
-	    printf("\n");	    
-	}
-    }
-  
-    IVP_Contact_Point *my_dist,*next_dist;
-    my_dist=second_sys->get_first_friction_dist();
-    //int counter=0;
+// Optimize: leave pair_info valid, don't process with with
+// dist_added_update_pair_info
+void IVP_Friction_System::fusion_friction_systems(
+    IVP_Friction_System *second_sys) {
+  IVP_Friction_System *first_sys = this;
 
-    IVP_Core *a_core_from_second;
-    
-    while(my_dist)  {
-        next_dist=second_sys->get_next_friction_dist(my_dist);
-	second_sys->remove_dist_from_system(my_dist);
-	second_sys->dist_removed_update_pair_info(my_dist); //is a little bit slow. remove all core pairs directly. But this way it is saver
-        first_sys->add_dist_to_system(my_dist);
-	first_sys->dist_added_update_pair_info(my_dist);
-	//first_sys->fr_solver.calc_calc_solver(first_sys);	
-      	my_dist=next_dist;
-	//counter+=2;
+  IVP_Simulation_Unit *s1, *s2;
+  s1 = first_sys->cores_of_friction_system.element_at(0)->sim_unit_of_core;
+  s2 = second_sys->cores_of_friction_system.element_at(0)->sim_unit_of_core;
+
+  IVP_IF(1) {
+    IVP_Environment *env = first_sys->l_environment;
+    IVP_IF(env->get_debug_manager()->check_fs) {
+      printf("fusion_fs %f %lx %lx  cores ", env->get_current_time().get_time(),
+             (long)first_sys, (long)second_sys);
+      for (int k = first_sys->cores_of_friction_system.len() - 1; k >= 0; k--) {
+        IVP_Core *my_core = first_sys->cores_of_friction_system.element_at(k);
+        printf("%lx ", (long)my_core);
+      }
+      printf(" ");
+      for (int l = second_sys->cores_of_friction_system.len() - 1; l >= 0;
+           l--) {
+        IVP_Core *my_core = second_sys->cores_of_friction_system.element_at(l);
+        printf("%lx ", (long)my_core);
+      }
+      printf("\n");
     }
-    //second_sys->first_friction_dist=NULL; //DIRTY, as this should be done with a loop of deletes, but this way faster
+  }
 
-    // now transfer objects ({unmovable!} if necessary) from one system to another
+  IVP_Contact_Point *my_dist, *next_dist;
+  my_dist = second_sys->get_first_friction_dist();
+  // int counter=0;
 
-    a_core_from_second=second_sys->moveable_cores_of_friction_system.element_at(0);
+  IVP_Core *a_core_from_second;
 
-    for (int n = second_sys->cores_of_friction_system.len()-1; n>=0;n--){
-	IVP_Core *obj1 = second_sys->cores_of_friction_system.element_at(n);
-	IVP_Friction_Info_For_Core *fr_info0,*fr_info1;
-	fr_info1 = obj1->get_friction_info(second_sys); // this info block must exist
-	if( (fr_info0 = obj1->get_friction_info(first_sys)) )	{
-	    // this (unmovable) object is part of both systems; transferr mindists and delete second Info-Blocks
-	    fr_info1 = obj1->get_friction_info(second_sys);
-	    for (int m = fr_info1->friction_springs.len()-1; m>=0; m--){
-		my_dist = fr_info1->friction_springs.element_at(m);
-		fr_info0->friction_info_insert_friction_dist(my_dist);
-		fr_info1->friction_info_delete_friction_dist(my_dist);
-	    }
-	    obj1->delete_friction_info(fr_info1);
-	} else {
-	    //this object is not member of first sys, leave info block but change link to system
-	    obj1->unlink_friction_info(fr_info1);  // l_friction_system is used as key in hash
-	    fr_info1->l_friction_system=first_sys; // now it is save to change l_friction_system
-	    obj1->add_friction_info(fr_info1);     // re-add
-	    second_sys->remove_core_from_system(obj1);
-	    first_sys->add_core_to_system(obj1);
-	}
-    }
+  while (my_dist) {
+    next_dist = second_sys->get_next_friction_dist(my_dist);
+    second_sys->remove_dist_from_system(my_dist);
+    second_sys->dist_removed_update_pair_info(
+        my_dist); // is a little bit slow. remove all core pairs directly. But
+                  // this way it is saver
+    first_sys->add_dist_to_system(my_dist);
+    first_sys->dist_added_update_pair_info(my_dist);
+    // first_sys->fr_solver.calc_calc_solver(first_sys);
+    my_dist = next_dist;
+    // counter+=2;
+  }
+  // second_sys->first_friction_dist=NULL; //DIRTY, as this should be done with
+  // a loop of deletes, but this way faster
 
-    //remove_friction_system(second_sys);
-    IVP_USE(a_core_from_second);
+  // now transfer objects ({unmovable!} if necessary) from one system to another
 
-    P_DELETE(second_sys);
-    //first_sys->fr_solver.calc_calc_solver(first_sys);
-    IVP_IF(1) {
-        first_sys->test_hole_fr_system_data();
+  a_core_from_second =
+      second_sys->moveable_cores_of_friction_system.element_at(0);
+
+  for (int n = second_sys->cores_of_friction_system.len() - 1; n >= 0; n--) {
+    IVP_Core *obj1 = second_sys->cores_of_friction_system.element_at(n);
+    IVP_Friction_Info_For_Core *fr_info0, *fr_info1;
+    fr_info1 =
+        obj1->get_friction_info(second_sys); // this info block must exist
+    if ((fr_info0 = obj1->get_friction_info(first_sys))) {
+      // this (unmovable) object is part of both systems; transferr mindists and
+      // delete second Info-Blocks
+      fr_info1 = obj1->get_friction_info(second_sys);
+      for (int m = fr_info1->friction_springs.len() - 1; m >= 0; m--) {
+        my_dist = fr_info1->friction_springs.element_at(m);
+        fr_info0->friction_info_insert_friction_dist(my_dist);
+        fr_info1->friction_info_delete_friction_dist(my_dist);
+      }
+      obj1->delete_friction_info(fr_info1);
+    } else {
+      // this object is not member of first sys, leave info block but change
+      // link to system
+      obj1->unlink_friction_info(
+          fr_info1); // l_friction_system is used as key in hash
+      fr_info1->l_friction_system =
+          first_sys; // now it is save to change l_friction_system
+      obj1->add_friction_info(fr_info1); // re-add
+      second_sys->remove_core_from_system(obj1);
+      first_sys->add_core_to_system(obj1);
     }
-    //printf("did_fusion\n");
-}
+  }
 
+  // remove_friction_system(second_sys);
+  IVP_USE(a_core_from_second);
 
-int IVP_Friction_Core_Pair::number_of_pair_dists()
-{
-    return fr_dists.len();
+  P_DELETE(second_sys);
+  // first_sys->fr_solver.calc_calc_solver(first_sys);
+  IVP_IF(1) { first_sys->test_hole_fr_system_data(); }
+  // printf("did_fusion\n");
 }
 
+int IVP_Friction_Core_Pair::number_of_pair_dists() { return fr_dists.len(); }
 
-void IVP_Friction_Core_Pair::add_fr_dist_obj_pairs(IVP_Contact_Point *dist)
-{
-#if 0 /* TL: this code is for initializing span_friction_s, but why at this point :( */   
+void IVP_Friction_Core_Pair::add_fr_dist_obj_pairs(IVP_Contact_Point *dist) {
+#if 0 /* TL: this code is for initializing span_friction_s, but why at this    \
+         point :( */   
     int numbers = fr_dists.len();
     if( numbers > 0 ) {
 	IVP_U_Float_Point friction_vec;
@@ -1271,593 +1338,638 @@
 	dist->span_friction_s[0]=friction_vec.dot_product(&info->span_friction_v[0]);
 	dist->span_friction_s[1]=friction_vec.dot_product(&info->span_friction_v[1]);
     }
-#endif    
-    fr_dists.add(dist);
+#endif
+  fr_dists.add(dist);
 }
 
-void IVP_Friction_Core_Pair::del_fr_dist_obj_pairs(IVP_Contact_Point *dist)
-{
-    fr_dists.remove(dist);
+void IVP_Friction_Core_Pair::del_fr_dist_obj_pairs(IVP_Contact_Point *dist) {
+  fr_dists.remove(dist);
 }
 
-
-void IVP_Friction_System::add_fr_pair(IVP_Friction_Core_Pair *pair)
-{
-    fr_pairs_of_objs.add(pair);
-	pair->objs[0]->get_environment()->fire_event_friction_pair_created( pair );
+void IVP_Friction_System::add_fr_pair(IVP_Friction_Core_Pair *pair) {
+  fr_pairs_of_objs.add(pair);
+  pair->objs[0]->get_environment()->fire_event_friction_pair_created(pair);
 }
 
-void IVP_Friction_System::del_fr_pair(IVP_Friction_Core_Pair *pair)
-{
-	pair->objs[0]->get_environment()->fire_event_friction_pair_deleted( pair );
-    fr_pairs_of_objs.remove(pair);
+void IVP_Friction_System::del_fr_pair(IVP_Friction_Core_Pair *pair) {
+  pair->objs[0]->get_environment()->fire_event_friction_pair_deleted(pair);
+  fr_pairs_of_objs.remove(pair);
 }
 
-IVP_Friction_Core_Pair *IVP_Friction_System::get_pair_info_for_objs(IVP_Core *core0,IVP_Core *core1){
-    for (int i = fr_pairs_of_objs.len()-1; i>=0; i--){
-	IVP_Friction_Core_Pair *my_pair= fr_pairs_of_objs.element_at(i);
-	if( (my_pair->objs[0]==core0) || (my_pair->objs[1]==core0) )	{
-	    if( (my_pair->objs[0]==core1) || (my_pair->objs[1]==core1) )
-	    return my_pair;
-	}
+IVP_Friction_Core_Pair *
+IVP_Friction_System::get_pair_info_for_objs(IVP_Core *core0, IVP_Core *core1) {
+  for (int i = fr_pairs_of_objs.len() - 1; i >= 0; i--) {
+    IVP_Friction_Core_Pair *my_pair = fr_pairs_of_objs.element_at(i);
+    if ((my_pair->objs[0] == core0) || (my_pair->objs[1] == core0)) {
+      if ((my_pair->objs[0] == core1) || (my_pair->objs[1] == core1))
+        return my_pair;
     }
-    return NULL;
+  }
+  return NULL;
 }
 
-
 // all cores of a simulated friction system have to be simulated
 void IVP_Friction_System::debug_check_system_consistency() {
-    for (int i = cores_of_friction_system.len()-1; i>=0; i--){
-	IVP_Core *core = cores_of_friction_system.element_at(i);
-	if(!core->physical_unmoveable)	{
-	    IVP_ASSERT(IVP_MTIS_SIMULATED (core->movement_state) );
-	}
-    }    
+  for (int i = cores_of_friction_system.len() - 1; i >= 0; i--) {
+    IVP_Core *core = cores_of_friction_system.element_at(i);
+    if (!core->physical_unmoveable) {
+      IVP_ASSERT(IVP_MTIS_SIMULATED(core->movement_state));
+    }
+  }
 }
 
-
 // make inline
-IVP_Core *IVP_Core::union_find_get_father()
-{
-    IVP_Core *obj=this;
-    IVP_Core *on_top=obj;
-    while(obj)
-    {
-	on_top=obj;
-	obj=obj->tmp.union_find_father;
-    }
-    return on_top;
+IVP_Core *IVP_Core::union_find_get_father() {
+  IVP_Core *obj = this;
+  IVP_Core *on_top = obj;
+  while (obj) {
+    on_top = obj;
+    obj = obj->tmp.union_find_father;
+  }
+  return on_top;
 }
 
-// a connection between two objects in fr sys no longer exists, test if fr sys can be splitted in two parts
-// fixed objs dont block the splitting
-IVP_Core *IVP_Friction_System::union_find_fr_sys()
-{
-    IVP_Friction_System *fr_sys=this;
+// a connection between two objects in fr sys no longer exists, test if fr sys
+// can be splitted in two parts fixed objs dont block the splitting
+IVP_Core *IVP_Friction_System::union_find_fr_sys() {
+  IVP_Friction_System *fr_sys = this;
 
-    for (int k = fr_sys->cores_of_friction_system.len()-1; k>=0; k--){
-	IVP_Core *obje = fr_sys->cores_of_friction_system.element_at(k);
-	obje->tmp.union_find_father=NULL;
-    }
+  for (int k = fr_sys->cores_of_friction_system.len() - 1; k >= 0; k--) {
+    IVP_Core *obje = fr_sys->cores_of_friction_system.element_at(k);
+    obje->tmp.union_find_father = NULL;
+  }
 
-    for (int l = fr_sys->fr_pairs_of_objs.len()-1; l>=0; l--){
-	IVP_Friction_Core_Pair *fr_pair = fr_sys->fr_pairs_of_objs.element_at(l);
-	IVP_Core *obj0,*obj1;
-	obj0=fr_pair->objs[0];
-	obj1=fr_pair->objs[1];
-	if(obj0->physical_unmoveable || obj1->physical_unmoveable) {
-	    continue; //ignore fixed objs. they cannot connect objects (fixed objs can have more than one friction system)
-	}
-	//printf("doinguf %lx %lx   ",(long)obj0&0x0000ffff,(long)obj1&0x0000ffff); UFTEST
-	obj0=obj0->union_find_get_father();
-	obj1=obj1->union_find_get_father();
-	//printf("fathers are %lx %lx   ",(long)obj0&0x0000ffff,(long)obj1&0x0000ffff); UFTEST
-	if(obj0!=obj1) {
-	    obj1->tmp.union_find_father=obj0;
-	    //printf("newfather %lx : %lx\n",(long)obj1&0x0000ffff,(long)obj0&0x0000ffff); UFTEST
-	}
+  for (int l = fr_sys->fr_pairs_of_objs.len() - 1; l >= 0; l--) {
+    IVP_Friction_Core_Pair *fr_pair = fr_sys->fr_pairs_of_objs.element_at(l);
+    IVP_Core *obj0, *obj1;
+    obj0 = fr_pair->objs[0];
+    obj1 = fr_pair->objs[1];
+    if (obj0->physical_unmoveable || obj1->physical_unmoveable) {
+      continue; // ignore fixed objs. they cannot connect objects (fixed objs
+                // can have more than one friction system)
     }
+    // printf("doinguf %lx %lx   ",(long)obj0&0x0000ffff,(long)obj1&0x0000ffff);
+    // UFTEST
+    obj0 = obj0->union_find_get_father();
+    obj1 = obj1->union_find_get_father();
+    // printf("fathers are %lx %lx
+    // ",(long)obj0&0x0000ffff,(long)obj1&0x0000ffff); UFTEST
+    if (obj0 != obj1) {
+      obj1->tmp.union_find_father = obj0;
+      // printf("newfather %lx :
+      // %lx\n",(long)obj1&0x0000ffff,(long)obj0&0x0000ffff); UFTEST
+    }
+  }
 
-    IVP_IF(0)	{
-	for (int k = fr_sys->cores_of_friction_system.len()-1; k>=0; k--){
-	    IVP_Core *objj = fr_sys->cores_of_friction_system.element_at(k);
-	    IVP_Core *of=objj->union_find_get_father();
-	    printf("uff of %lx : %lx\n",(long)objj&0x0000ffff,(long)of&0x0000ffff);
-	}
+  IVP_IF(0) {
+    for (int k = fr_sys->cores_of_friction_system.len() - 1; k >= 0; k--) {
+      IVP_Core *objj = fr_sys->cores_of_friction_system.element_at(k);
+      IVP_Core *of = objj->union_find_get_father();
+      printf("uff of %lx : %lx\n", (long)objj & 0x0000ffff,
+             (long)of & 0x0000ffff);
     }
+  }
 
-    
-    IVP_Core *first_father=NULL,*second_father=NULL;
+  IVP_Core *first_father = NULL, *second_father = NULL;
 
-    // find representative obj for second system (must not be a fixed obj)
-    for (int i1 = fr_sys->cores_of_friction_system.len()-1; i1>=0; i1--){
-	IVP_Core *obj = fr_sys->cores_of_friction_system.element_at(i1);
-	if(!obj->physical_unmoveable)	{
-	    first_father=obj->union_find_get_father();
-	}
+  // find representative obj for second system (must not be a fixed obj)
+  for (int i1 = fr_sys->cores_of_friction_system.len() - 1; i1 >= 0; i1--) {
+    IVP_Core *obj = fr_sys->cores_of_friction_system.element_at(i1);
+    if (!obj->physical_unmoveable) {
+      first_father = obj->union_find_get_father();
     }
-    IVP_ASSERT(first_father);
-    
-    for (int i2 = fr_sys->cores_of_friction_system.len()-1; i2>=0; i2--){
-	IVP_Core *obj = fr_sys->cores_of_friction_system.element_at(i2);
-	if(obj->physical_unmoveable) {
-	    continue; //ignore fixed objs
-	}
-	IVP_Core *test_father=obj->union_find_get_father();
-	if(test_father!=first_father)	{
-	    second_father=test_father;
-	}
+  }
+  IVP_ASSERT(first_father);
+
+  for (int i2 = fr_sys->cores_of_friction_system.len() - 1; i2 >= 0; i2--) {
+    IVP_Core *obj = fr_sys->cores_of_friction_system.element_at(i2);
+    if (obj->physical_unmoveable) {
+      continue; // ignore fixed objs
     }
-    
-    return second_father;
+    IVP_Core *test_father = obj->union_find_get_father();
+    if (test_father != first_father) {
+      second_father = test_father;
+    }
+  }
+
+  return second_father;
 }
 
-// split in two parts; every object, that has 'split_father' as union-find father is put into a new system 
-void IVP_Friction_System::split_friction_system(IVP_Core *split_father)
-{
-    IVP_Friction_System *fr_sys=this;
-    
-    IVP_Friction_System *new_fr_sys=new IVP_Friction_System(l_environment);
+// split in two parts; every object, that has 'split_father' as union-find
+// father is put into a new system
+void IVP_Friction_System::split_friction_system(IVP_Core *split_father) {
+  IVP_Friction_System *fr_sys = this;
 
-     IVP_IF( fr_sys->l_environment->get_debug_manager()->check_fs ) {
-        printf("split_fs %f %lx %lx  cores ",fr_sys->l_environment->get_current_time().get_time(),(long)fr_sys,(long)new_fr_sys);
-	for (int i = fr_sys->cores_of_friction_system.len()-1; i>=0;i--){
-	    IVP_Core *my_core = fr_sys->cores_of_friction_system.element_at(i);
-	    printf("%lx ",(long)my_core);
-	}
-	printf("\n");
-     }
+  IVP_Friction_System *new_fr_sys = new IVP_Friction_System(l_environment);
 
-    //printf("splitting_now father %lx\n",(long)split_father&0x0000ffff);
-    //fr_sys->debug_fs_out_ascii();
-    {
-	//first transfer objs
-	for (int j = fr_sys->cores_of_friction_system.len()-1; j>=0; j--){
-	    IVP_Core *obj=fr_sys->cores_of_friction_system.element_at(j);
-	  //printf("   %lx hasfather %lx ",(long)obj&0x0000ffff,(long)union_find_get_father(obj)&0x0000ffff);  
-	    if(obj->physical_unmoveable)    {
-	        //printf("isumv");
-		// fixed objs first belong to both systems and get two IVP_Friction_Info_For_Core, later deleted if necessary
-		IVP_Friction_Info_For_Core *fr_i=new IVP_Friction_Info_For_Core();
-		fr_i->l_friction_system=new_fr_sys;
-		new_fr_sys->add_core_to_system(obj);
-		obj->add_friction_info(fr_i);
-	    } else {
-		if(obj->union_find_get_father()==split_father)
-		{
-		    fr_sys->remove_core_from_system(obj);
-		    new_fr_sys->add_core_to_system(obj);
-		    IVP_Friction_Info_For_Core *fr_i=obj->get_friction_info(fr_sys);
-		    fr_i->l_friction_system=new_fr_sys;
-		}
-	    }
-	}
-	//printf("\n");
+  IVP_IF(fr_sys->l_environment->get_debug_manager()->check_fs) {
+    printf("split_fs %f %lx %lx  cores ",
+           fr_sys->l_environment->get_current_time().get_time(), (long)fr_sys,
+           (long)new_fr_sys);
+    for (int i = fr_sys->cores_of_friction_system.len() - 1; i >= 0; i--) {
+      IVP_Core *my_core = fr_sys->cores_of_friction_system.element_at(i);
+      printf("%lx ", (long)my_core);
     }
+    printf("\n");
+  }
 
-    {
-	// transfer mindists (take pairs as orientation)
-	for (int n = fr_sys->fr_pairs_of_objs.len()-1; n>=0; n--){
-	IVP_Friction_Core_Pair *fr_pair = fr_sys->fr_pairs_of_objs.element_at(n);
-	    IVP_Core *robj=fr_pair->objs[0]; //is used to identify fr sys my pair should belong to
-	    IVP_Core *robj2=fr_pair->objs[1]; // used when fixed obj is involved 
-	    IVP_Friction_Info_For_Core *fr_i_old = NULL,*fr_i_new = NULL; // when fixed obj exists, dists have to be transfered from fr_i_old to fr_i_new
-	    if(robj->physical_unmoveable)   {
-	        IVP_Core *ct;
-		ct=robj2;
-		robj2=robj;
-		robj=ct;
-		goto found_fixed;
-	    } else {
-		if(robj2->physical_unmoveable){
-		found_fixed:    
-		    fr_i_old=robj2->get_friction_info(fr_sys);
-		    fr_i_new=robj2->get_friction_info(new_fr_sys);
-		}
-	    }
-
-      	    //printf("reassignpair %lx infoc %lx",(long)fr_pair&0x0000ffff,(long)robj&0x0000ffff);
-	    if(robj->union_find_get_father()==split_father)	    {
-	      //printf(" to_new");
-		fr_sys->del_fr_pair(fr_pair);
-		new_fr_sys->add_fr_pair(fr_pair);
-		for (int k = fr_pair->fr_dists.len()-1; k>=0; k--){
-		    IVP_Contact_Point *fr_dist=fr_pair->fr_dists.element_at(k);
-		    int found_mine=0;
-		    IVP_Contact_Point *mindist;
-		    for(mindist=fr_sys->get_first_friction_dist();mindist;mindist=fr_sys->get_next_friction_dist(mindist))   {
-			if(mindist==fr_dist) {
-			    found_mine=1;
-			}
-		    }
-		    if(!found_mine)
-		    {
-			IVP_IF(1) { printf("removing_dist that doesnt belong to sys\n"); }
-			CORE;
-		    }
-		    fr_sys->remove_dist_from_system(fr_dist);
-		    new_fr_sys->add_dist_to_system(fr_dist);
-		    //printf("add_to_new %lx fs_num_now %ld\n",(long)fr_dist,new_fr_sys->friction_dist_number); UFTEST
-		    if(fr_i_old)
-		    {
-			// a fixed obj is involved. fixed objs have friction_info in BOTH systems
-			fr_i_old->friction_info_delete_friction_dist(fr_dist);
-			fr_i_new->friction_info_insert_friction_dist(fr_dist);
-		    }
-		}
-	    }
-	    //printf("jjj\n");
-	}
+  // printf("splitting_now father %lx\n",(long)split_father&0x0000ffff);
+  // fr_sys->debug_fs_out_ascii();
+  {
+    // first transfer objs
+    for (int j = fr_sys->cores_of_friction_system.len() - 1; j >= 0; j--) {
+      IVP_Core *obj = fr_sys->cores_of_friction_system.element_at(j);
+      // printf("   %lx hasfather %lx
+      // ",(long)obj&0x0000ffff,(long)union_find_get_father(obj)&0x0000ffff);
+      if (obj->physical_unmoveable) {
+        // printf("isumv");
+        //  fixed objs first belong to both systems and get two
+        //  IVP_Friction_Info_For_Core, later deleted if necessary
+        IVP_Friction_Info_For_Core *fr_i = new IVP_Friction_Info_For_Core();
+        fr_i->l_friction_system = new_fr_sys;
+        new_fr_sys->add_core_to_system(obj);
+        obj->add_friction_info(fr_i);
+      } else {
+        if (obj->union_find_get_father() == split_father) {
+          fr_sys->remove_core_from_system(obj);
+          new_fr_sys->add_core_to_system(obj);
+          IVP_Friction_Info_For_Core *fr_i = obj->get_friction_info(fr_sys);
+          fr_i->l_friction_system = new_fr_sys;
+        }
+      }
     }
+    // printf("\n");
+  }
 
-    //printf("\nbefore_removal\n");
-    //fr_sys->debug_fs_out_ascii();
-    //new_fr_sys->debug_fs_out_ascii();
-    {
-	// test if fixed objs can be removed from old system
-	for (int l = fr_sys->cores_of_friction_system.len()-1; l>=0; l--){
-	    IVP_Core *obj=fr_sys->cores_of_friction_system.element_at(l);
-	    if(obj->physical_unmoveable)    {
-		// fixed objs belong to both systems and have two IVP_Friction_Info_For_Obj
-		IVP_Friction_Info_For_Core *fr_i_new=obj->get_friction_info(new_fr_sys);
-		IVP_Friction_Info_For_Core *fr_i_old=obj->get_friction_info(fr_sys);
-		if(fr_i_new->dist_number()==0) {
-		  //printf("uf_rem %lx from new %lx\n",(long)obj&0x0000ffff,(long)new_fr_sys&0x0000ffff);
-		    obj->delete_friction_info(fr_i_new);
-		    new_fr_sys->remove_core_from_system(obj);
-		}
-		if(fr_i_old->dist_number()==0) {
-		  //printf("uf_rem %lx from old %lx\n",(long)obj&0x0000ffff,(long)fr_sys&0x0000ffff);
-		    obj->delete_friction_info(fr_i_old);
-		    fr_sys->remove_core_from_system(obj);
-		}
-	    } 
-	}
-    } 
-    
-    if(new_fr_sys->friction_obj_number<2) {
-      //printf("split_only_one_new\n"); //UFTEST
-	IVP_Core *obj=new_fr_sys->cores_of_friction_system.element_at(0);
-	IVP_Friction_Info_For_Core *fr_i = obj->get_friction_info(new_fr_sys);
-	obj->delete_friction_info(fr_i);
-	P_DELETE(fr_i);
-	P_DELETE(new_fr_sys);
-	return ;
-    }
-    if(fr_sys->friction_obj_number<2) {
-      //printf("split_only_one_old\n"); //UFTEST
-	IVP_Core *obj=fr_sys->cores_of_friction_system.element_at(0);
-	IVP_Friction_Info_For_Core *fr_i=obj->get_friction_info(fr_sys);
-	obj->delete_friction_info(fr_i);
-	P_DELETE(fr_i);
-	P_DELETE(fr_sys);
-	return ;
-    }
-    //printf("splitted_frs %lx\n",(long)fr_sys); //UFTEST
-    //new_fr_sys->fr_solver.calc_calc_solver(new_fr_sys);
-    //fr_sys->fr_solver.calc_calc_solver(fr_sys);
-    //this->add_friction_system(new_fr_sys);
-    IVP_IF(1==1) //expensive but important
-    {
-      //printf("split_first_result\n");
-      //new_fr_sys->debug_fs_out_ascii();
-      //printf("split_second_result\n");
-      //fr_sys->debug_fs_out_ascii();
-      new_fr_sys->test_hole_fr_system_data();
-      fr_sys->test_hole_fr_system_data();
-    }
-    {
-	// it may happen, that a system can be split in more than two parts (very seldom)
-	IVP_Core *obj=fr_sys->union_find_fr_sys();
-	if(obj) {
-	    fr_sys->split_friction_system(obj); //split recorsively if necessary
-	}
+  {
+    // transfer mindists (take pairs as orientation)
+    for (int n = fr_sys->fr_pairs_of_objs.len() - 1; n >= 0; n--) {
+      IVP_Friction_Core_Pair *fr_pair = fr_sys->fr_pairs_of_objs.element_at(n);
+      IVP_Core *robj =
+          fr_pair
+              ->objs[0]; // is used to identify fr sys my pair should belong to
+      IVP_Core *robj2 = fr_pair->objs[1]; // used when fixed obj is involved
+      IVP_Friction_Info_For_Core
+          *fr_i_old = NULL,
+          *fr_i_new = NULL; // when fixed obj exists, dists have to be
+                            // transfered from fr_i_old to fr_i_new
+      if (robj->physical_unmoveable) {
+        IVP_Core *ct;
+        ct = robj2;
+        robj2 = robj;
+        robj = ct;
+        goto found_fixed;
+      } else {
+        if (robj2->physical_unmoveable) {
+        found_fixed:
+          fr_i_old = robj2->get_friction_info(fr_sys);
+          fr_i_new = robj2->get_friction_info(new_fr_sys);
+        }
+      }
+
+      // printf("reassignpair %lx infoc
+      // %lx",(long)fr_pair&0x0000ffff,(long)robj&0x0000ffff);
+      if (robj->union_find_get_father() == split_father) {
+        // printf(" to_new");
+        fr_sys->del_fr_pair(fr_pair);
+        new_fr_sys->add_fr_pair(fr_pair);
+        for (int k = fr_pair->fr_dists.len() - 1; k >= 0; k--) {
+          IVP_Contact_Point *fr_dist = fr_pair->fr_dists.element_at(k);
+          int found_mine = 0;
+          IVP_Contact_Point *mindist;
+          for (mindist = fr_sys->get_first_friction_dist(); mindist;
+               mindist = fr_sys->get_next_friction_dist(mindist)) {
+            if (mindist == fr_dist) {
+              found_mine = 1;
+            }
+          }
+          if (!found_mine) {
+            IVP_IF(1) { printf("removing_dist that doesnt belong to sys\n"); }
+            CORE;
+          }
+          fr_sys->remove_dist_from_system(fr_dist);
+          new_fr_sys->add_dist_to_system(fr_dist);
+          // printf("add_to_new %lx fs_num_now
+          // %ld\n",(long)fr_dist,new_fr_sys->friction_dist_number); UFTEST
+          if (fr_i_old) {
+            // a fixed obj is involved. fixed objs have friction_info in BOTH
+            // systems
+            fr_i_old->friction_info_delete_friction_dist(fr_dist);
+            fr_i_new->friction_info_insert_friction_dist(fr_dist);
+          }
+        }
+      }
+      // printf("jjj\n");
     }
+  }
+
+  // printf("\nbefore_removal\n");
+  // fr_sys->debug_fs_out_ascii();
+  // new_fr_sys->debug_fs_out_ascii();
+  {
+    // test if fixed objs can be removed from old system
+    for (int l = fr_sys->cores_of_friction_system.len() - 1; l >= 0; l--) {
+      IVP_Core *obj = fr_sys->cores_of_friction_system.element_at(l);
+      if (obj->physical_unmoveable) {
+        // fixed objs belong to both systems and have two
+        // IVP_Friction_Info_For_Obj
+        IVP_Friction_Info_For_Core *fr_i_new =
+            obj->get_friction_info(new_fr_sys);
+        IVP_Friction_Info_For_Core *fr_i_old = obj->get_friction_info(fr_sys);
+        if (fr_i_new->dist_number() == 0) {
+          // printf("uf_rem %lx from new
+          // %lx\n",(long)obj&0x0000ffff,(long)new_fr_sys&0x0000ffff);
+          obj->delete_friction_info(fr_i_new);
+          new_fr_sys->remove_core_from_system(obj);
+        }
+        if (fr_i_old->dist_number() == 0) {
+          // printf("uf_rem %lx from old
+          // %lx\n",(long)obj&0x0000ffff,(long)fr_sys&0x0000ffff);
+          obj->delete_friction_info(fr_i_old);
+          fr_sys->remove_core_from_system(obj);
+        }
+      }
+    }
+  }
+
+  if (new_fr_sys->friction_obj_number < 2) {
+    // printf("split_only_one_new\n"); //UFTEST
+    IVP_Core *obj = new_fr_sys->cores_of_friction_system.element_at(0);
+    IVP_Friction_Info_For_Core *fr_i = obj->get_friction_info(new_fr_sys);
+    obj->delete_friction_info(fr_i);
+    P_DELETE(fr_i);
+    P_DELETE(new_fr_sys);
+    return;
+  }
+  if (fr_sys->friction_obj_number < 2) {
+    // printf("split_only_one_old\n"); //UFTEST
+    IVP_Core *obj = fr_sys->cores_of_friction_system.element_at(0);
+    IVP_Friction_Info_For_Core *fr_i = obj->get_friction_info(fr_sys);
+    obj->delete_friction_info(fr_i);
+    P_DELETE(fr_i);
+    P_DELETE(fr_sys);
+    return;
+  }
+  // printf("splitted_frs %lx\n",(long)fr_sys); //UFTEST
+  // new_fr_sys->fr_solver.calc_calc_solver(new_fr_sys);
+  // fr_sys->fr_solver.calc_calc_solver(fr_sys);
+  // this->add_friction_system(new_fr_sys);
+  IVP_IF(1 == 1) // expensive but important
+  {
+    // printf("split_first_result\n");
+    // new_fr_sys->debug_fs_out_ascii();
+    // printf("split_second_result\n");
+    // fr_sys->debug_fs_out_ascii();
+    new_fr_sys->test_hole_fr_system_data();
+    fr_sys->test_hole_fr_system_data();
+  }
+  {
+    // it may happen, that a system can be split in more than two parts (very
+    // seldom)
+    IVP_Core *obj = fr_sys->union_find_fr_sys();
+    if (obj) {
+      fr_sys->split_friction_system(obj); // split recorsively if necessary
+    }
+  }
 }
 
-void IVP_Friction_System::print_all_dists()
-{
-    IVP_IF(1) {
-    printf("fs %lx  ",(long)this&0x0000ffff);
-		for(IVP_Contact_Point *mindist=this->get_first_friction_dist();mindist;mindist=this->get_next_friction_dist(mindist))
-		{
-		    printf("%lx ",(long)mindist&0x0000ffff);
-		}    
+void IVP_Friction_System::print_all_dists() {
+  IVP_IF(1) {
+    printf("fs %lx  ", (long)this & 0x0000ffff);
+    for (IVP_Contact_Point *mindist = this->get_first_friction_dist(); mindist;
+         mindist = this->get_next_friction_dist(mindist)) {
+      printf("%lx ", (long)mindist & 0x0000ffff);
+    }
     printf("\n");
     printf("      ");
-    for (int i = fr_pairs_of_objs.len()-1; i>=0; i--){
-	IVP_Friction_Core_Pair *fr_pair = fr_pairs_of_objs.element_at(i);
-	printf("p %lx %lx  ",(long)fr_pair->objs[0]&0x0000ffff,(long)fr_pair->objs[1]&0x0000ffff);
-	for (int c = fr_pair->fr_dists.len()-1;c>=0; c--){
-	    IVP_Contact_Point *fr_dist=fr_pair->fr_dists.element_at(c);
-	    printf("%lx ",(long)fr_dist&0x0000ffff);
-	}
+    for (int i = fr_pairs_of_objs.len() - 1; i >= 0; i--) {
+      IVP_Friction_Core_Pair *fr_pair = fr_pairs_of_objs.element_at(i);
+      printf("p %lx %lx  ", (long)fr_pair->objs[0] & 0x0000ffff,
+             (long)fr_pair->objs[1] & 0x0000ffff);
+      for (int c = fr_pair->fr_dists.len() - 1; c >= 0; c--) {
+        IVP_Contact_Point *fr_dist = fr_pair->fr_dists.element_at(c);
+        printf("%lx ", (long)fr_dist & 0x0000ffff);
+      }
     }
     printf("\n");
-    }
+  }
 }
 
-void IVP_Friction_System::reset_time(IVP_Time offset){
-    for (int i = fr_pairs_of_objs.len()-1; i>=0; i--){
-	IVP_Friction_Core_Pair *fr_pair = fr_pairs_of_objs.element_at(i);
-	for (int c = fr_pair->fr_dists.len()-1;c>=0; c--){
-	    IVP_Contact_Point *my_dist = fr_pair->fr_dists.element_at(c);
-	    my_dist->reset_time(offset);
-	}
+void IVP_Friction_System::reset_time(IVP_Time offset) {
+  for (int i = fr_pairs_of_objs.len() - 1; i >= 0; i--) {
+    IVP_Friction_Core_Pair *fr_pair = fr_pairs_of_objs.element_at(i);
+    for (int c = fr_pair->fr_dists.len() - 1; c >= 0; c--) {
+      IVP_Contact_Point *my_dist = fr_pair->fr_dists.element_at(c);
+      my_dist->reset_time(offset);
     }
+  }
 }
 
 // return zero when pair no longer exists
-int IVP_Friction_Core_Pair::check_all_fr_mindists_to_be_valid(IVP_Friction_System *my_fs) {
-    int total_number_remaining = this->fr_dists.len();
-    for (int k = fr_dists.len()-1; k>=0; k--){
-	IVP_Contact_Point *my_dist=this->fr_dists.element_at(k);
-	my_dist->recalc_friction_s_vals();
-	IVP_Impact_Solver_Long_Term *info=my_dist->tmp_contact_info;
-	my_dist->read_materials_for_contact_situation(info);
-	
-	//printf("impact_sys_update_contact_vals %lx\n",(long)my_dist);
-	if( info->friction_is_broken == IVP_TRUE) {
-	    total_number_remaining--;
-	    my_fs->delete_friction_distance(my_dist);
-	}
+int IVP_Friction_Core_Pair::check_all_fr_mindists_to_be_valid(
+    IVP_Friction_System *my_fs) {
+  int total_number_remaining = this->fr_dists.len();
+  for (int k = fr_dists.len() - 1; k >= 0; k--) {
+    IVP_Contact_Point *my_dist = this->fr_dists.element_at(k);
+    my_dist->recalc_friction_s_vals();
+    IVP_Impact_Solver_Long_Term *info = my_dist->tmp_contact_info;
+    my_dist->read_materials_for_contact_situation(info);
+
+    // printf("impact_sys_update_contact_vals %lx\n",(long)my_dist);
+    if (info->friction_is_broken == IVP_TRUE) {
+      total_number_remaining--;
+      my_fs->delete_friction_distance(my_dist);
     }
-    //warning: at this point 'this' might have been deleted
+  }
+  // warning: at this point 'this' might have been deleted
 
-    return total_number_remaining;
+  return total_number_remaining;
 }
 
-
-void IVP_Friction_System::remove_energy_gained_by_real_friction()
-{
-    for (int i = fr_pairs_of_objs.len()-1; i>=0; i--){
-	IVP_Friction_Core_Pair *my_pair = fr_pairs_of_objs.element_at(i);
-	my_pair->remove_energy_gained_by_real_friction();
-    }
+void IVP_Friction_System::remove_energy_gained_by_real_friction() {
+  for (int i = fr_pairs_of_objs.len() - 1; i >= 0; i--) {
+    IVP_Friction_Core_Pair *my_pair = fr_pairs_of_objs.element_at(i);
+    my_pair->remove_energy_gained_by_real_friction();
+  }
 }
 
-void IVP_Friction_System::clear_integrated_anti_energy()
-{
-    for (int k = fr_pairs_of_objs.len()-1; k>=0; k--){
-	IVP_Friction_Core_Pair *my_pair = fr_pairs_of_objs.element_at(k);
-	my_pair->integrated_anti_energy=0.0f;
-    }
+void IVP_Friction_System::clear_integrated_anti_energy() {
+  for (int k = fr_pairs_of_objs.len() - 1; k >= 0; k--) {
+    IVP_Friction_Core_Pair *my_pair = fr_pairs_of_objs.element_at(k);
+    my_pair->integrated_anti_energy = 0.0f;
+  }
 }
 
-
-void IVP_Friction_Core_Pair::remove_energy_gained_by_real_friction()
-{
-    integrated_anti_energy *= objs[0]->environment->get_integrated_energy_damp(); //to avoid accumulation to neverending
-    if(integrated_anti_energy<0.0f){ 
-	return;
-    }
-        //printf("destroyyenergy %.8f\n",integrated_anti_energy);
+void IVP_Friction_Core_Pair::remove_energy_gained_by_real_friction() {
+  integrated_anti_energy *=
+      objs[0]
+          ->environment->get_integrated_energy_damp(); // to avoid accumulation
+                                                       // to neverending
+  if (integrated_anti_energy < 0.0f) {
+    return;
+  }
+  // printf("destroyyenergy %.8f\n",integrated_anti_energy);
 #ifdef IVP_FAST_WHEELS_ENABLED
-    if (objs[0]->car_wheel || objs[1]->car_wheel){
-	return;
-    }
+  if (objs[0]->car_wheel || objs[1]->car_wheel) {
+    return;
+  }
 #endif
 
 #ifndef NO_MUTUAL_ENERGYDESTROY
-    IVP_DOUBLE amount_energy_destr;
-    amount_energy_destr=destroy_mutual_energy(integrated_anti_energy);
-    //printf("destr_eee %f\n",amount_energy_destr);
-    //printf("destroyed %f\n",amount_energy_destr);
-//	IVP_IF(1) {
-	objs[0]->environment->get_statistic_manager()->sum_energy_destr+=amount_energy_destr;
-//	}
-    integrated_anti_energy-=amount_energy_destr;
+  IVP_DOUBLE amount_energy_destr;
+  amount_energy_destr = destroy_mutual_energy(integrated_anti_energy);
+  // printf("destr_eee %f\n",amount_energy_destr);
+  // printf("destroyed %f\n",amount_energy_destr);
+  //	IVP_IF(1) {
+  objs[0]->environment->get_statistic_manager()->sum_energy_destr +=
+      amount_energy_destr;
+  //	}
+  integrated_anti_energy -= amount_energy_destr;
 #endif
 }
 
-IVP_DOUBLE IVP_Mutual_Energizer::calc_impulse_to_reduce_energy_level(IVP_DOUBLE speed_pot,IVP_DOUBLE inv_mass0,IVP_DOUBLE inv_mass1,IVP_DOUBLE delta_e)
-{
-    delta_e*=2.0f;
-    IVP_DOUBLE divisor=1.0f/(inv_mass0+inv_mass1);
-    IVP_DOUBLE root=(speed_pot*speed_pot-(inv_mass0+inv_mass1)*delta_e); ///(mass1*speed_pot*speed_pot-target_e));
-    root = IVP_Inline_Math::fabsd(root);
-    root = IVP_Inline_Math::ivp_sqrtf(root);
-    IVP_DOUBLE x=(speed_pot-root)*divisor;
-    return x;
+IVP_DOUBLE IVP_Mutual_Energizer::calc_impulse_to_reduce_energy_level(
+    IVP_DOUBLE speed_pot, IVP_DOUBLE inv_mass0, IVP_DOUBLE inv_mass1,
+    IVP_DOUBLE delta_e) {
+  delta_e *= 2.0f;
+  IVP_DOUBLE divisor = 1.0f / (inv_mass0 + inv_mass1);
+  IVP_DOUBLE root = (speed_pot * speed_pot -
+                     (inv_mass0 + inv_mass1) *
+                         delta_e); ///(mass1*speed_pot*speed_pot-target_e));
+  root = IVP_Inline_Math::fabsd(root);
+  root = IVP_Inline_Math::ivp_sqrtf(root);
+  IVP_DOUBLE x = (speed_pot - root) * divisor;
+  return x;
 }
 
-IVP_DOUBLE IVP_Mutual_Energizer::calc_energy_potential(IVP_DOUBLE speed_pot,IVP_DOUBLE mass0,IVP_DOUBLE mass1,IVP_DOUBLE inv_mass0,IVP_DOUBLE inv_mass1)
-{
-    IVP_DOUBLE x; //impulse done on objects to destroy potential, first obj is still
-    //Energy E1 of obj1: mass1 * (speed_pot - x*inv_mass1)^2
-    //Energy E0 of obj0: mass0 * (x*inv_mass0)^2
-    //point of minimal Energy: E1'(x) = -E0'(x)
+IVP_DOUBLE IVP_Mutual_Energizer::calc_energy_potential(IVP_DOUBLE speed_pot,
+                                                       IVP_DOUBLE mass0,
+                                                       IVP_DOUBLE mass1,
+                                                       IVP_DOUBLE inv_mass0,
+                                                       IVP_DOUBLE inv_mass1) {
+  IVP_DOUBLE
+      x; // impulse done on objects to destroy potential, first obj is still
+  // Energy E1 of obj1: mass1 * (speed_pot - x*inv_mass1)^2
+  // Energy E0 of obj0: mass0 * (x*inv_mass0)^2
+  // point of minimal Energy: E1'(x) = -E0'(x)
 
-    IVP_DOUBLE energy_now=mass1*speed_pot*speed_pot;
-    
-    x=speed_pot/(inv_mass0+inv_mass1); //solution of E1'(x) = -E0'(x) -> speed of both objects get identical, speed_pot gets zero
+  IVP_DOUBLE energy_now = mass1 * speed_pot * speed_pot;
 
-    IVP_DOUBLE E0,E1;
-    IVP_DOUBLE speed;
-    speed=speed_pot - x*inv_mass1;
-    E1=mass1*speed*speed;
+  x = speed_pot /
+      (inv_mass0 + inv_mass1); // solution of E1'(x) = -E0'(x) -> speed of both
+                               // objects get identical, speed_pot gets zero
 
-    speed=x*inv_mass0;
-    E0=mass0*speed*speed;
+  IVP_DOUBLE E0, E1;
+  IVP_DOUBLE speed;
+  speed = speed_pot - x * inv_mass1;
+  E1 = mass1 * speed * speed;
 
-    IVP_DOUBLE tmp = energy_now+P_DOUBLE_EPS - (E0+E1);
-	// VALVE: For very large energies (e.g. 3e15) this can be slightly off due to precision errors :(
-	// Clamp instead
-	// IVP_ASSERT(tmp>=0);
-	if ( tmp < 0 )
-	{
-		tmp = 0;
-	}
+  speed = x * inv_mass0;
+  E0 = mass0 * speed * speed;
 
-    return 0.5f*(energy_now-E0-E1);
+  IVP_DOUBLE tmp = energy_now + P_DOUBLE_EPS - (E0 + E1);
+  // VALVE: For very large energies (e.g. 3e15) this can be slightly off due to
+  // precision errors :( Clamp instead IVP_ASSERT(tmp>=0);
+  if (tmp < 0) {
+    tmp = 0;
+  }
+
+  return 0.5f * (energy_now - E0 - E1);
 }
 
 // rot moment in a direction
 // rot_vec_obj is normized
-void IVP_Mutual_Energizer::get_rot_inertia(IVP_Core *core,IVP_U_Float_Point *rot_vec_obj,IVP_DOUBLE *rot_inertia,IVP_DOUBLE *inv_rot_inertia)
-{
-    IVP_U_Float_Point rot_vec_abs;
-    rot_vec_abs.set_pairwise_mult(rot_vec_obj,core->get_rot_inertia());
-    *rot_inertia=rot_vec_abs.real_length();
-    if(*rot_inertia<P_DOUBLE_EPS) {
-	*rot_inertia=1.0f;
-	*inv_rot_inertia=1.0f;
-    } else {
-	*inv_rot_inertia=1.0f/(*rot_inertia);
-    }
+void IVP_Mutual_Energizer::get_rot_inertia(IVP_Core *core,
+                                           IVP_U_Float_Point *rot_vec_obj,
+                                           IVP_DOUBLE *rot_inertia,
+                                           IVP_DOUBLE *inv_rot_inertia) {
+  IVP_U_Float_Point rot_vec_abs;
+  rot_vec_abs.set_pairwise_mult(rot_vec_obj, core->get_rot_inertia());
+  *rot_inertia = rot_vec_abs.real_length();
+  if (*rot_inertia < P_DOUBLE_EPS) {
+    *rot_inertia = 1.0f;
+    *inv_rot_inertia = 1.0f;
+  } else {
+    *inv_rot_inertia = 1.0f / (*rot_inertia);
+  }
 }
 
-void IVP_Mutual_Energizer::init_mutual_energizer(IVP_Core *core0,IVP_Core *core1) {
-    if(core1->physical_unmoveable || core1->pinned) { //@@CBPIN
-	this->core[0]=core1;
-	this->core[1]=core0;
+void IVP_Mutual_Energizer::init_mutual_energizer(IVP_Core *core0,
+                                                 IVP_Core *core1) {
+  if (core1->physical_unmoveable || core1->pinned) { //@@CBPIN
+    this->core[0] = core1;
+    this->core[1] = core0;
+  } else {
+    this->core[1] = core1;
+    this->core[0] = core0;
+  }
+  // now core1 is moveable
+
+  {
+    trans_vec_world.subtract(&core[1]->speed, &core[0]->speed);
+    trans_speed_potential = trans_vec_world.real_length_plus_normize();
+  }
+  {
+    IVP_U_Float_Point rot0_world;
+    core[0]->m_world_f_core_last_psi.vmult3(&core[0]->rot_speed, &rot0_world);
+    IVP_U_Float_Point rot1_world;
+    core[1]->m_world_f_core_last_psi.vmult3(&core[1]->rot_speed, &rot1_world);
+    IVP_U_Float_Point rot_vec_world;
+    rot_vec_world.subtract(&rot1_world, &rot0_world);
+
+    rot_speed_potential = rot_vec_world.real_length_plus_normize();
+    core[0]->m_world_f_core_last_psi.vimult3(&rot_vec_world, &rot_vec_obj[0]);
+    rot_vec_world.mult(-1.0f);
+    core[1]->m_world_f_core_last_psi.vimult3(&rot_vec_world, &rot_vec_obj[1]);
+
+    get_rot_inertia(core[0], &rot_vec_obj[0], &rot_inertia[0],
+                    &inv_rot_inertia[0]);
+    get_rot_inertia(core[1], &rot_vec_obj[1], &rot_inertia[1],
+                    &inv_rot_inertia[1]);
+  }
+  {
+    trans_inertia[1] = core[1]->get_mass();
+    inv_trans_inertia[1] = core[1]->get_inv_mass();
+    if (core[0]->physical_unmoveable || core[0]->pinned) { //@@CBPIN
+      trans_inertia[0] = 10000 * trans_inertia[1];
+      inv_trans_inertia[0] = inv_trans_inertia[1] * (1.0f / 10000.0f);
+      rot_inertia[0] = 10000 * rot_inertia[1];
+      inv_rot_inertia[0] = inv_rot_inertia[1] * (1.0f / 10000.0f);
     } else {
-	this->core[1]=core1;
-	this->core[0]=core0;
+      trans_inertia[0] = core[0]->get_mass();
+      inv_trans_inertia[0] = core[0]->get_inv_mass();
     }
-    //now core1 is moveable
-
-    {
-	trans_vec_world.subtract(&core[1]->speed,&core[0]->speed);
-	trans_speed_potential=trans_vec_world.real_length_plus_normize();
-    }
-    {
-	IVP_U_Float_Point rot0_world;   	core[0]->m_world_f_core_last_psi.vmult3(&core[0]->rot_speed,&rot0_world);
-	IVP_U_Float_Point rot1_world;   	core[1]->m_world_f_core_last_psi.vmult3(&core[1]->rot_speed,&rot1_world);
-	IVP_U_Float_Point rot_vec_world; 	rot_vec_world.subtract(&rot1_world,&rot0_world);
-	
-	rot_speed_potential = rot_vec_world.real_length_plus_normize();
-	core[0]->m_world_f_core_last_psi.vimult3(&rot_vec_world,&rot_vec_obj[0]);
-	rot_vec_world.mult(-1.0f);
-	core[1]->m_world_f_core_last_psi.vimult3(&rot_vec_world,&rot_vec_obj[1]);
-	
-	get_rot_inertia(core[0],&rot_vec_obj[0],&rot_inertia[0],&inv_rot_inertia[0]);
-	get_rot_inertia(core[1],&rot_vec_obj[1],&rot_inertia[1],&inv_rot_inertia[1]);
-    }
-    {
-	trans_inertia[1] = core[1]->get_mass();
-	inv_trans_inertia[1]=core[1]->get_inv_mass();
-	if(core[0]->physical_unmoveable || core[0]->pinned) { //@@CBPIN
-	    trans_inertia[0]=10000*trans_inertia[1];
-	    inv_trans_inertia[0]=inv_trans_inertia[1]*(1.0f/10000.0f);
-	    rot_inertia[0]=10000*rot_inertia[1];
-	    inv_rot_inertia[0]=inv_rot_inertia[1]*(1.0f/10000.0f);
-	} else {
-	    trans_inertia[0]=core[0]->get_mass();
-	    inv_trans_inertia[0]=core[0]->get_inv_mass();
-	}
-    }
+  }
 }
 
-void IVP_Mutual_Energizer::calc_energy_potential() {   
-	rot_energy_potential = calc_energy_potential(rot_speed_potential,rot_inertia[0],rot_inertia[1],inv_rot_inertia[0],inv_rot_inertia[1]);
-	trans_energy_potential = calc_energy_potential(trans_speed_potential,trans_inertia[0],trans_inertia[1],inv_trans_inertia[0],inv_trans_inertia[1]);
-	whole_mutual_energy = trans_energy_potential+rot_energy_potential;
+void IVP_Mutual_Energizer::calc_energy_potential() {
+  rot_energy_potential =
+      calc_energy_potential(rot_speed_potential, rot_inertia[0], rot_inertia[1],
+                            inv_rot_inertia[0], inv_rot_inertia[1]);
+  trans_energy_potential = calc_energy_potential(
+      trans_speed_potential, trans_inertia[0], trans_inertia[1],
+      inv_trans_inertia[0], inv_trans_inertia[1]);
+  whole_mutual_energy = trans_energy_potential + rot_energy_potential;
 }
 
-void IVP_Mutual_Energizer::destroy_percent_energy(IVP_DOUBLE percent_energy_to_destroy)
-{
-    IVP_DOUBLE rot_impulse=calc_impulse_to_reduce_energy_level(rot_speed_potential,inv_rot_inertia[0],inv_rot_inertia[1],percent_energy_to_destroy*rot_energy_potential);
-    IVP_DOUBLE trans_impulse=calc_impulse_to_reduce_energy_level(trans_speed_potential,inv_trans_inertia[0],inv_trans_inertia[1],percent_energy_to_destroy*trans_energy_potential);
-    if(!core[0]->physical_unmoveable && !core[0]->pinned) {
-	core[0]->speed_change.add_multiple(&trans_vec_world,inv_trans_inertia[0]*trans_impulse);
-	core[0]->rot_speed_change.add_multiple(&rot_vec_obj[0],inv_rot_inertia[0]*rot_impulse);
-    }
-    trans_vec_world.mult(-1.0f);
-    //printf("muttd %f %f\n",trans_impulse,rot_impulse);
-    core[1]->speed_change.add_multiple(&trans_vec_world,inv_trans_inertia[1]*trans_impulse);
-    core[1]->rot_speed_change.add_multiple(&rot_vec_obj[1],inv_rot_inertia[1]*rot_impulse);
+void IVP_Mutual_Energizer::destroy_percent_energy(
+    IVP_DOUBLE percent_energy_to_destroy) {
+  IVP_DOUBLE rot_impulse = calc_impulse_to_reduce_energy_level(
+      rot_speed_potential, inv_rot_inertia[0], inv_rot_inertia[1],
+      percent_energy_to_destroy * rot_energy_potential);
+  IVP_DOUBLE trans_impulse = calc_impulse_to_reduce_energy_level(
+      trans_speed_potential, inv_trans_inertia[0], inv_trans_inertia[1],
+      percent_energy_to_destroy * trans_energy_potential);
+  if (!core[0]->physical_unmoveable && !core[0]->pinned) {
+    core[0]->speed_change.add_multiple(&trans_vec_world,
+                                       inv_trans_inertia[0] * trans_impulse);
+    core[0]->rot_speed_change.add_multiple(&rot_vec_obj[0],
+                                           inv_rot_inertia[0] * rot_impulse);
+  }
+  trans_vec_world.mult(-1.0f);
+  // printf("muttd %f %f\n",trans_impulse,rot_impulse);
+  core[1]->speed_change.add_multiple(&trans_vec_world,
+                                     inv_trans_inertia[1] * trans_impulse);
+  core[1]->rot_speed_change.add_multiple(&rot_vec_obj[1],
+                                         inv_rot_inertia[1] * rot_impulse);
 }
 
-IVP_DOUBLE IVP_Friction_Core_Pair::destroy_mutual_energy(IVP_DOUBLE d_e){
-    IVP_Mutual_Energizer mutual_energizer_stack;
-    mutual_energizer_stack.init_mutual_energizer(objs[0],objs[1]);
+IVP_DOUBLE IVP_Friction_Core_Pair::destroy_mutual_energy(IVP_DOUBLE d_e) {
+  IVP_Mutual_Energizer mutual_energizer_stack;
+  mutual_energizer_stack.init_mutual_energizer(objs[0], objs[1]);
 
-    mutual_energizer_stack.calc_energy_potential();
-    IVP_DOUBLE max_energy_to_destroy = MAX_ENERGY_DESTROY * mutual_energizer_stack.whole_mutual_energy;
-    if(d_e > max_energy_to_destroy) {
-	d_e=max_energy_to_destroy;
-	//d_e=whole_mutual_energy;
-    }
-    if(mutual_energizer_stack.whole_mutual_energy < P_DOUBLE_EPS) {
-	return 0.0f;
-    }
-    //printf("destroyy %f\n",d_e);
-    IVP_DOUBLE percent_energy_to_destroy = d_e / mutual_energizer_stack.whole_mutual_energy;
+  mutual_energizer_stack.calc_energy_potential();
+  IVP_DOUBLE max_energy_to_destroy =
+      MAX_ENERGY_DESTROY * mutual_energizer_stack.whole_mutual_energy;
+  if (d_e > max_energy_to_destroy) {
+    d_e = max_energy_to_destroy;
+    // d_e=whole_mutual_energy;
+  }
+  if (mutual_energizer_stack.whole_mutual_energy < P_DOUBLE_EPS) {
+    return 0.0f;
+  }
+  // printf("destroyy %f\n",d_e);
+  IVP_DOUBLE percent_energy_to_destroy =
+      d_e / mutual_energizer_stack.whole_mutual_energy;
 
-    mutual_energizer_stack.destroy_percent_energy(percent_energy_to_destroy);    
-    return d_e;
+  mutual_energizer_stack.destroy_percent_energy(percent_energy_to_destroy);
+  return d_e;
 }
 
 IVP_Friction_Core_Pair::~IVP_Friction_Core_Pair() {
-    //printf("deleteing_core_pair %lx\n",0x0000ffff&(long)this);
+  // printf("deleteing_core_pair %lx\n",0x0000ffff&(long)this);
 }
 
-IVP_Friction_Core_Pair::IVP_Friction_Core_Pair()
-{
-    last_impact_time_pair=-1000.0f; //negative time
-    integrated_anti_energy=0.0f;
-    next_ease_nr_psi=1;
+IVP_Friction_Core_Pair::IVP_Friction_Core_Pair() {
+  last_impact_time_pair = -1000.0f; // negative time
+  integrated_anti_energy = 0.0f;
+  next_ease_nr_psi = 1;
 }
 
-void IVP_Friction_Core_Pair::set_friction_vectors(IVP_U_Float_Point *average_friction) {
-    for (int i = fr_dists.len()-1; i>=0; i--){
-	IVP_Contact_Point *fr_dist = fr_dists.element_at(i);
-	    IVP_DOUBLE sign;
-	    if( fr_dist->get_synapse(0)->get_object()->physical_core == objs[0] ) {
-		sign = 1.0f;
-	    } else {
-		sign =-1.0f;
-	    }
-	    IVP_Impact_Solver_Long_Term *info = fr_dist->tmp_contact_info;
-	    fr_dist->span_friction_s[0]=average_friction->dot_product(&info->span_friction_v[0])*sign;
-	    fr_dist->span_friction_s[1]=average_friction->dot_product(&info->span_friction_v[1])*sign;
-	}
+void IVP_Friction_Core_Pair::set_friction_vectors(
+    IVP_U_Float_Point *average_friction) {
+  for (int i = fr_dists.len() - 1; i >= 0; i--) {
+    IVP_Contact_Point *fr_dist = fr_dists.element_at(i);
+    IVP_DOUBLE sign;
+    if (fr_dist->get_synapse(0)->get_object()->physical_core == objs[0]) {
+      sign = 1.0f;
+    } else {
+      sign = -1.0f;
+    }
+    IVP_Impact_Solver_Long_Term *info = fr_dist->tmp_contact_info;
+    fr_dist->span_friction_s[0] =
+        average_friction->dot_product(&info->span_friction_v[0]) * sign;
+    fr_dist->span_friction_s[1] =
+        average_friction->dot_product(&info->span_friction_v[1]) * sign;
+  }
 }
 
-void IVP_Friction_Core_Pair::get_average_friction_vector(IVP_U_Float_Point *average_friction) {
-    average_friction->set_to_zero();
-    int numbers = fr_dists.len();
-    if( numbers > 0 ) {
-	IVP_DOUBLE factor = 1.0f/numbers;
-	for (int i = fr_dists.len()-1; i>=0; i--){
-	    IVP_Contact_Point *fr_dist = fr_dists.element_at(i);
-	    IVP_U_Float_Point temp_v;
-	    temp_v.set_to_zero();
-	    IVP_Impact_Solver_Long_Term *info = fr_dist->tmp_contact_info;
-	    temp_v.add_multiple(&info->span_friction_v[0],fr_dist->span_friction_s[0]);
-	    temp_v.add_multiple(&info->span_friction_v[1],fr_dist->span_friction_s[1]);
-	    IVP_DOUBLE sign;
-	    if( fr_dist->get_synapse(0)->get_object()->physical_core == objs[0] ) {
-		sign = 1.0f;
-	    } else {
-		sign =-1.0f;
-	    }
+void IVP_Friction_Core_Pair::get_average_friction_vector(
+    IVP_U_Float_Point *average_friction) {
+  average_friction->set_to_zero();
+  int numbers = fr_dists.len();
+  if (numbers > 0) {
+    IVP_DOUBLE factor = 1.0f / numbers;
+    for (int i = fr_dists.len() - 1; i >= 0; i--) {
+      IVP_Contact_Point *fr_dist = fr_dists.element_at(i);
+      IVP_U_Float_Point temp_v;
+      temp_v.set_to_zero();
+      IVP_Impact_Solver_Long_Term *info = fr_dist->tmp_contact_info;
+      temp_v.add_multiple(&info->span_friction_v[0],
+                          fr_dist->span_friction_s[0]);
+      temp_v.add_multiple(&info->span_friction_v[1],
+                          fr_dist->span_friction_s[1]);
+      IVP_DOUBLE sign;
+      if (fr_dist->get_synapse(0)->get_object()->physical_core == objs[0]) {
+        sign = 1.0f;
+      } else {
+        sign = -1.0f;
+      }
 
-	    average_friction->add_multiple(&temp_v,sign);
-	}
-	average_friction->mult(factor);
+      average_friction->add_multiple(&temp_v, sign);
     }
+    average_friction->mult(factor);
+  }
 }
 
 void IVP_Friction_Core_Pair::debug_printf_pair() {
-    IVP_IF(1) {
-	IVP_Real_Object *obj1,*obj2;
-	obj1=objs[0]->objects.element_at(0);
-	obj2=objs[1]->objects.element_at(0);
-	printf("frpair_names %s %s ",obj1->get_name(),obj2->get_name());
-    }
+  IVP_IF(1) {
+    IVP_Real_Object *obj1, *obj2;
+    obj1 = objs[0]->objects.element_at(0);
+    obj2 = objs[1]->objects.element_at(0);
+    printf("frpair_names %s %s ", obj1->get_name(), obj2->get_name());
+  }
 }
 
 void IVP_Friction_Core_Pair::debug_store_vector_before_ease() {
-    span_vector_sum.set_to_zero();
-    get_average_friction_vector(&span_vector_sum);
+  span_vector_sum.set_to_zero();
+  get_average_friction_vector(&span_vector_sum);
 }
 
 void IVP_Friction_Core_Pair::debug_read_vector_after_ease() {
-    IVP_U_Float_Point test_vec;
-    test_vec.set_to_zero();
-    get_average_friction_vector(&test_vec);
+  IVP_U_Float_Point test_vec;
+  test_vec.set_to_zero();
+  get_average_friction_vector(&test_vec);
 #if 0    
     IVP_Contact_Point *fr_dist;
     for(fr_dist=this->get_first_fr_dist_obj_pairs(); fr_dist; fr_dist=this->get_next_fr_dist_obj_pairs()) {
@@ -1876,68 +1988,68 @@
 	test_vec.add_multiple(&temp_v,sign);
     }
 #endif
-    IVP_U_Float_Point diff;
-    diff.subtract(&test_vec,&span_vector_sum);
-    if( diff.real_length() > 0.01f ) {
-	printf("easingerror: %f %f %f should equal %f %f %f\n",test_vec.k[0],test_vec.k[1],test_vec.k[2],span_vector_sum.k[0],span_vector_sum.k[1],span_vector_sum.k[2]);
-    }
+  IVP_U_Float_Point diff;
+  diff.subtract(&test_vec, &span_vector_sum);
+  if (diff.real_length() > 0.01f) {
+    printf("easingerror: %f %f %f should equal %f %f %f\n", test_vec.k[0],
+           test_vec.k[1], test_vec.k[2], span_vector_sum.k[0],
+           span_vector_sum.k[1], span_vector_sum.k[2]);
+  }
 }
 
-
-void IVP_Friction_System::debug_fs_out_ascii()
-{
-    IVP_IF(1) {
-    printf("fs %lx  ",(long)this&0x0000ffff);
-		for(IVP_Contact_Point *mindist=this->get_first_friction_dist();mindist;mindist=this->get_next_friction_dist(mindist))
-		{
-		    printf("%lx ",(long)mindist&0x0000ffff);
-		}    
+void IVP_Friction_System::debug_fs_out_ascii() {
+  IVP_IF(1) {
+    printf("fs %lx  ", (long)this & 0x0000ffff);
+    for (IVP_Contact_Point *mindist = this->get_first_friction_dist(); mindist;
+         mindist = this->get_next_friction_dist(mindist)) {
+      printf("%lx ", (long)mindist & 0x0000ffff);
+    }
     printf("\n");
-    for (int k = cores_of_friction_system.len()-1; k>=0; k--){
-	IVP_Core *my_core = cores_of_friction_system.element_at(k);
-        printf("    core %lx  ",(long)my_core&0x0000ffff);
-	IVP_Friction_Info_For_Core *inf=my_core->get_friction_info(this);
-	printf("lfs %lx  ",(long)inf->l_friction_system&0x0000ffff);
+    for (int k = cores_of_friction_system.len() - 1; k >= 0; k--) {
+      IVP_Core *my_core = cores_of_friction_system.element_at(k);
+      printf("    core %lx  ", (long)my_core & 0x0000ffff);
+      IVP_Friction_Info_For_Core *inf = my_core->get_friction_info(this);
+      printf("lfs %lx  ", (long)inf->l_friction_system & 0x0000ffff);
 
-	for (int i = inf->friction_springs.len()-1; i>=0; i--){
-	    IVP_Contact_Point *mindist = inf->friction_springs.element_at(i);
-	    printf("%lx  ",(long)mindist&0x0000ffff);
-	}
+      for (int i = inf->friction_springs.len() - 1; i >= 0; i--) {
+        IVP_Contact_Point *mindist = inf->friction_springs.element_at(i);
+        printf("%lx  ", (long)mindist & 0x0000ffff);
+      }
     }
     printf("\n");
-    for (int m = fr_pairs_of_objs.len()-1; m>=0;m--){
-	IVP_Friction_Core_Pair *fr_pair = fr_pairs_of_objs.element_at(m);
-	printf("    p %lx %lx  ",(long)fr_pair->objs[0]&0x0000ffff,(long)fr_pair->objs[1]&0x0000ffff);
-	for (int c = fr_pair->fr_dists.len()-1; c>=0; c--){
-	    IVP_Contact_Point *fr_dist= fr_pair->fr_dists.element_at(c);
-	    printf("%lx ",(long)fr_dist&0x0000ffff);
-	}
+    for (int m = fr_pairs_of_objs.len() - 1; m >= 0; m--) {
+      IVP_Friction_Core_Pair *fr_pair = fr_pairs_of_objs.element_at(m);
+      printf("    p %lx %lx  ", (long)fr_pair->objs[0] & 0x0000ffff,
+             (long)fr_pair->objs[1] & 0x0000ffff);
+      for (int c = fr_pair->fr_dists.len() - 1; c >= 0; c--) {
+        IVP_Contact_Point *fr_dist = fr_pair->fr_dists.element_at(c);
+        printf("%lx ", (long)fr_dist & 0x0000ffff);
+      }
     }
     printf("\n");
-    }
+  }
 }
 
-IVP_BOOL IVP_Friction_System::core_is_found_in_pairs(IVP_Core *test_core)
-{
-    for (int m = fr_pairs_of_objs.len()-1; m>=0;m--){
-	IVP_Friction_Core_Pair *fr_pair = fr_pairs_of_objs.element_at(m);
-        if( (fr_pair->objs[0]==test_core) || (fr_pair->objs[1]==test_core) )
-	{
-	    return IVP_TRUE;
-	}
+IVP_BOOL IVP_Friction_System::core_is_found_in_pairs(IVP_Core *test_core) {
+  for (int m = fr_pairs_of_objs.len() - 1; m >= 0; m--) {
+    IVP_Friction_Core_Pair *fr_pair = fr_pairs_of_objs.element_at(m);
+    if ((fr_pair->objs[0] == test_core) || (fr_pair->objs[1] == test_core)) {
+      return IVP_TRUE;
     }
-    return IVP_FALSE;
+  }
+  return IVP_FALSE;
 }
 
-IVP_Friction_Core_Pair *IVP_Friction_System::find_pair_of_cores(IVP_Core *core0,IVP_Core *core1)
-{
-    for (int m = fr_pairs_of_objs.len()-1; m>=0;m--){
-	IVP_Friction_Core_Pair *my_pair = fr_pairs_of_objs.element_at(m);
-	if( ((my_pair->objs[0]==core0)&&(my_pair->objs[1]==core1)) || ((my_pair->objs[0]==core1)&&(my_pair->objs[1]==core0)) ) {
-	    return my_pair;
-	}
+IVP_Friction_Core_Pair *
+IVP_Friction_System::find_pair_of_cores(IVP_Core *core0, IVP_Core *core1) {
+  for (int m = fr_pairs_of_objs.len() - 1; m >= 0; m--) {
+    IVP_Friction_Core_Pair *my_pair = fr_pairs_of_objs.element_at(m);
+    if (((my_pair->objs[0] == core0) && (my_pair->objs[1] == core1)) ||
+        ((my_pair->objs[0] == core1) && (my_pair->objs[1] == core0))) {
+      return my_pair;
     }
-    return NULL;
+  }
+  return NULL;
 }
 
 #if 0
@@ -1949,320 +2061,336 @@
 #endif
 
 // be sure the core point of contact is valid
-// this function is called at generation of mindist. It should be called more often, as contact point can slide away
+// this function is called at generation of mindist. It should be called more
+// often, as contact point can slide away
 void IVP_Contact_Point::calc_virtual_mass_of_mindist() {
-    //do we have two friction values ?
-    IVP_Material *mtl[2];
-    get_material_info(mtl);
-    if( mtl[0]->second_friction_x_enabled || mtl[1]->second_friction_x_enabled ) {
-        this->two_friction_values=IVP_TRUE;
-    }
-    
-    IVP_Core *core[2];
-    for(int i=0;i<2;i++) {
-	core[i] = get_synapse(i)->get_object()->get_core();
-    }
-    IVP_DOUBLE virt_mass_mindist_no_dir;
-    if(core[0]->physical_unmoveable) {
-	virt_mass_mindist_no_dir =  core[1]->calc_virt_mass_worst_case(&tmp_contact_info->contact_point_cs[1]);
+  // do we have two friction values ?
+  IVP_Material *mtl[2];
+  get_material_info(mtl);
+  if (mtl[0]->second_friction_x_enabled || mtl[1]->second_friction_x_enabled) {
+    this->two_friction_values = IVP_TRUE;
+  }
+
+  IVP_Core *core[2];
+  for (int i = 0; i < 2; i++) {
+    core[i] = get_synapse(i)->get_object()->get_core();
+  }
+  IVP_DOUBLE virt_mass_mindist_no_dir;
+  if (core[0]->physical_unmoveable) {
+    virt_mass_mindist_no_dir = core[1]->calc_virt_mass_worst_case(
+        &tmp_contact_info->contact_point_cs[1]);
+  } else {
+    if (core[1]->physical_unmoveable) {
+      virt_mass_mindist_no_dir = core[0]->calc_virt_mass_worst_case(
+          &tmp_contact_info->contact_point_cs[0]);
     } else {
-	if(core[1]->physical_unmoveable) {
-	    virt_mass_mindist_no_dir =  core[0]->calc_virt_mass_worst_case(&tmp_contact_info->contact_point_cs[0]);
-	} else {
-	    IVP_DOUBLE vmass_no_dir[2];
-	    for (int j = 0;j<2;j++){
-		vmass_no_dir[j] = core[j]->calc_virt_mass_worst_case(&tmp_contact_info->contact_point_cs[j]);
-	    }
-	    virt_mass_mindist_no_dir=(vmass_no_dir[0]*vmass_no_dir[1])/(vmass_no_dir[0]+vmass_no_dir[1]);
-	}
+      IVP_DOUBLE vmass_no_dir[2];
+      for (int j = 0; j < 2; j++) {
+        vmass_no_dir[j] = core[j]->calc_virt_mass_worst_case(
+            &tmp_contact_info->contact_point_cs[j]);
+      }
+      virt_mass_mindist_no_dir = (vmass_no_dir[0] * vmass_no_dir[1]) /
+                                 (vmass_no_dir[0] + vmass_no_dir[1]);
     }
-    this->inv_virt_mass_mindist_no_dir = 1.0f / virt_mass_mindist_no_dir;
-    IVP_ASSERT(virt_mass_mindist_no_dir < 1e30f); // test for NaN
+  }
+  this->inv_virt_mass_mindist_no_dir = 1.0f / virt_mass_mindist_no_dir;
+  IVP_ASSERT(virt_mass_mindist_no_dir < 1e30f); // test for NaN
 }
 
-inline IVP_FLOAT ivp_minimum(IVP_FLOAT a,IVP_FLOAT b) {
-    if(a > b) {
-	return b;
-    } else {
-	return a;
-    }
+inline IVP_FLOAT ivp_minimum(IVP_FLOAT a, IVP_FLOAT b) {
+  if (a > b) {
+    return b;
+  } else {
+    return a;
+  }
 }
 
 // returns IVP_TRUE when a friction system has been grown
 IVP_BOOL IVP_Core::grow_friction_system() {
 
-    IVP_IF( environment->get_debug_manager()->check_fs ) {
-	printf("growing_fs %f core %lx\n",environment->get_current_time().get_time(),(long)this);
-    }
+  IVP_IF(environment->get_debug_manager()->check_fs) {
+    printf("growing_fs %f core %lx\n",
+           environment->get_current_time().get_time(), (long)this);
+  }
 
-    IVP_BOOL grew_new_contact_point=IVP_FALSE;
-    
-    //IVP_U_Vector<IVP_Core> wake_up_cores;
-    IVP_Core *start_core=this;
-    int c;
-    for(c = objects.len()-1;c>=0;c--) {
-	IVP_Real_Object *r_obj=this->objects.element_at(c);
+  IVP_BOOL grew_new_contact_point = IVP_FALSE;
 
-	IVP_Synapse_Real *my_synapse, *next_synapse;
-	for(my_synapse=r_obj->get_first_exact_synapse();   my_synapse;    my_synapse = next_synapse) {
-	    next_synapse = my_synapse->get_next();
-	    IVP_Mindist *my_mindist = my_synapse->get_mindist();
+  // IVP_U_Vector<IVP_Core> wake_up_cores;
+  IVP_Core *start_core = this;
+  int c;
+  for (c = objects.len() - 1; c >= 0; c--) {
+    IVP_Real_Object *r_obj = this->objects.element_at(c);
 
-	    if (my_mindist->mindist_function != IVP_MF_COLLISION) {  // grow real collisions only
-	      continue;
-	    }
-	    
-	    IVP_DOUBLE mindist_distance;
-	    
-	    IVP_Core *other_core=my_mindist->get_synapse(0)->get_object()->get_core();
-	    if(other_core == start_core) {
-	        other_core=my_mindist->get_synapse(1)->get_object()->get_core();
-	    }
-	    if(other_core->physical_unmoveable) {
-		if( this->physical_unmoveable ) {
-		    //printf("unnecessary_mindist\n");
-		    P_DELETE( my_mindist );
-		}
-		continue;
-	    }
+    IVP_Synapse_Real *my_synapse, *next_synapse;
+    for (my_synapse = r_obj->get_first_exact_synapse(); my_synapse;
+         my_synapse = next_synapse) {
+      next_synapse = my_synapse->get_next();
+      IVP_Mindist *my_mindist = my_synapse->get_mindist();
 
-	    /* When there are cores in friction systems enable this part */
-	    IVP_Friction_Info_For_Core *fr_info=other_core->moveable_core_has_friction_info();
-	    if(fr_info) {
-	        //continue;
-		goto next_in_loop;
-	    }
-	    
-	    my_mindist->recalc_mindist();
-	    if (my_mindist->recalc_result != IVP_MDRR_OK){ 
-		continue;
-	    }
-	    
-	    mindist_distance = my_mindist->get_length();
+      if (my_mindist->mindist_function !=
+          IVP_MF_COLLISION) { // grow real collisions only
+        continue;
+      }
 
-	    if( mindist_distance < ivp_mindist_settings.max_distance_for_friction ) {
-		IVP_Friction_System *affected_friction_system;
-		IVP_BOOL having_new_dist;
-		this->environment->sim_unit_mem->start_memory_transaction();
-		my_mindist->try_to_generate_managed_friction(&affected_friction_system,&having_new_dist,this->sim_unit_of_core,IVP_TRUE); //do not call recalc_friction_s_vals
-		this->environment->sim_unit_mem->end_memory_transaction();
-		if(having_new_dist==IVP_TRUE) {
-		    grew_new_contact_point=IVP_TRUE;
-		    other_core->reset_freeze_check_values();
-		}
-	    }
-	    //printf("\n\n\nnot_grow_with_core %lx\n\n\n",(long)other_core);
-next_in_loop:;
-	}
+      IVP_DOUBLE mindist_distance;
+
+      IVP_Core *other_core =
+          my_mindist->get_synapse(0)->get_object()->get_core();
+      if (other_core == start_core) {
+        other_core = my_mindist->get_synapse(1)->get_object()->get_core();
+      }
+      if (other_core->physical_unmoveable) {
+        if (this->physical_unmoveable) {
+          // printf("unnecessary_mindist\n");
+          P_DELETE(my_mindist);
+        }
+        continue;
+      }
+
+      /* When there are cores in friction systems enable this part */
+      IVP_Friction_Info_For_Core *fr_info =
+          other_core->moveable_core_has_friction_info();
+      if (fr_info) {
+        // continue;
+        goto next_in_loop;
+      }
+
+      my_mindist->recalc_mindist();
+      if (my_mindist->recalc_result != IVP_MDRR_OK) {
+        continue;
+      }
+
+      mindist_distance = my_mindist->get_length();
+
+      if (mindist_distance < ivp_mindist_settings.max_distance_for_friction) {
+        IVP_Friction_System *affected_friction_system;
+        IVP_BOOL having_new_dist;
+        this->environment->sim_unit_mem->start_memory_transaction();
+        my_mindist->try_to_generate_managed_friction(
+            &affected_friction_system, &having_new_dist, this->sim_unit_of_core,
+            IVP_TRUE); // do not call recalc_friction_s_vals
+        this->environment->sim_unit_mem->end_memory_transaction();
+        if (having_new_dist == IVP_TRUE) {
+          grew_new_contact_point = IVP_TRUE;
+          other_core->reset_freeze_check_values();
+        }
+      }
+      // printf("\n\n\nnot_grow_with_core %lx\n\n\n",(long)other_core);
+    next_in_loop:;
     }
+  }
 
-    return grew_new_contact_point;
+  return grew_new_contact_point;
 }
 
-
 void IVP_Friction_System::get_controlled_cores(IVP_U_Vector<IVP_Core> *vectr) {
-    vectr=NULL;
+  vectr = NULL;
 }
 
 IVP_DOUBLE IVP_Friction_System::get_minimum_simulation_frequency() {
-    return 1.0f;
+  return 1.0f;
 }
 
 IVP_U_Vector<IVP_Core> *IVP_Friction_System::get_associated_controlled_cores() {
-    return &moveable_cores_of_friction_system;
+  return &moveable_cores_of_friction_system;
 }
 
-void IVP_Friction_Sys_Energy::do_simulation_controller(IVP_Event_Sim *es,IVP_U_Vector<IVP_Core> *) {
-    //special case for one contact point
-    if( (l_friction_system->friction_dist_number<=1 )&&1) {
-	IVP_Contact_Point *cp=l_friction_system->get_first_friction_dist();
-	cp->recalc_friction_s_vals();
-	return;
-    }
-    
-    l_friction_system->fs_recalc_all_contact_points();
-#if !defined( NO_MUTUAL_ENERGYDESTROY )
-    if(es->sim_unit->sim_unit_just_slowed_down) {
-	l_friction_system->clear_integrated_anti_energy();
-    }
-    if(!es->sim_unit->sim_unit_has_fast_objects) {
-	l_friction_system->remove_energy_gained_by_real_friction();
-    }
-#endif    
+void IVP_Friction_Sys_Energy::do_simulation_controller(
+    IVP_Event_Sim *es, IVP_U_Vector<IVP_Core> *) {
+  // special case for one contact point
+  if ((l_friction_system->friction_dist_number <= 1) && 1) {
+    IVP_Contact_Point *cp = l_friction_system->get_first_friction_dist();
+    cp->recalc_friction_s_vals();
+    return;
+  }
+
+  l_friction_system->fs_recalc_all_contact_points();
+#if !defined(NO_MUTUAL_ENERGYDESTROY)
+  if (es->sim_unit->sim_unit_just_slowed_down) {
+    l_friction_system->clear_integrated_anti_energy();
+  }
+  if (!es->sim_unit->sim_unit_has_fast_objects) {
+    l_friction_system->remove_energy_gained_by_real_friction();
+  }
+#endif
 }
 
 void IVP_Friction_Sys_Static::do_simulation_single_friction(IVP_Event_Sim *es) {
-    //maybe destroy anti energy of first core_pair
+  // maybe destroy anti energy of first core_pair
 
-    IVP_Contact_Point *cp=l_friction_system->get_first_friction_dist();
+  IVP_Contact_Point *cp = l_friction_system->get_first_friction_dist();
 
-    cp->static_friction_single(es,ivp_mindist_settings.friction_dist,1.0f);
+  cp->static_friction_single(es, ivp_mindist_settings.friction_dist, 1.0f);
 
-    if((cp->get_gap_length() >= ivp_mindist_settings.max_distance_for_friction) || (cp->get_lt()->friction_is_broken == IVP_TRUE)){    	    
-	l_friction_system->delete_friction_distance(cp);
-	return;
-    }
+  if ((cp->get_gap_length() >=
+       ivp_mindist_settings.max_distance_for_friction) ||
+      (cp->get_lt()->friction_is_broken == IVP_TRUE)) {
+    l_friction_system->delete_friction_distance(cp);
+    return;
+  }
 }
 
-void IVP_Friction_Sys_Static::do_simulation_controller(IVP_Event_Sim *es,IVP_U_Vector<IVP_Core> * /*core_list*/) {
-    if( (l_friction_system->friction_dist_number <= 1 )&&1) {
-	do_simulation_single_friction(es);
-    } else {
-	l_friction_system->do_friction_system(es);
-    }
+void IVP_Friction_Sys_Static::do_simulation_controller(
+    IVP_Event_Sim *es, IVP_U_Vector<IVP_Core> * /*core_list*/) {
+  if ((l_friction_system->friction_dist_number <= 1) && 1) {
+    do_simulation_single_friction(es);
+  } else {
+    l_friction_system->do_friction_system(es);
+  }
 
-    //when all fr_dists are deleted this affects sim_u (controller is deleted), but does no harm (luckily)
-    
-    if( l_friction_system->friction_dist_number == 0 ) {
-      //sim_u->rem_sim_unit_controller( l_friction_system );
-      //sim_u->rem_sim_unit_controller( &l_friction_system->static_fs_handle );
-        IVP_Friction_System *temp_sys=l_friction_system;
-	l_friction_system=NULL; 
-	P_DELETE( temp_sys );
-	es->sim_unit->union_find_needed_for_sim_unit=IVP_TRUE;
-	return;
+  // when all fr_dists are deleted this affects sim_u (controller is deleted),
+  // but does no harm (luckily)
+
+  if (l_friction_system->friction_dist_number == 0) {
+    // sim_u->rem_sim_unit_controller( l_friction_system );
+    // sim_u->rem_sim_unit_controller( &l_friction_system->static_fs_handle );
+    IVP_Friction_System *temp_sys = l_friction_system;
+    l_friction_system = NULL;
+    P_DELETE(temp_sys);
+    es->sim_unit->union_find_needed_for_sim_unit = IVP_TRUE;
+    return;
+  }
+  if (l_friction_system->union_find_necessary) {
+    l_friction_system->union_find_necessary = IVP_FALSE;
+    // IVP_Core
+    // *obj=l_friction_system->l_environment->get_friction_manager()->union_find_fr_sys(l_friction_system);
+    IVP_Core *obj = l_friction_system->union_find_fr_sys();
+    if (obj) {
+      // l_friction_system->l_environment->get_friction_manager()->split_friction_system(obj,l_friction_system);
+      l_friction_system->split_friction_system(obj);
+      obj->sim_unit_of_core->union_find_needed_for_sim_unit = IVP_TRUE;
+      // obj->sim_unit_of_core->perform_test_and_split();
     }
-    if( l_friction_system->union_find_necessary ) {
-        l_friction_system->union_find_necessary=IVP_FALSE;
-        //IVP_Core *obj=l_friction_system->l_environment->get_friction_manager()->union_find_fr_sys(l_friction_system);
-	IVP_Core *obj=l_friction_system->union_find_fr_sys();
-        if(obj) {
-	    //l_friction_system->l_environment->get_friction_manager()->split_friction_system(obj,l_friction_system);
-	    l_friction_system->split_friction_system(obj);
-	    obj->sim_unit_of_core->union_find_needed_for_sim_unit=IVP_TRUE;
-	    //obj->sim_unit_of_core->perform_test_and_split();
-        }
-    }
-    IVP_IF(1) {
-	l_friction_system->debug_clean_tmp_info();
-    }
+  }
+  IVP_IF(1) { l_friction_system->debug_clean_tmp_info(); }
 }
 
-void IVP_Friction_System::do_simulation_controller(IVP_Event_Sim *es,IVP_U_Vector<IVP_Core> *) {
-    //special case single friction
-    if( ( friction_dist_number<=1 )&&1) {
-	IVP_Contact_Point *cp=this->get_first_friction_dist();
-	//cp->recalc_friction_s_vals();
+void IVP_Friction_System::do_simulation_controller(IVP_Event_Sim *es,
+                                                   IVP_U_Vector<IVP_Core> *) {
+  // special case single friction
+  if ((friction_dist_number <= 1) && 1) {
+    IVP_Contact_Point *cp = this->get_first_friction_dist();
+    // cp->recalc_friction_s_vals();
 
-	IVP_FLOAT max_local_spring_len = cp->get_possible_friction_slide_way(es) * es->delta_time * es->delta_time;
+    IVP_FLOAT max_local_spring_len = cp->get_possible_friction_slide_way(es) *
+                                     es->delta_time * es->delta_time;
 
-	cp->calc_pretension( max_local_spring_len );
-	
-	if(cp->two_friction_values!=IVP_TRUE) {
-	    cp->friction_force_local_constraint_2d(es);
-	} else {
-	    cp->friction_force_local_constraint_1d(es);
-	}
-	
-	return;
+    cp->calc_pretension(max_local_spring_len);
+
+    if (cp->two_friction_values != IVP_TRUE) {
+      cp->friction_force_local_constraint_2d(es);
+    } else {
+      cp->friction_force_local_constraint_1d(es);
     }
-    apply_real_friction(es);
+
+    return;
+  }
+  apply_real_friction(es);
 }
 
 void IVP_Friction_System::core_is_going_to_be_deleted_event(IVP_Core *core) {
-    IVP_USE(core);
+  IVP_USE(core);
 }
 
-void IVP_Friction_Sys_Energy::core_is_going_to_be_deleted_event(IVP_Core *core) {
-    IVP_USE(core);
+void IVP_Friction_Sys_Energy::core_is_going_to_be_deleted_event(
+    IVP_Core *core) {
+  IVP_USE(core);
 }
 
 int IVP_Synapse_Friction::get_material_index() const {
-    return this->edge->get_triangle()->get_material_index();
+  return this->edge->get_triangle()->get_material_index();
 }
 
+IVP_BOOL IVP_Synapse_Friction::is_same_as(const IVP_Synapse_Real *syn1) const {
+  const IVP_Synapse_Friction *syn0 = this;
+  IVP_ASSERT(syn0->l_obj == syn1->l_obj);
 
+  IVP_SYNAPSE_POLYGON_STATUS syn_stat = syn0->get_status();
+  if (syn_stat != syn1->get_status())
+    return IVP_FALSE;
 
-IVP_BOOL IVP_Synapse_Friction::is_same_as(const IVP_Synapse_Real *syn1) const
-{
-    const IVP_Synapse_Friction *syn0 = this;
-    IVP_ASSERT( syn0->l_obj == syn1->l_obj );
-    
-    IVP_SYNAPSE_POLYGON_STATUS syn_stat = syn0->get_status();
-    if(syn_stat!= syn1->get_status() ) return IVP_FALSE;
+  switch (syn_stat) {
+  case IVP_ST_POINT: {
+    // check for ledge and start point index to identify a point
+    const IVP_Compact_Ledge *l0 = syn0->edge->get_compact_ledge();
+    const IVP_Compact_Ledge *l1 = syn1->edge->get_compact_ledge();
+    if (l0 != l1)
+      return IVP_FALSE;
 
-    switch(syn_stat)
-    {
-        case IVP_ST_POINT: {
-	    //check for ledge and start point index to identify a point
-	    const IVP_Compact_Ledge *l0 = syn0->edge->get_compact_ledge();
-	    const IVP_Compact_Ledge *l1 = syn1->edge->get_compact_ledge();
-	    if (l0 != l1) return IVP_FALSE;
-	    
-	    if( syn0->edge->get_start_point_index() != syn1->edge->get_start_point_index() ){
-		return IVP_FALSE;
-	    }
-	    return IVP_TRUE;
-	}
-        case IVP_ST_TRIANGLE: {
-	    //immer eindeutig
-	    if( syn0->edge->get_triangle() == syn1->edge->get_triangle() )
-	    {
-		return IVP_TRUE;
-	    } else {
-		return IVP_FALSE;
-	    }
-	}
-    case IVP_ST_BALL: 
-	// objects are already checked !!
-	return IVP_TRUE;
-    case IVP_ST_EDGE: {
-	    //do not check side
-	    // note by OS: check for tmp.common would work too: but discussion for concav objects needed
-	if( syn0->edge == syn1->edge || syn0->edge->get_opposite() == syn1->edge)
-	{
-	    return IVP_TRUE;
-	} else {
-	    return IVP_FALSE;
-	}
-    }	    
-        default:
-	    CORE;
+    if (syn0->edge->get_start_point_index() !=
+        syn1->edge->get_start_point_index()) {
+      return IVP_FALSE;
     }
-    return IVP_FALSE;
+    return IVP_TRUE;
+  }
+  case IVP_ST_TRIANGLE: {
+    // immer eindeutig
+    if (syn0->edge->get_triangle() == syn1->edge->get_triangle()) {
+      return IVP_TRUE;
+    } else {
+      return IVP_FALSE;
+    }
+  }
+  case IVP_ST_BALL:
+    // objects are already checked !!
+    return IVP_TRUE;
+  case IVP_ST_EDGE: {
+    // do not check side
+    //  note by OS: check for tmp.common would work too: but discussion for
+    //  concav objects needed
+    if (syn0->edge == syn1->edge || syn0->edge->get_opposite() == syn1->edge) {
+      return IVP_TRUE;
+    } else {
+      return IVP_FALSE;
+    }
+  }
+  default:
+    CORE;
+  }
+  return IVP_FALSE;
 }
 
-IVP_BOOL IVP_Contact_Point::is_same_as(const IVP_Mindist *md2) const
-{
-    const IVP_Synapse_Friction *sy00 = this->get_synapse(0);
-    const IVP_Synapse_Friction *sy01 = this->get_synapse(1);
-    const IVP_Synapse_Real *sy10 =  md2->get_synapse(0);
-    const IVP_Synapse_Real *sy11 =  md2->get_synapse(1);
+IVP_BOOL IVP_Contact_Point::is_same_as(const IVP_Mindist *md2) const {
+  const IVP_Synapse_Friction *sy00 = this->get_synapse(0);
+  const IVP_Synapse_Friction *sy01 = this->get_synapse(1);
+  const IVP_Synapse_Real *sy10 = md2->get_synapse(0);
+  const IVP_Synapse_Real *sy11 = md2->get_synapse(1);
 
-    // check objects first
-    if ( sy00->l_obj == sy10->l_obj && sy01->l_obj == sy11->l_obj) {
-	if (sy00->is_same_as(sy10) && sy01->is_same_as(sy11)){
-	    return IVP_TRUE;
-	}
+  // check objects first
+  if (sy00->l_obj == sy10->l_obj && sy01->l_obj == sy11->l_obj) {
+    if (sy00->is_same_as(sy10) && sy01->is_same_as(sy11)) {
+      return IVP_TRUE;
     }
-    if ( sy01->l_obj == sy10->l_obj && sy00->l_obj == sy11->l_obj) {
-	if (sy01->is_same_as(sy10) && sy00->is_same_as(sy11)){
-	    return IVP_TRUE;
-	}
+  }
+  if (sy01->l_obj == sy10->l_obj && sy00->l_obj == sy11->l_obj) {
+    if (sy01->is_same_as(sy10) && sy00->is_same_as(sy11)) {
+      return IVP_TRUE;
     }
-    return IVP_FALSE;
+  }
+  return IVP_FALSE;
 }
 
-void IVP_Friction_Sys_Static::core_is_going_to_be_deleted_event(IVP_Core *del_core) {
-    IVP_ASSERT(!del_core->physical_unmoveable);
-    IVP_ASSERT(del_core->environment->state==IVP_ES_AT);
+void IVP_Friction_Sys_Static::core_is_going_to_be_deleted_event(
+    IVP_Core *del_core) {
+  IVP_ASSERT(!del_core->physical_unmoveable);
+  IVP_ASSERT(del_core->environment->state == IVP_ES_AT);
 
-    IVP_Friction_Core_Pair *my_pair;
-    int j;
-    for(j=l_friction_system->fr_pairs_of_objs.len()-1;j>=0;j--) {
-        my_pair=l_friction_system->fr_pairs_of_objs.element_at(j);
-	if((my_pair->objs[0]==del_core)||(my_pair->objs[1]==del_core)) {
-	    int k;
-	    for(k=my_pair->fr_dists.len()-1;k>=0;k--) {
-	        IVP_Contact_Point *fr_mindist=my_pair->fr_dists.element_at(k);
-		this->l_friction_system->delete_friction_distance(fr_mindist);
-	    }
-	    //my_pair is now deleted!!!
-	}
+  IVP_Friction_Core_Pair *my_pair;
+  int j;
+  for (j = l_friction_system->fr_pairs_of_objs.len() - 1; j >= 0; j--) {
+    my_pair = l_friction_system->fr_pairs_of_objs.element_at(j);
+    if ((my_pair->objs[0] == del_core) || (my_pair->objs[1] == del_core)) {
+      int k;
+      for (k = my_pair->fr_dists.len() - 1; k >= 0; k--) {
+        IVP_Contact_Point *fr_mindist = my_pair->fr_dists.element_at(k);
+        this->l_friction_system->delete_friction_distance(fr_mindist);
+      }
+      // my_pair is now deleted!!!
     }
-    
-    IVP_Friction_System *fs=this->l_friction_system;
-    if(fs->friction_dist_number==0) {
-      P_DELETE(fs);
-    }
+  }
+
+  IVP_Friction_System *fs = this->l_friction_system;
+  if (fs->friction_dist_number == 0) {
+    P_DELETE(fs);
+  }
 }
--- source-engine-base/ivp/ivp_intern/ivp_sim_unit.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_intern/ivp_sim_unit.cxx	2025-11-26 18:47:32
@@ -5,6 +5,7 @@
 #if !defined(WIN32) && !defined(PSXII) && !defined(GEKKO) && !defined(PLATFORM_BSD)
 #	include <alloca.h>
 #endif
+#include <stdlib.h>
 
 #ifndef WIN32
 #	pragma implementation "ivp_sim_unit.hxx"
--- source-engine-base/ivp/ivp_compact_builder/geompack_drdec3.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/geompack_drdec3.cxx	2025-11-26 18:48:42
@@ -2,6 +2,7 @@
 */
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 
 #if !( (defined(__MWERKS__) && defined(__POWERPC__)) || defined(GEKKO) )
 #ifdef OSX
--- source-engine-base/ivp/ivp_compact_builder/ivp_surbuild_ledge_soup.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/ivp_surbuild_ledge_soup.cxx	2025-11-26 18:48:42
@@ -1,6 +1,7 @@
 // Copyright (C) Ipion Software GmbH 1999-2000. All rights reserved.
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 #include <string.h>
 
 //#define STATS
--- source-engine-base/ivp/ivp_compact_builder/qhull_user.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/qhull_user.cxx	2025-11-26 18:48:42
@@ -39,6 +39,7 @@
 */
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 #include "qhull_a.hxx" 
 
 /*-<a                             href="qh-c.htm#user"
--- source-engine-base/ivp/ivp_compact_builder/ivp_convex_decompositor.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/ivp_convex_decompositor.cxx	2025-11-26 18:48:42
@@ -2,6 +2,7 @@
 
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 #include <ivp_betterdebugmanager.hxx>
 
 #include <ivp_convex_decompositor.hxx>
--- source-engine-base/ivp/ivp_compact_builder/ivp_surbuild_pointsoup.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/ivp_surbuild_pointsoup.cxx	2025-11-26 18:48:42
@@ -2,6 +2,7 @@
 
 // IVP_EXPORT_PUBLIC
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 
 #include <qhull_a.hxx>
 
--- source-engine-base/ivp/ivp_compact_builder/qhull_mem.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/qhull_mem.cxx	2025-11-26 18:48:42
@@ -32,6 +32,7 @@
   copyright (c) 1993-1999 The Geometry Center
 */
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 
 #include <stdio.h>
 #include <stdlib.h>
--- source-engine-base/ivp/ivp_compact_builder/qhull_qset.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/qhull_qset.cxx	2025-11-26 18:48:42
@@ -10,6 +10,7 @@
 */
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 /*** uncomment here and qhull_a.h 
--- source-engine-base/ivp/ivp_compact_builder/qhull_geom.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/qhull_geom.cxx	2025-11-26 18:48:42
@@ -11,6 +11,7 @@
    infrequent code goes into geom2.c
 */
 #include <ivp_physics.hxx>
+#include <stdlib.h>
    
 #include "qhull_a.hxx"
    
--- source-engine-base/ivp/ivp_compact_builder/3dsimport_co.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/3dsimport_co.cxx	2025-11-26 18:48:42
@@ -5,6 +5,7 @@
 
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 #include <ctype.h>
 #ifndef WIN32
 #	pragma implementation "ivp_surbuild_3ds.hxx"
--- source-engine-base/ivp/ivp_compact_builder/qhull_stat.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/qhull_stat.cxx	2025-11-26 18:48:42
@@ -10,6 +10,7 @@
 */
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 #include "qhull_a.hxx"
 
 /*============ global data structure ==========*/
--- source-engine-base/ivp/ivp_compact_builder/qhull_merge.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/qhull_merge.cxx	2025-11-26 18:48:42
@@ -24,6 +24,7 @@
 */
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 #include "qhull_a.hxx"
 
 #ifndef qh_NOmerge
--- source-engine-base/ivp/ivp_compact_builder/qhull_io.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/qhull_io.cxx	2025-11-26 18:48:42
@@ -17,6 +17,7 @@
 */
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 #include "qhull_a.hxx"
 
 /*========= -prototypes for internal functions ========= */
--- source-engine-base/ivp/ivp_compact_builder/qhull_global.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/qhull_global.cxx	2025-11-26 18:48:42
@@ -14,6 +14,7 @@
  */
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 #include "qhull_a.hxx"
 
 /*========= qh definition =======================*/
--- source-engine-base/ivp/ivp_compact_builder/qhull.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/qhull.cxx	2025-11-26 18:48:42
@@ -14,6 +14,7 @@
 */
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 #include "qhull_a.hxx" 
 
 /*============= functions in alphabetic order after qhull() =======*/
--- source-engine-base/ivp/ivp_compact_builder/qhull_poly.cxx	2025-11-30 13:04:05
+++ source-engine-working/ivp/ivp_compact_builder/qhull_poly.cxx	2025-11-26 18:48:42
@@ -13,6 +13,7 @@
 */
 
 #include <ivp_physics.hxx>
+#include <stdlib.h>
 #include "qhull_a.hxx"
 
 /*======== functions in alphabetical order ==========*/
--- source-engine-base/public/tier1/utlblockmemory.h	2025-11-30 13:04:00
+++ source-engine-working/public/tier1/utlblockmemory.h	2025-11-26 18:45:39
@@ -1,6 +1,6 @@
 //========= Copyright Valve Corporation, All rights reserved. ============//
 //
-// Purpose: 
+// Purpose:
 //
 // $NoKeywords: $
 //
@@ -14,336 +14,330 @@
 #pragma once
 #endif
 
+#include "mathlib/mathlib.h"
 #include "tier0/dbg.h"
 #include "tier0/platform.h"
-#include "mathlib/mathlib.h"
 
 #include "tier0/memalloc.h"
 #include "tier0/memdbgon.h"
+#include <algorithm>
 
 #ifdef _WIN32
-#pragma warning (disable:4100)
-#pragma warning (disable:4514)
+#pragma warning(disable : 4100)
+#pragma warning(disable : 4514)
 #endif
 
 //-----------------------------------------------------------------------------
 
 #ifdef UTBLOCKLMEMORY_TRACK
-#define UTLBLOCKMEMORY_TRACK_ALLOC()		MemAlloc_RegisterAllocation( "Sum of all UtlBlockMemory", 0, NumAllocated() * sizeof(T), NumAllocated() * sizeof(T), 0 )
-#define UTLBLOCKMEMORY_TRACK_FREE()		if ( !m_pMemory ) ; else MemAlloc_RegisterDeallocation( "Sum of all UtlBlockMemory", 0, NumAllocated() * sizeof(T), NumAllocated() * sizeof(T), 0 )
+#define UTLBLOCKMEMORY_TRACK_ALLOC()                                           \
+  MemAlloc_RegisterAllocation("Sum of all UtlBlockMemory", 0,                  \
+                              NumAllocated() * sizeof(T),                      \
+                              NumAllocated() * sizeof(T), 0)
+#define UTLBLOCKMEMORY_TRACK_FREE()                                            \
+  if (!m_pMemory)                                                              \
+    ;                                                                          \
+  else                                                                         \
+    MemAlloc_RegisterDeallocation("Sum of all UtlBlockMemory", 0,              \
+                                  NumAllocated() * sizeof(T),                  \
+                                  NumAllocated() * sizeof(T), 0)
 #else
-#define UTLBLOCKMEMORY_TRACK_ALLOC()		((void)0)
-#define UTLBLOCKMEMORY_TRACK_FREE()		((void)0)
+#define UTLBLOCKMEMORY_TRACK_ALLOC() ((void)0)
+#define UTLBLOCKMEMORY_TRACK_FREE() ((void)0)
 #endif
 
-
 //-----------------------------------------------------------------------------
 // The CUtlBlockMemory class:
-// A growable memory class that allocates non-sequential blocks, but is indexed sequentially
+// A growable memory class that allocates non-sequential blocks, but is indexed
+// sequentially
 //-----------------------------------------------------------------------------
-template< class T, class I >
-class CUtlBlockMemory
-{
+template <class T, class I> class CUtlBlockMemory {
 public:
-	// constructor, destructor
-	CUtlBlockMemory( int nGrowSize = 0, int nInitSize = 0 );
-	~CUtlBlockMemory();
+  // constructor, destructor
+  CUtlBlockMemory(int nGrowSize = 0, int nInitSize = 0);
+  ~CUtlBlockMemory();
 
-	// Set the size by which the memory grows - round up to the next power of 2
-	void Init( int nGrowSize = 0, int nInitSize = 0 );
+  // Set the size by which the memory grows - round up to the next power of 2
+  void Init(int nGrowSize = 0, int nInitSize = 0);
 
-	// here to match CUtlMemory, but only used by ResetDbgInfo, so it can just return NULL
-	T* Base() { return NULL; }
-	const T* Base() const { return NULL; }
+  // here to match CUtlMemory, but only used by ResetDbgInfo, so it can just
+  // return NULL
+  T *Base() { return NULL; }
+  const T *Base() const { return NULL; }
 
-	class Iterator_t
-	{
-	public:
-		Iterator_t( I i ) : index( i ) {}
-		I index;
+  class Iterator_t {
+  public:
+    Iterator_t(I i) : index(i) {}
+    I index;
 
-		bool operator==( const Iterator_t it ) const	{ return index == it.index; }
-		bool operator!=( const Iterator_t it ) const	{ return index != it.index; }
-	};
-	Iterator_t First() const							{ return Iterator_t( IsIdxValid( 0 ) ? 0 : InvalidIndex() ); }
-	Iterator_t Next( const Iterator_t &it ) const		{ return Iterator_t( IsIdxValid( it.index + 1 ) ? it.index + 1 : InvalidIndex() ); }
-	I GetIndex( const Iterator_t &it ) const			{ return it.index; }
-	bool IsIdxAfter( I i, const Iterator_t &it ) const	{ return i > it.index; }
-	bool IsValidIterator( const Iterator_t &it ) const	{ return IsIdxValid( it.index ); }
-	Iterator_t InvalidIterator() const					{ return Iterator_t( InvalidIndex() ); }
+    bool operator==(const Iterator_t it) const { return index == it.index; }
+    bool operator!=(const Iterator_t it) const { return index != it.index; }
+  };
+  Iterator_t First() const {
+    return Iterator_t(IsIdxValid(0) ? 0 : InvalidIndex());
+  }
+  Iterator_t Next(const Iterator_t &it) const {
+    return Iterator_t(IsIdxValid(it.index + 1) ? it.index + 1 : InvalidIndex());
+  }
+  I GetIndex(const Iterator_t &it) const { return it.index; }
+  bool IsIdxAfter(I i, const Iterator_t &it) const { return i > it.index; }
+  bool IsValidIterator(const Iterator_t &it) const {
+    return IsIdxValid(it.index);
+  }
+  Iterator_t InvalidIterator() const { return Iterator_t(InvalidIndex()); }
 
-	// element access
-	T& operator[]( I i );
-	const T& operator[]( I i ) const;
-	T& Element( I i );
-	const T& Element( I i ) const;
+  // element access
+  T &operator[](I i);
+  const T &operator[](I i) const;
+  T &Element(I i);
+  const T &Element(I i) const;
 
-	// Can we use this index?
-	bool IsIdxValid( I i ) const;
-	static I InvalidIndex() { return ( I )-1; }
+  // Can we use this index?
+  bool IsIdxValid(I i) const;
+  static I InvalidIndex() { return (I)-1; }
 
-	void Swap( CUtlBlockMemory< T, I > &mem );
+  void Swap(CUtlBlockMemory<T, I> &mem);
 
-	// Size
-	int NumAllocated() const;
-	int Count() const { return NumAllocated(); }
+  // Size
+  int NumAllocated() const;
+  int Count() const { return NumAllocated(); }
 
-	// Grows memory by max(num,growsize) rounded up to the next power of 2, and returns the allocation index/ptr
-	void Grow( int num = 1 );
+  // Grows memory by max(num,growsize) rounded up to the next power of 2, and
+  // returns the allocation index/ptr
+  void Grow(int num = 1);
 
-	// Makes sure we've got at least this much memory
-	void EnsureCapacity( int num );
+  // Makes sure we've got at least this much memory
+  void EnsureCapacity(int num);
 
-	// Memory deallocation
-	void Purge();
+  // Memory deallocation
+  void Purge();
 
-	// Purge all but the given number of elements
-	void Purge( int numElements );
+  // Purge all but the given number of elements
+  void Purge(int numElements);
 
 protected:
-	int Index( int major, int minor ) const { return ( major << m_nIndexShift ) | minor; }
-	int MajorIndex( int i ) const { return i >> m_nIndexShift; }
-	int MinorIndex( int i ) const { return i & m_nIndexMask; }
-	void ChangeSize( int nBlocks );
-	int NumElementsInBlock() const { return m_nIndexMask + 1; }
+  int Index(int major, int minor) const {
+    return (major << m_nIndexShift) | minor;
+  }
+  int MajorIndex(int i) const { return i >> m_nIndexShift; }
+  int MinorIndex(int i) const { return i & m_nIndexMask; }
+  void ChangeSize(int nBlocks);
+  int NumElementsInBlock() const { return m_nIndexMask + 1; }
 
-	T** m_pMemory;
-	int m_nBlocks;
-	int m_nIndexMask;
-	int m_nIndexShift;
+  T **m_pMemory;
+  int m_nBlocks;
+  int m_nIndexMask;
+  int m_nIndexShift;
 };
 
 //-----------------------------------------------------------------------------
 // constructor, destructor
 //-----------------------------------------------------------------------------
 
-template< class T, class I >
-CUtlBlockMemory<T,I>::CUtlBlockMemory( int nGrowSize, int nInitAllocationCount )
-: m_pMemory( 0 ), m_nBlocks( 0 ), m_nIndexMask( 0 ), m_nIndexShift( 0 )
-{
-	Init( nGrowSize, nInitAllocationCount );
+template <class T, class I>
+CUtlBlockMemory<T, I>::CUtlBlockMemory(int nGrowSize, int nInitAllocationCount)
+    : m_pMemory(0), m_nBlocks(0), m_nIndexMask(0), m_nIndexShift(0) {
+  Init(nGrowSize, nInitAllocationCount);
 }
 
-template< class T, class I >
-CUtlBlockMemory<T,I>::~CUtlBlockMemory()
-{
-	Purge();
+template <class T, class I> CUtlBlockMemory<T, I>::~CUtlBlockMemory() {
+  Purge();
 }
 
 //-----------------------------------------------------------------------------
 // Fast swap
 //-----------------------------------------------------------------------------
-template< class T, class I >
-void CUtlBlockMemory<T,I>::Swap( CUtlBlockMemory< T, I > &mem )
-{
-	V_swap( m_pMemory, mem.m_pMemory );
-	V_swap( m_nBlocks, mem.m_nBlocks );
-	V_swap( m_nIndexMask, mem.m_nIndexMask );
-	V_swap( m_nIndexShift, mem.m_nIndexShift );
-}
+template <class T, class I>
+void CUtlBlockMemory<T, I>::Swap(CUtlBlockMemory<T, I> &mem) {
+  std::swap(m_pMemory, mem.m_pMemory);
+  std::swap(m_nBlocks, mem.m_nBlocks);
 
+  // Handle bit-fields manually since std::swap cannot take references to
+  // bit-fields
+  int tempMask = m_nIndexMask;
+  m_nIndexMask = mem.m_nIndexMask;
+  mem.m_nIndexMask = tempMask;
 
+  int tempShift = m_nIndexShift;
+  m_nIndexShift = mem.m_nIndexShift;
+  mem.m_nIndexShift = tempShift;
+}
+
 //-----------------------------------------------------------------------------
 // Set the size by which the memory grows - round up to the next power of 2
 //-----------------------------------------------------------------------------
-template< class T, class I >
-void CUtlBlockMemory<T,I>::Init( int nGrowSize /* = 0 */, int nInitSize /* = 0 */ )
-{
-	Purge();
+template <class T, class I>
+void CUtlBlockMemory<T, I>::Init(int nGrowSize /* = 0 */,
+                                 int nInitSize /* = 0 */) {
+  Purge();
 
-	if ( nGrowSize == 0)
-	{
-		// default grow size is smallest size s.t. c++ allocation overhead is ~6% of block size
-		nGrowSize = ( 127 + sizeof( T ) ) / sizeof( T );
-	}
-	nGrowSize = SmallestPowerOfTwoGreaterOrEqual( nGrowSize );
-	m_nIndexMask = nGrowSize - 1;
+  if (nGrowSize == 0) {
+    // default grow size is smallest size s.t. c++ allocation overhead is ~6% of
+    // block size
+    nGrowSize = (127 + sizeof(T)) / sizeof(T);
+  }
+  nGrowSize = SmallestPowerOfTwoGreaterOrEqual(nGrowSize);
+  m_nIndexMask = nGrowSize - 1;
 
-	m_nIndexShift = 0;
-	while ( nGrowSize > 1 )
-	{
-		nGrowSize >>= 1;
-		++m_nIndexShift;
-	}
-	Assert( m_nIndexMask + 1 == ( 1 << m_nIndexShift ) );
+  m_nIndexShift = 0;
+  while (nGrowSize > 1) {
+    nGrowSize >>= 1;
+    ++m_nIndexShift;
+  }
+  Assert(m_nIndexMask + 1 == (1 << m_nIndexShift));
 
-	Grow( nInitSize );
+  Grow(nInitSize);
 }
 
-
 //-----------------------------------------------------------------------------
 // element access
 //-----------------------------------------------------------------------------
-template< class T, class I >
-inline T& CUtlBlockMemory<T,I>::operator[]( I i )
-{
-	Assert( IsIdxValid(i) );
-	T *pBlock = m_pMemory[ MajorIndex( i ) ];
-	return pBlock[ MinorIndex( i ) ];
+template <class T, class I> inline T &CUtlBlockMemory<T, I>::operator[](I i) {
+  Assert(IsIdxValid(i));
+  T *pBlock = m_pMemory[MajorIndex(i)];
+  return pBlock[MinorIndex(i)];
 }
 
-template< class T, class I >
-inline const T& CUtlBlockMemory<T,I>::operator[]( I i ) const
-{
-	Assert( IsIdxValid(i) );
-	const T *pBlock = m_pMemory[ MajorIndex( i ) ];
-	return pBlock[ MinorIndex( i ) ];
+template <class T, class I>
+inline const T &CUtlBlockMemory<T, I>::operator[](I i) const {
+  Assert(IsIdxValid(i));
+  const T *pBlock = m_pMemory[MajorIndex(i)];
+  return pBlock[MinorIndex(i)];
 }
 
-template< class T, class I >
-inline T& CUtlBlockMemory<T,I>::Element( I i )
-{
-	Assert( IsIdxValid(i) );
-	T *pBlock = m_pMemory[ MajorIndex( i ) ];
-	return pBlock[ MinorIndex( i ) ];
+template <class T, class I> inline T &CUtlBlockMemory<T, I>::Element(I i) {
+  Assert(IsIdxValid(i));
+  T *pBlock = m_pMemory[MajorIndex(i)];
+  return pBlock[MinorIndex(i)];
 }
 
-template< class T, class I >
-inline const T& CUtlBlockMemory<T,I>::Element( I i ) const
-{
-	Assert( IsIdxValid(i) );
-	const T *pBlock = m_pMemory[ MajorIndex( i ) ];
-	return pBlock[ MinorIndex( i ) ];
+template <class T, class I>
+inline const T &CUtlBlockMemory<T, I>::Element(I i) const {
+  Assert(IsIdxValid(i));
+  const T *pBlock = m_pMemory[MajorIndex(i)];
+  return pBlock[MinorIndex(i)];
 }
 
-
 //-----------------------------------------------------------------------------
 // Size
 //-----------------------------------------------------------------------------
-template< class T, class I >
-inline int CUtlBlockMemory<T,I>::NumAllocated() const
-{
-	return m_nBlocks * NumElementsInBlock();
+template <class T, class I>
+inline int CUtlBlockMemory<T, I>::NumAllocated() const {
+  return m_nBlocks * NumElementsInBlock();
 }
 
-
 //-----------------------------------------------------------------------------
 // Is element index valid?
 //-----------------------------------------------------------------------------
-template< class T, class I >
-inline bool CUtlBlockMemory<T,I>::IsIdxValid( I i ) const
-{
-	return ( i >= 0 ) && ( MajorIndex( i ) < m_nBlocks );
+template <class T, class I>
+inline bool CUtlBlockMemory<T, I>::IsIdxValid(I i) const {
+  return (i >= 0) && (MajorIndex(i) < m_nBlocks);
 }
 
-template< class T, class I >
-void CUtlBlockMemory<T,I>::Grow( int num )
-{
-	if ( num <= 0 )
-		return;
+template <class T, class I> void CUtlBlockMemory<T, I>::Grow(int num) {
+  if (num <= 0)
+    return;
 
-	int nBlockSize = NumElementsInBlock();
-	int nBlocks = ( num + nBlockSize - 1 ) / nBlockSize;
+  int nBlockSize = NumElementsInBlock();
+  int nBlocks = (num + nBlockSize - 1) / nBlockSize;
 
-	ChangeSize( m_nBlocks + nBlocks );
+  ChangeSize(m_nBlocks + nBlocks);
 }
 
-template< class T, class I >
-void CUtlBlockMemory<T,I>::ChangeSize( int nBlocks )
-{
-	UTLBLOCKMEMORY_TRACK_FREE(); // this must stay before the recalculation of m_nBlocks, since it implicitly uses the old value
+template <class T, class I>
+void CUtlBlockMemory<T, I>::ChangeSize(int nBlocks) {
+  UTLBLOCKMEMORY_TRACK_FREE(); // this must stay before the recalculation of
+                               // m_nBlocks, since it implicitly uses the old
+                               // value
 
-	int nBlocksOld = m_nBlocks;
-	m_nBlocks = nBlocks;
+  int nBlocksOld = m_nBlocks;
+  m_nBlocks = nBlocks;
 
-	UTLBLOCKMEMORY_TRACK_ALLOC(); // this must stay after the recalculation of m_nBlocks, since it implicitly uses the new value
+  UTLBLOCKMEMORY_TRACK_ALLOC(); // this must stay after the recalculation of
+                                // m_nBlocks, since it implicitly uses the new
+                                // value
 
-	if ( m_pMemory )
-	{
-		// free old blocks if shrinking
-		// Only possible if m_pMemory is non-NULL (and avoids PVS-Studio warning)
-		for ( int i = m_nBlocks; i < nBlocksOld; ++i )
-		{
-			UTLBLOCKMEMORY_TRACK_FREE();
-			free( (void*)m_pMemory[ i ] );
-		}
+  if (m_pMemory) {
+    // free old blocks if shrinking
+    // Only possible if m_pMemory is non-NULL (and avoids PVS-Studio warning)
+    for (int i = m_nBlocks; i < nBlocksOld; ++i) {
+      UTLBLOCKMEMORY_TRACK_FREE();
+      free((void *)m_pMemory[i]);
+    }
 
-		MEM_ALLOC_CREDIT_CLASS();
-		m_pMemory = (T**)realloc( m_pMemory, m_nBlocks * sizeof(T*) );
-		Assert( m_pMemory );
-	}
-	else
-	{
-		MEM_ALLOC_CREDIT_CLASS();
-		m_pMemory = (T**)malloc( m_nBlocks * sizeof(T*) );
-		Assert( m_pMemory );
-	}
+    MEM_ALLOC_CREDIT_CLASS();
+    m_pMemory = (T **)realloc(m_pMemory, m_nBlocks * sizeof(T *));
+    Assert(m_pMemory);
+  } else {
+    MEM_ALLOC_CREDIT_CLASS();
+    m_pMemory = (T **)malloc(m_nBlocks * sizeof(T *));
+    Assert(m_pMemory);
+  }
 
-	if ( !m_pMemory )
-	{
-		Error( "CUtlBlockMemory overflow!\n" );
-	}
+  if (!m_pMemory) {
+    Error("CUtlBlockMemory overflow!\n");
+  }
 
-	// allocate new blocks if growing
-	int nBlockSize = NumElementsInBlock();
-	for ( int i = nBlocksOld; i < m_nBlocks; ++i )
-	{
-		MEM_ALLOC_CREDIT_CLASS();
-		m_pMemory[ i ] = (T*)malloc( nBlockSize * sizeof( T ) );
-		Assert( m_pMemory[ i ] );
-	}
+  // allocate new blocks if growing
+  int nBlockSize = NumElementsInBlock();
+  for (int i = nBlocksOld; i < m_nBlocks; ++i) {
+    MEM_ALLOC_CREDIT_CLASS();
+    m_pMemory[i] = (T *)malloc(nBlockSize * sizeof(T));
+    Assert(m_pMemory[i]);
+  }
 }
 
-
 //-----------------------------------------------------------------------------
 // Makes sure we've got at least this much memory
 //-----------------------------------------------------------------------------
-template< class T, class I >
-inline void CUtlBlockMemory<T,I>::EnsureCapacity( int num )
-{
-	Grow( num - NumAllocated() );
+template <class T, class I>
+inline void CUtlBlockMemory<T, I>::EnsureCapacity(int num) {
+  Grow(num - NumAllocated());
 }
 
-
 //-----------------------------------------------------------------------------
 // Memory deallocation
 //-----------------------------------------------------------------------------
-template< class T, class I >
-void CUtlBlockMemory<T,I>::Purge()
-{
-	if ( !m_pMemory )
-		return;
+template <class T, class I> void CUtlBlockMemory<T, I>::Purge() {
+  if (!m_pMemory)
+    return;
 
-	for ( int i = 0; i < m_nBlocks; ++i )
-	{
-		UTLBLOCKMEMORY_TRACK_FREE();
-		free( (void*)m_pMemory[ i ] );
-	}
-	m_nBlocks = 0;
+  for (int i = 0; i < m_nBlocks; ++i) {
+    UTLBLOCKMEMORY_TRACK_FREE();
+    free((void *)m_pMemory[i]);
+  }
+  m_nBlocks = 0;
 
-	UTLBLOCKMEMORY_TRACK_FREE();
-	free( (void*)m_pMemory );
-	m_pMemory = 0;
+  UTLBLOCKMEMORY_TRACK_FREE();
+  free((void *)m_pMemory);
+  m_pMemory = 0;
 }
 
-template< class T, class I >
-void CUtlBlockMemory<T,I>::Purge( int numElements )
-{
-	Assert( numElements >= 0 );
+template <class T, class I> void CUtlBlockMemory<T, I>::Purge(int numElements) {
+  Assert(numElements >= 0);
 
-	int nAllocated = NumAllocated();
-	if ( numElements > nAllocated )
-	{
-		// Ensure this isn't a grow request in disguise.
-		Assert( numElements <= nAllocated );
-		return;
-	}
+  int nAllocated = NumAllocated();
+  if (numElements > nAllocated) {
+    // Ensure this isn't a grow request in disguise.
+    Assert(numElements <= nAllocated);
+    return;
+  }
 
-	if ( numElements <= 0 )
-	{
-		Purge();
-		return;
-	}
+  if (numElements <= 0) {
+    Purge();
+    return;
+  }
 
-	int nBlockSize = NumElementsInBlock();
-	int nBlocksOld = m_nBlocks;
-	int nBlocks = ( numElements + nBlockSize - 1 ) / nBlockSize;
+  int nBlockSize = NumElementsInBlock();
+  int nBlocksOld = m_nBlocks;
+  int nBlocks = (numElements + nBlockSize - 1) / nBlockSize;
 
-	// If the number of blocks is the same as the allocated number of blocks, we are done.
-	if ( nBlocks == m_nBlocks )
-		return;
+  // If the number of blocks is the same as the allocated number of blocks, we
+  // are done.
+  if (nBlocks == m_nBlocks)
+    return;
 
-	ChangeSize( nBlocks );
+  ChangeSize(nBlocks);
 }
 
 #include "tier0/memdbgoff.h"
--- source-engine-base/public/datamodel/dmattributevar.h	2025-11-30 13:04:00
+++ source-engine-working/public/datamodel/dmattributevar.h	2025-11-26 18:46:00
@@ -1,6 +1,6 @@
 //========= Copyright Valve Corporation, All rights reserved. ============//
 //
-// Purpose: 
+// Purpose:
 //
 //=============================================================================
 
@@ -10,1109 +10,1006 @@
 #pragma once
 #endif
 
-#include "tier1/utlvector.h"
 #include "Color.h"
-#include "mathlib/vector2d.h"
+#include "datamodel/dmattribute.h"
+#include "datamodel/dmelement.h"
 #include "mathlib/vector.h"
+#include "mathlib/vector2d.h"
 #include "mathlib/vector4d.h"
 #include "mathlib/vmatrix.h"
-#include "datamodel/dmelement.h"
-#include "datamodel/dmattribute.h"
+#include "tier1/utlvector.h"
 
-template< class C, bool D > class CDmeHandle;
+template <class C, bool D> class CDmeHandle;
 
 //-----------------------------------------------------------------------------
 // Specialization for color
 //-----------------------------------------------------------------------------
-class CDmaColor : public CDmaVar< Color >
-{
+class CDmaColor : public CDmaVar<Color> {
 public:
-	// Set methods
-	void SetColor( int r, int g, int b, int a = 0 );
-	void SetRed( int r );
-	void SetGreen( int g );
-	void SetBlue( int b );
-	void SetAlpha( int a );
+  // Set methods
+  void SetColor(int r, int g, int b, int a = 0);
+  void SetRed(int r);
+  void SetGreen(int g);
+  void SetBlue(int b);
+  void SetAlpha(int a);
 
-	// Sets the color as a 32-bit integer
-	void SetRawColor( int color );
+  // Sets the color as a 32-bit integer
+  void SetRawColor(int color);
 
-	// Get methods
-	unsigned char r() const;
-	unsigned char g() const;
-	unsigned char b() const;
-	unsigned char a() const;
-	const unsigned char &operator[]( int index ) const;
+  // Get methods
+  unsigned char r() const;
+  unsigned char g() const;
+  unsigned char b() const;
+  unsigned char a() const;
+  const unsigned char &operator[](int index) const;
 };
 
-
 //-----------------------------------------------------------------------------
 // Specialization for object ids
 //-----------------------------------------------------------------------------
-class CDmaObjectId : public CDmaVar< DmObjectId_t >
-{
+class CDmaObjectId : public CDmaVar<DmObjectId_t> {
 public:
-	void CreateObjectId( );
-	void Invalidate( );
-	bool IsValid( ) const;
-	bool IsEqual( const DmObjectId_t &id ) const;
-	const DmObjectId_t &operator=( const DmObjectId_t& src );
-	const CDmaObjectId& operator=( const CDmaObjectId& src );
-	const DmObjectId_t& Set( const DmObjectId_t &src );
+  void CreateObjectId();
+  void Invalidate();
+  bool IsValid() const;
+  bool IsEqual(const DmObjectId_t &id) const;
+  const DmObjectId_t &operator=(const DmObjectId_t &src);
+  const CDmaObjectId &operator=(const CDmaObjectId &src);
+  const DmObjectId_t &Set(const DmObjectId_t &src);
 };
 
-
 //-----------------------------------------------------------------------------
 // Specialization for binary block
 //-----------------------------------------------------------------------------
-class CDmaBinaryBlock : public CDmaVar< CUtlBinaryBlock >
-{
+class CDmaBinaryBlock : public CDmaVar<CUtlBinaryBlock> {
 public:
-	void Get( void *pValue, int nMaxLen ) const;
-	void Set( const void *pValue, int nLen );
-	const void *Get() const;
-	const unsigned char& operator[]( int i ) const;
+  void Get(void *pValue, int nMaxLen) const;
+  void Set(const void *pValue, int nLen);
+  const void *Get() const;
+  const unsigned char &operator[](int i) const;
 
-	// Returns buffer length
-	int	Length() const;
+  // Returns buffer length
+  int Length() const;
 };
 
-
 //-----------------------------------------------------------------------------
 // Specialization for elements
 //-----------------------------------------------------------------------------
-template <class T>
-class CDmaElement : public CDmaVar< DmElementHandle_t >
-{
-	typedef CDmaVar< DmElementHandle_t > BaseClass;
+template <class T> class CDmaElement : public CDmaVar<DmElementHandle_t> {
+  typedef CDmaVar<DmElementHandle_t> BaseClass;
 
 public:
-	// Used to initialize the attribute in an element's OnConstruction method
-	void InitAndCreate( CDmElement *pOwner, const char *pAttributeName, const char *pElementName = NULL, int flags = 0 );
-	void Init( CDmElement *pOwner, const char *pAttributeName, int flags = 0 );
+  // Used to initialize the attribute in an element's OnConstruction method
+  void InitAndCreate(CDmElement *pOwner, const char *pAttributeName,
+                     const char *pElementName = NULL, int flags = 0);
+  void Init(CDmElement *pOwner, const char *pAttributeName, int flags = 0);
 
-	// Returns the type of elements allowed into this attribute. UTL_INVAL_SYMBOL allows everything.
-	//UtlSymId_t GetElementType() const;
+  // Returns the type of elements allowed into this attribute. UTL_INVAL_SYMBOL
+  // allows everything.
+  UtlSymId_t GetElementType() const;
 
-	// Get/set
-	void Set( T* pElement );
-	T* GetElement() const;
+  // Get/set
+  void Set(T *pElement);
+  T *GetElement() const;
 
-	// Cast
-	T* operator->() const;
-	operator T*() const;
+  // Cast
+  T *operator->() const;
+  operator T *() const;
 
-	// NULL check
-	bool operator!() const;
+  // NULL check
+  bool operator!() const;
 
-	// Assignment.. wish I knew how to un-inline these methods
-	template <class S> CDmaElement<T> &operator=( S* pElement )
-	{
-		Set( static_cast<T*>( pElement ) );
-		return *this;
-	}
+  // Assignment.. wish I knew how to un-inline these methods
+  template <class S> CDmaElement<T> &operator=(S *pElement) {
+    Set(static_cast<T *>(pElement));
+    return *this;
+  }
 
-	template <class S> CDmaElement<T> &operator=( const CDmaElement<S>& src )
-	{
-		Set( static_cast<T*>( src.Get() ) );
-		return *this;
-	}
+  template <class S> CDmaElement<T> &operator=(const CDmaElement<S> &src) {
+    Set(static_cast<T *>(src.Get()));
+    return *this;
+  }
 
-	template <class S> bool operator==( const CDmaElement<S>& src )	const
-	{
-		return Value() == src.Value();
-	}
+  template <class S> bool operator==(const CDmaElement<S> &src) const {
+    return Value() == src.Value();
+  }
 
-	template <class S> bool operator!=( const CDmaElement<S>& src )	const
-	{
-		return Value() != src.Value();
-	}
+  template <class S> bool operator!=(const CDmaElement<S> &src) const {
+    return Value() != src.Value();
+  }
 };
 
-
 //-----------------------------------------------------------------------------
 // Can access any array attribute, regardless of type
 // See below for type-specific array accessors which have more features
 //-----------------------------------------------------------------------------
-class CDmrGenericArrayConst
-{
+class CDmrGenericArrayConst {
 public:
-	CDmrGenericArrayConst( const CDmAttribute* pAttribute );
-	CDmrGenericArrayConst( const CDmElement *pElement, const char *pAttributeName );
+  CDmrGenericArrayConst(const CDmAttribute *pAttribute);
+  CDmrGenericArrayConst(const CDmElement *pElement, const char *pAttributeName);
 
-	// Array count
-	int			Count() const;
+  // Array count
+  int Count() const;
 
-	// Gets 
-	const void*	GetUntyped( int i ) const;
+  // Gets
+  const void *GetUntyped(int i) const;
 
-	// String conversion
-	const char* GetAsString( int i, char *pBuffer, size_t nBufLen ) const;
+  // String conversion
+  const char *GetAsString(int i, char *pBuffer, size_t nBufLen) const;
 
-	const CDmAttribute *GetAttribute() const;
-	bool IsValid() const;
+  const CDmAttribute *GetAttribute() const;
+  bool IsValid() const;
 
 protected:
-	CDmrGenericArrayConst();
-	void Init( const CDmAttribute *pAttribute );
-	void Init( const CDmElement *pElement, const char *pAttributeName );
+  CDmrGenericArrayConst();
+  void Init(const CDmAttribute *pAttribute);
+  void Init(const CDmElement *pElement, const char *pAttributeName);
 
-	CDmAttribute *m_pAttribute;
+  CDmAttribute *m_pAttribute;
 };
 
-class CDmrGenericArray : public CDmrGenericArrayConst
-{
+class CDmrGenericArray : public CDmrGenericArrayConst {
 public:
-	CDmrGenericArray( CDmAttribute* pAttribute );
-	CDmrGenericArray( CDmElement *pElement, const char *pAttributeName );
+  CDmrGenericArray(CDmAttribute *pAttribute);
+  CDmrGenericArray(CDmElement *pElement, const char *pAttributeName);
 
-	void	EnsureCount( int num );
+  void EnsureCount(int num);
 
-	// Sets multiple elements at the same time
-	int		AddToTail();
-	void	Remove( int elem );		// preserves order, shifts elements
-	void	RemoveAll();				// doesn't deallocate memory
-	void	SetMultiple( int i, int nCount, DmAttributeType_t valueType, const void *pValue );
-	void	Set( int i, DmAttributeType_t valueType, const void *pValue );
+  // Sets multiple elements at the same time
+  int AddToTail();
+  void Remove(int elem); // preserves order, shifts elements
+  void RemoveAll();      // doesn't deallocate memory
+  void SetMultiple(int i, int nCount, DmAttributeType_t valueType,
+                   const void *pValue);
+  void Set(int i, DmAttributeType_t valueType, const void *pValue);
 
-	// String conversion
-	void SetFromString( int i, const char *pValue );
+  // String conversion
+  void SetFromString(int i, const char *pValue);
 
-	CDmAttribute *GetAttribute();
-	const CDmAttribute *GetAttribute() const;
+  CDmAttribute *GetAttribute();
+  const CDmAttribute *GetAttribute() const;
 };
 
-
 //-----------------------------------------------------------------------------
 // Helper template for external array attribute vars
 // NOTE: To use this class, don't use CDmaArrayBase directly. Instead, use
-//		CDmaArray<T> var;	<- Instantiate an array attribute var as a member of a element class
-//		CDmrArray<T> var;	<- Used to reference an existing array attribute + read/modify it
-//		CDmrArrayConst<T> var;	<- Used to reference an existing array attribute + read it (no modify)
+//		CDmaArray<T> var;	<- Instantiate an array attribute var as
+//a member of a element class 		CDmrArray<T> var;	<- Used to reference an existing
+//array attribute + read/modify it 		CDmrArrayConst<T> var;	<- Used to
+//reference an existing array attribute + read it (no modify)
 //
-// Also, there is a CDmaStringArray/CDmrStringArray/CDmrStringArrayConst for strings
-// and a CDmaElementArray/CDmrElementArray/CDmrElementArrayConst for elements
+// Also, there is a CDmaStringArray/CDmrStringArray/CDmrStringArrayConst for
+// strings and a CDmaElementArray/CDmrElementArray/CDmrElementArrayConst for
+// elements
 //-----------------------------------------------------------------------------
-template< class T, class B >
-class CDmaArrayConstBase : public B
-{
+template <class T, class B> class CDmaArrayConstBase : public B {
 public:
-	// Accessors
-	const CUtlVector<T> &Get() const;
-	const T *Base() const;
+  // Accessors
+  const CUtlVector<T> &Get() const;
+  const T *Base() const;
 
-	// Iteration
-	int		Count() const;
-	const T& operator[]( int i ) const;
-	const T& Element( int i ) const;
-	const T& Get( int i ) const;
-	const void*	GetUntyped( int i ) const;
-	bool	IsValidIndex( int i ) const;
-	int		InvalidIndex( void ) const;
+  // Iteration
+  int Count() const;
+  const T &operator[](int i) const;
+  const T &Element(int i) const;
+  const T &Get(int i) const;
+  const void *GetUntyped(int i) const;
+  bool IsValidIndex(int i) const;
+  int InvalidIndex(void) const;
 
-	// Search
-	int		Find( const T &value ) const;
+  // Search
+  int Find(const T &value) const;
 
-	// Attribute-related methods
-	const CDmAttribute *GetAttribute() const;
-	CDmElement *GetOwner();
-	bool IsDirty() const;
+  // Attribute-related methods
+  const CDmAttribute *GetAttribute() const;
+  CDmElement *GetOwner();
+  bool IsDirty() const;
 
 protected:
-	CDmaArrayConstBase( );
+  CDmaArrayConstBase();
 
-	CDmAttribute *m_pAttribute;
+  CDmAttribute *m_pAttribute;
 };
 
-template< class T, class B >
-class CDmaArrayBase : public CDmaArrayConstBase< T, B >
-{
-public:	
-	// Insertion
-	int		AddToTail();
-	int		InsertBefore( int elem );
-	int		AddToTail( const T& src );
-	int		InsertBefore( int elem, const T& src );
-	int		AddMultipleToTail( int num );
-	int		InsertMultipleBefore( int elem, int num );
-	void	EnsureCount( int num );
+template <class T, class B>
+class CDmaArrayBase : public CDmaArrayConstBase<T, B> {
+public:
+  // Insertion
+  int AddToTail();
+  int InsertBefore(int elem);
+  int AddToTail(const T &src);
+  int InsertBefore(int elem, const T &src);
+  int AddMultipleToTail(int num);
+  int InsertMultipleBefore(int elem, int num);
+  void EnsureCount(int num);
 
-	// Element Modification
-	void	Set( int i, const T& value );
-	void	SetMultiple( int i, int nCount, const T* pValue );
-	void	Swap( int i, int j );
-
-	// Copy related methods
-	void	CopyArray( const T *pArray, int size );
+  // Element Modification
+  void Set(int i, const T &value);
+  void SetMultiple(int i, int nCount, const T *pValue);
+  void Swap(int i, int j);
 
-	// this is basically just a faster version of CopyArray which uses pointer swap
-	// NOTE: This doesn't work for element arrays
-	void	SwapArray( CUtlVector< T > &array );
+  // Copy related methods
+  void CopyArray(const T *pArray, int size);
 
-	// Removal
-	void	FastRemove( int elem );
-	void	Remove( int elem );
-	void	RemoveMultiple( int elem, int num );
-	void	RemoveAll();
+  // this is basically just a faster version of CopyArray which uses pointer
+  // swap NOTE: This doesn't work for element arrays
+  void SwapArray(CUtlVector<T> &array);
 
-	// Memory management
-	void	EnsureCapacity( int num );
-	void	Purge();
+  // Removal
+  void FastRemove(int elem);
+  void Remove(int elem);
+  void RemoveMultiple(int elem, int num);
+  void RemoveAll();
 
-	// Attribute-related methods
-	CDmAttribute *GetAttribute();
-	const CDmAttribute *GetAttribute() const;
+  // Memory management
+  void EnsureCapacity(int num);
+  void Purge();
+
+  // Attribute-related methods
+  CDmAttribute *GetAttribute();
+  const CDmAttribute *GetAttribute() const;
 };
 
-
 //-----------------------------------------------------------------------------
 // Specialization for string arrays
 // NOTE: To use this class, don't use CDmaStringArrayBase directly. Instead, use
-//		CDmaStringArray var;	<- Instantiate an array attribute var as a member of a element class
-//		CDmrStringArray var;	<- Used to reference an existing array attribute + read/modify it
-//		CDmrStringArrayConst var; <- Used to reference an existing array attribute + read it (no modify)
+//		CDmaStringArray var;	<- Instantiate an array attribute var as
+//a member of a element class 		CDmrStringArray var;	<- Used to reference an
+//existing array attribute + read/modify it 		CDmrStringArrayConst var; <- Used to
+//reference an existing array attribute + read it (no modify)
 //-----------------------------------------------------------------------------
-template< class BaseClass >
-class CDmaStringArrayConstBase : public BaseClass
-{
+template <class BaseClass> class CDmaStringArrayConstBase : public BaseClass {
 public:
-	const char *operator[]( int i ) const;
-	const char *Element( int i ) const;
-	const char *Get( int i ) const;
-	const CUtlVector< CUtlString > &Get() const;
+  const char *operator[](int i) const;
+  const char *Element(int i) const;
+  const char *Get(int i) const;
+  const CUtlVector<CUtlString> &Get() const;
 
-	// Returns strlen of element i
-	int	Length( int i ) const;
+  // Returns strlen of element i
+  int Length(int i) const;
 };
 
-template< class B >
-class CDmaStringArrayBase : public CDmaStringArrayConstBase< CDmaArrayBase< CUtlString, B > >
-{
-	typedef CDmaStringArrayConstBase< CDmaArrayBase< CUtlString, B > > BaseClass;
+template <class B>
+class CDmaStringArrayBase
+    : public CDmaStringArrayConstBase<CDmaArrayBase<CUtlString, B>> {
+  typedef CDmaStringArrayConstBase<CDmaArrayBase<CUtlString, B>> BaseClass;
 
 public:
-	// Sets an element in the array
-	void Set( int i, const char * pValue );
+  // Sets an element in the array
+  void Set(int i, const char *pValue);
 
-	// Adds an element, uses copy constructor
-	int	AddToTail( const char *pValue );
-	int	InsertBefore( int elem, const char *pValue );
+  // Adds an element, uses copy constructor
+  int AddToTail(const char *pValue);
+  int InsertBefore(int elem, const char *pValue);
 };
 
-
 //-----------------------------------------------------------------------------
 // Specialization for elements
-// NOTE: To use this class, don't use CDmaElementArrayBase directly. Instead, use
-//		CDmaElementArray< element_type > var;	<- Instantiate an array attribute var as a member of a element class
-//		CDmrElementArray< element_type >  var;	<- Used to reference an existing array attribute + read/modify it
-//		CDmrElementArrayConst< element_type > var; <- Used to reference an existing array attribute + read it (no modify)
+// NOTE: To use this class, don't use CDmaElementArrayBase directly. Instead,
+// use
+//		CDmaElementArray< element_type > var;	<- Instantiate an array
+//attribute var as a member of a element class 		CDmrElementArray< element_type >
+//var;	<- Used to reference an existing array attribute + read/modify it
+//		CDmrElementArrayConst< element_type > var; <- Used to reference
+//an existing array attribute + read it (no modify)
 //-----------------------------------------------------------------------------
-template< class E, class BaseClass >
-class CDmaElementArrayConstBase : public BaseClass
-{
+template <class E, class BaseClass>
+class CDmaElementArrayConstBase : public BaseClass {
 public:
-	// Returns the element type
-	UtlSymId_t GetElementType() const;
+  // Returns the element type
+  UtlSymId_t GetElementType() const;
 
-	// Array access
-	E *operator[]( int i ) const;
-	E *Element( int i ) const;
-	E *Get( int i ) const;
-	const DmElementHandle_t& GetHandle( int i ) const;
-	const CUtlVector< DmElementHandle_t > &Get() const;
+  // Array access
+  E *operator[](int i) const;
+  E *Element(int i) const;
+  E *Get(int i) const;
+  const DmElementHandle_t &GetHandle(int i) const;
+  const CUtlVector<DmElementHandle_t> &Get() const;
 
-	// Search
-	int	Find( const E *pValue ) const;
-	int	Find( DmElementHandle_t h ) const;
+  // Search
+  int Find(const E *pValue) const;
+  int Find(DmElementHandle_t h) const;
 };
 
-template < class E, class B >
-class CDmaElementArrayBase : public CDmaElementArrayConstBase< E, CDmaArrayBase< DmElementHandle_t, B > >
-{
-	typedef CDmaElementArrayConstBase< E, CDmaArrayBase< DmElementHandle_t, B > > BaseClass;
+template <class E, class B>
+class CDmaElementArrayBase
+    : public CDmaElementArrayConstBase<E, CDmaArrayBase<DmElementHandle_t, B>> {
+  typedef CDmaElementArrayConstBase<E, CDmaArrayBase<DmElementHandle_t, B>>
+      BaseClass;
 
 public:
-	void SetHandle( int i, DmElementHandle_t h );
-	void Set( int i, E *pElement );
+  void SetHandle(int i, DmElementHandle_t h);
+  void Set(int i, E *pElement);
 
-	// Insertion
-	int	AddToTail( );
-	int	AddToTail( DmElementHandle_t src );
-	int	AddToTail( E *pValue );
-	int InsertBefore( int elem );
-	int	InsertBefore( int elem, DmElementHandle_t src );
-	int	InsertBefore( int elem, E *pValue );
+  // Insertion
+  int AddToTail();
+  int AddToTail(DmElementHandle_t src);
+  int AddToTail(E *pValue);
+  int InsertBefore(int elem);
+  int InsertBefore(int elem, DmElementHandle_t src);
+  int InsertBefore(int elem, E *pValue);
 
-	template< class C, bool D > int AddToTail( const CDmeHandle<C,D>& value )
-	{
-		return BaseClass::AddToTail( value.GetHandle() );
-	}
+  template <class C, bool D> int AddToTail(const CDmeHandle<C, D> &value) {
+    return BaseClass::AddToTail(value.GetHandle());
+  }
 
-	template< class C, bool D > int InsertBefore( int elem, const CDmeHandle<C,D>& value )
-	{
-		return BaseClass::InsertBefore( elem, value.GetHandle() );
-	}
+  template <class C, bool D>
+  int InsertBefore(int elem, const CDmeHandle<C, D> &value) {
+    return BaseClass::InsertBefore(elem, value.GetHandle());
+  }
 };
 
+// NOTE: The next couple classes are implementation details used to create
+// CDmrAray/CDmaArray
 
-// NOTE: The next couple classes are implementation details used to create CDmrAray/CDmaArray
-
 //-----------------------------------------------------------------------------
-// Base classes that contain data or refer to it; used for array accessor classes
+// Base classes that contain data or refer to it; used for array accessor
+// classes
 //-----------------------------------------------------------------------------
-template< typename T >
-class CDmaDataInternal
-{
+template <typename T> class CDmaDataInternal {
 protected:
-	typedef typename CDmAttributeInfo< T >::StorageType_t D;
+  typedef typename CDmAttributeInfo<T>::StorageType_t D;
 
-	const T& Value() const { return m_Storage; }
-	T& Value( ) { return m_Storage; }
-	const D& Data() const { return m_Storage; }
-	D& Data( ) { return m_Storage; }
+  const T &Value() const { return m_Storage; }
+  T &Value() { return m_Storage; }
+  const D &Data() const { return m_Storage; }
+  D &Data() { return m_Storage; }
+  const D &Storage() const { return m_Storage; }
+  D &Storage() { return m_Storage; }
 
 private:
-	D m_Storage;
+  D m_Storage;
 };
 
-template< typename T >
-class CDmaDataExternal
-{
+template <typename T> class CDmaDataExternal {
 protected:
-	typedef typename CDmAttributeInfo< T >::StorageType_t D;
+  typedef typename CDmAttributeInfo<T>::StorageType_t D;
 
-	CDmaDataExternal() : m_pStorage(0) {}
-	void Attach( void *pData ) { m_pStorage = (D*)pData; }
-	const T& Value() const { return *m_pStorage; }
-	T& Value( ) { return *m_pStorage; }
-	const D& Data() const { return *m_pStorage; }
-	D& Data( ) { return *m_pStorage; }
+  CDmaDataExternal() : m_pStorage(0) {}
+  void Attach(void *pData) { m_pStorage = (D *)pData; }
+  const T &Value() const { return *m_pStorage; }
+  T &Value() { return *m_pStorage; }
+  const D &Data() const { return *m_pStorage; }
+  D &Data() { return *m_pStorage; }
+  const D &Storage() const { return *m_pStorage; }
+  D &Storage() { return *m_pStorage; }
 
 private:
-	D* m_pStorage;
+  D *m_pStorage;
 };
 
-
 //-----------------------------------------------------------------------------
 // Versions for access, or for attribute vars
 //-----------------------------------------------------------------------------
-template< class T, class B >
-class CDmaDecorator : public B
-{
+template <class T, class B> class CDmaDecorator : public B {
 public:
-	void Init( CDmElement *pOwner, const char *pAttributeName, int flags = 0 );
+  void Init(CDmElement *pOwner, const char *pAttributeName, int flags = 0);
 };
 
-
-template< class T, class BaseClass >
-class CDmrDecoratorConst : public BaseClass
-{
+template <class T, class BaseClass>
+class CDmrDecoratorConst : public BaseClass {
 public:
-	void Init( const CDmAttribute* pAttribute );
-	void Init( const CDmElement *pElement, const char *pAttributeName );
+  void Init(const CDmAttribute *pAttribute);
+  void Init(const CDmElement *pElement, const char *pAttributeName);
 
-	bool IsValid() const;
+  bool IsValid() const;
 };
 
-template< class T, class BaseClass >
-class CDmrDecorator : public BaseClass
-{
+template <class T, class BaseClass> class CDmrDecorator : public BaseClass {
 public:
-	void Init( CDmAttribute* pAttribute );
-	void Init( CDmElement *pElement, const char *pAttributeName, bool bAddAttribute = false );
+  void Init(CDmAttribute *pAttribute);
+  void Init(CDmElement *pElement, const char *pAttributeName,
+            bool bAddAttribute = false);
 
-	bool IsValid() const;
+  bool IsValid() const;
 };
 
+#define DECLARE_ATTRIBUTE_ARRAY_VARIABLE(_className, _elementType)             \
+public:                                                                        \
+  _className() = default;
 
-#define DECLARE_ATTRIBUTE_ARRAY_VARIABLE( _className, _elementType )	\
-	public:																\
-		_className() = default;
+#define DECLARE_ATTRIBUTE_ARRAY_REFERENCE(_className, _elementType)            \
+public:                                                                        \
+  _className() = default;                                                      \
+  _className(CDmAttribute *pAttribute) { BaseClass::Init(pAttribute); }        \
+  _className(CDmElement *pElement, const char *pAttributeName,                 \
+             bool bAddAttribute = false) {                                     \
+    BaseClass::Init(pElement, pAttributeName, bAddAttribute);                  \
+  }                                                                            \
+  _className(CDmaArray<_className> &var) {                                     \
+    BaseClass::Init(var.GetAttribute());                                       \
+  }                                                                            \
+  _className(CDmrArray<_className> &var) {                                     \
+    BaseClass::Init(var.GetAttribute());                                       \
+  }
 
-#define DECLARE_ATTRIBUTE_ARRAY_REFERENCE( _className, _elementType )	\
-	public:																\
-		_className() = default;													\
-		_className( CDmAttribute* pAttribute ) { BaseClass::Init( pAttribute ); }	\
-		_className( CDmElement *pElement, const char *pAttributeName, bool bAddAttribute = false ) { BaseClass::Init( pElement, pAttributeName, bAddAttribute ); } \
-		_className( CDmaArray<_className>& var ) { BaseClass::Init( var.GetAttribute() ); } \
-		_className( CDmrArray<_className>& var ) { BaseClass::Init( var.GetAttribute() ); }
+#define DECLARE_ATTRIBUTE_ARRAY_CONST_REFERENCE(_className, _elementType)      \
+public:                                                                        \
+  _className() = default;                                                      \
+  _className(const CDmAttribute *pAttribute) { BaseClass::Init(pAttribute); }  \
+  _className(const CDmElement *pElement, const char *pAttributeName) {         \
+    BaseClass::Init(pElement, pAttributeName);                                 \
+  }                                                                            \
+  _className(const CDmaArray<_className> &var) {                               \
+    BaseClass::Init(var.GetAttribute());                                       \
+  }                                                                            \
+  _className(const CDmrArrayConst<_className> &var) {                          \
+    BaseClass::Init(var.GetAttribute());                                       \
+  }                                                                            \
+  _className(const CDmrArray<_className> &var) {                               \
+    BaseClass::Init(var.GetAttribute());                                       \
+  }
 
-#define DECLARE_ATTRIBUTE_ARRAY_CONST_REFERENCE( _className, _elementType )	\
-	public:																	\
-		_className() = default;														\
-		_className( const CDmAttribute* pAttribute ) { BaseClass::Init( pAttribute ); } \
-		_className( const CDmElement *pElement, const char *pAttributeName ) { BaseClass::Init( pElement, pAttributeName ); } \
-		_className( const CDmaArray<_className>& var ) { BaseClass::Init( var.GetAttribute() ); } \
-		_className( const CDmrArrayConst<_className>& var ) { BaseClass::Init( var.GetAttribute() ); } \
-		_className( const CDmrArray<_className>& var ) { BaseClass::Init( var.GetAttribute() ); }
+template <class T> class CDmrArray;
+template <class T> class CDmrArrayConst;
+template <class T> class CDmaArray;
 
-template<class T> class CDmrArray;
-template<class T> class CDmrArrayConst;
-template<class T> class CDmaArray;
-
 //-----------------------------------------------------------------------------
 // Versions for access, or for attribute vars
 //-----------------------------------------------------------------------------
-template<class T>
-class CDmaArray : public CDmaDecorator< T, CDmaArrayBase< T, CDmaDataInternal< CUtlVector< T > > > >
-{
-	DECLARE_ATTRIBUTE_ARRAY_VARIABLE( CDmaArray, T );
+template <class T>
+class CDmaArray
+    : public CDmaDecorator<T,
+                           CDmaArrayBase<T, CDmaDataInternal<CUtlVector<T>>>> {
+  DECLARE_ATTRIBUTE_ARRAY_VARIABLE(CDmaArray, T);
 
 public:
-	const CDmaArray<T>& operator=( const CDmaArray<T> &val ) 
-	{ 
-		CopyArray( val.Base(), val.Count() ); 
-		return *this; 
-	}
+  const CDmaArray<T> &operator=(const CDmaArray<T> &val) {
+    CopyArray(val.Base(), val.Count());
+    return *this;
+  }
 
-	template< class C > const CDmaArray<T>& operator=( const C &val ) 
-	{ 
-		CopyArray( val.Base(), val.Count() ); 
-		return *this; 
-	}
+  template <class C> const CDmaArray<T> &operator=(const C &val) {
+    CopyArray(val.Base(), val.Count());
+    return *this;
+  }
 
 private:
-	CDmaArray( const CDmaArray& array ) {}
+  CDmaArray(const CDmaArray &array) {}
 };
 
-
-template<class T>
-class CDmrArrayConst : public CDmrDecoratorConst< T, CDmaArrayConstBase< T, CDmaDataExternal< CUtlVector< T > > > >
-{
-	typedef CDmrDecoratorConst< T, CDmaArrayConstBase< T, CDmaDataExternal< CUtlVector< T > > > > BaseClass;
-	DECLARE_ATTRIBUTE_ARRAY_CONST_REFERENCE( CDmrArrayConst, T );
+template <class T>
+class CDmrArrayConst
+    : public CDmrDecoratorConst<
+          T, CDmaArrayConstBase<T, CDmaDataExternal<CUtlVector<T>>>> {
+  typedef CDmrDecoratorConst<
+      T, CDmaArrayConstBase<T, CDmaDataExternal<CUtlVector<T>>>>
+      BaseClass;
+  DECLARE_ATTRIBUTE_ARRAY_CONST_REFERENCE(CDmrArrayConst, T);
 };
 
+template <class T>
+class CDmrArray
+    : public CDmrDecorator<T,
+                           CDmaArrayBase<T, CDmaDataExternal<CUtlVector<T>>>> {
+  typedef CDmrDecorator<T, CDmaArrayBase<T, CDmaDataExternal<CUtlVector<T>>>>
+      BaseClass;
+  DECLARE_ATTRIBUTE_ARRAY_REFERENCE(CDmrArray, T);
 
-template<class T>
-class CDmrArray : public CDmrDecorator< T, CDmaArrayBase< T, CDmaDataExternal< CUtlVector< T > > > >
-{
-	typedef CDmrDecorator< T, CDmaArrayBase< T, CDmaDataExternal< CUtlVector< T > > > > BaseClass;
-	DECLARE_ATTRIBUTE_ARRAY_REFERENCE( CDmrArray, T );
-
 public:
-	const CDmrArray<T>& operator=( const CDmrArray<T> &val ) 
-	{ 
-		CopyArray( val.Base(), val.Count() ); 
-		return *this; 
-	}
+  const CDmrArray<T> &operator=(const CDmrArray<T> &val) {
+    CopyArray(val.Base(), val.Count());
+    return *this;
+  }
 
-	template< class C > const CDmrArray<T>& operator=( const C &val ) 
-	{ 
-		CopyArray( val.Base(), val.Count() ); 
-		return *this; 
-	}
+  template <class C> const CDmrArray<T> &operator=(const C &val) {
+    CopyArray(val.Base(), val.Count());
+    return *this;
+  }
 };
 
 class CDmrStringArray;
 
-class CDmaStringArray : public CDmaDecorator< CUtlString, CDmaStringArrayBase< CDmaDataInternal< CUtlVector< CUtlString > > > >
-{
-	DECLARE_ATTRIBUTE_ARRAY_VARIABLE( CDmaStringArray, CUtlString );
+class CDmaStringArray
+    : public CDmaDecorator<
+          CUtlString,
+          CDmaStringArrayBase<CDmaDataInternal<CUtlVector<CUtlString>>>> {
+  DECLARE_ATTRIBUTE_ARRAY_VARIABLE(CDmaStringArray, CUtlString);
 
 public:
-	const CDmaStringArray& operator=( const CDmaStringArray &val ) 
-	{ 
-		CopyArray( val.Base(), val.Count() ); 
-		return *this; 
-	}
+  const CDmaStringArray &operator=(const CDmaStringArray &val) {
+    CopyArray(val.Base(), val.Count());
+    return *this;
+  }
 
-	template< class C > const CDmaStringArray& operator=( const C &val ) 
-	{ 
-		CopyArray( val.Base(), val.Count() ); 
-		return *this; 
-	}
+  template <class C> const CDmaStringArray &operator=(const C &val) {
+    CopyArray(val.Base(), val.Count());
+    return *this;
+  }
 
 private:
-	CDmaStringArray( const CDmaStringArray& array ) {}
+  CDmaStringArray(const CDmaStringArray &array) {}
 };
 
-class CDmrStringArray : public CDmrDecorator< CUtlString, CDmaStringArrayBase< CDmaDataExternal< CUtlVector< CUtlString > > > >
-{
-	typedef CDmrDecorator< CUtlString, CDmaStringArrayBase< CDmaDataExternal< CUtlVector< CUtlString > > > > BaseClass;
-	DECLARE_ATTRIBUTE_ARRAY_REFERENCE( CDmrStringArray, CUtlString );
+class CDmrStringArray
+    : public CDmrDecorator<
+          CUtlString,
+          CDmaStringArrayBase<CDmaDataExternal<CUtlVector<CUtlString>>>> {
+  typedef CDmrDecorator<
+      CUtlString, CDmaStringArrayBase<CDmaDataExternal<CUtlVector<CUtlString>>>>
+      BaseClass;
+  DECLARE_ATTRIBUTE_ARRAY_REFERENCE(CDmrStringArray, CUtlString);
 
 public:
-	CDmrStringArray( CDmaStringArray& var ) { Init( var.GetAttribute() ); }
-	CDmrStringArray( CDmrStringArray& var ) { Init( var.GetAttribute() ); }
+  CDmrStringArray(CDmaStringArray &var) { Init(var.GetAttribute()); }
+  CDmrStringArray(CDmrStringArray &var) { Init(var.GetAttribute()); }
 
-	const CDmrStringArray& operator=( const CDmrStringArray &val ) 
-	{ 
-		CopyArray( val.Base(), val.Count() ); 
-		return *this; 
-	}
+  const CDmrStringArray &operator=(const CDmrStringArray &val) {
+    CopyArray(val.Base(), val.Count());
+    return *this;
+  }
 
-	template< class C > const CDmrStringArray& operator=( const C &val ) 
-	{ 
-		CopyArray( val.Base(), val.Count() ); 
-		return *this; 
-	}
+  template <class C> const CDmrStringArray &operator=(const C &val) {
+    CopyArray(val.Base(), val.Count());
+    return *this;
+  }
 };
 
-class CDmrStringArrayConst : public CDmrDecoratorConst< CUtlString, CDmaStringArrayConstBase< CDmaArrayConstBase< CUtlString, CDmaDataExternal< CUtlVector< CUtlString > > > > >
-{
-	typedef CDmrDecoratorConst< CUtlString, CDmaStringArrayConstBase< CDmaArrayConstBase< CUtlString, CDmaDataExternal< CUtlVector< CUtlString > > > > > BaseClass;
-	DECLARE_ATTRIBUTE_ARRAY_CONST_REFERENCE( CDmrStringArrayConst, CUtlString );
+class CDmrStringArrayConst
+    : public CDmrDecoratorConst<
+          CUtlString,
+          CDmaStringArrayConstBase<CDmaArrayConstBase<
+              CUtlString, CDmaDataExternal<CUtlVector<CUtlString>>>>> {
+  typedef CDmrDecoratorConst<
+      CUtlString, CDmaStringArrayConstBase<CDmaArrayConstBase<
+                      CUtlString, CDmaDataExternal<CUtlVector<CUtlString>>>>>
+      BaseClass;
+  DECLARE_ATTRIBUTE_ARRAY_CONST_REFERENCE(CDmrStringArrayConst, CUtlString);
 
 public:
-	CDmrStringArrayConst( const CDmaStringArray& var )		{ Init( var.GetAttribute() ); }
-	CDmrStringArrayConst( const CDmrStringArray& var )		{ Init( var.GetAttribute() ); }
-	CDmrStringArrayConst( const CDmrStringArrayConst& var )	{ Init( var.GetAttribute() ); }
+  CDmrStringArrayConst(const CDmaStringArray &var) { Init(var.GetAttribute()); }
+  CDmrStringArrayConst(const CDmrStringArray &var) { Init(var.GetAttribute()); }
+  CDmrStringArrayConst(const CDmrStringArrayConst &var) {
+    Init(var.GetAttribute());
+  }
 };
 
-
 //-----------------------------------------------------------------------------
 // Prevent CDmaArray for DmElementHandle_t
 //-----------------------------------------------------------------------------
-template<> class CDmaArray<DmElementHandle_t> { private: CDmaArray(); };
+template <> class CDmaArray<DmElementHandle_t> {
+private:
+  CDmaArray();
+};
 
+template <class E> class CDmrElementArray;
 
-template< class E > class CDmrElementArray;
+template <class E = CDmElement>
+class CDmaElementArray
+    : public CDmaElementArrayBase<
+          E, CDmaDataInternal<CUtlVector<DmElementHandle_t>>> {
+  DECLARE_ATTRIBUTE_ARRAY_VARIABLE(CDmaElementArray, DmElementHandle_t);
 
-template< class E = CDmElement >
-class CDmaElementArray : public CDmaElementArrayBase< E, CDmaDataInternal< CUtlVector< DmElementHandle_t > > >
-{
-	DECLARE_ATTRIBUTE_ARRAY_VARIABLE( CDmaElementArray, DmElementHandle_t );
-
 public:
-	void Init( CDmElement *pOwner, const char *pAttributeName, int flags = 0 )
-	{
-		Assert( pOwner );
-		this->m_pAttribute = pOwner->AddExternalAttribute( pAttributeName, AT_ELEMENT_ARRAY, &CDmaElementArrayBase< E, CDmaDataInternal< CUtlVector< DmElementHandle_t > > >::Value() );
-		this->m_pAttribute->SetElementTypeSymbol( E::GetStaticTypeSymbol() );
-		if ( flags )
-		{
-			this->m_pAttribute->AddFlag( flags );
-		}
-	}
+  void Init(CDmElement *pOwner, const char *pAttributeName, int flags = 0) {
+    Assert(pOwner);
+    this->m_pAttribute = pOwner->AddExternalAttribute(
+        pAttributeName, AT_ELEMENT_ARRAY,
+        &CDmaElementArrayBase<
+            E, CDmaDataInternal<CUtlVector<DmElementHandle_t>>>::Value());
+    this->m_pAttribute->SetElementTypeSymbol(E::GetStaticTypeSymbol());
+    if (flags) {
+      this->m_pAttribute->AddFlag(flags);
+    }
+  }
 
-	template< typename C > CDmaElementArray<E>& operator=( const C &val ) 
-	{ 
-		CopyArray( val.Base(), val.Count() ); 
-		return *this; 
-	}
+  template <typename C> CDmaElementArray<E> &operator=(const C &val) {
+    CopyArray(val.Base(), val.Count());
+    return *this;
+  }
 
-	// NOTE: The copy operator= must be defined in addition to the generic one
-	const CDmaElementArray<E>& operator=( const CDmaElementArray<E> &val ) 
-	{ 
-		CopyArray( val.Base(), val.Count() ); 
-		return *this; 
-	}
+  // NOTE: The copy operator= must be defined in addition to the generic one
+  const CDmaElementArray<E> &operator=(const CDmaElementArray<E> &val) {
+    CopyArray(val.Base(), val.Count());
+    return *this;
+  }
 
 private:
-	template< class C > CDmaElementArray( const CDmaElementArray<C>& var );
+  template <class C> CDmaElementArray(const CDmaElementArray<C> &var);
 };
 
-template< class E = CDmElement >
-class CDmrElementArrayConst : public CDmaElementArrayConstBase< E, CDmaArrayConstBase< DmElementHandle_t, CDmaDataExternal< CUtlVector< DmElementHandle_t > > > >
-{
+template <class E = CDmElement>
+class CDmrElementArrayConst
+    : public CDmaElementArrayConstBase<
+          E,
+          CDmaArrayConstBase<DmElementHandle_t,
+                             CDmaDataExternal<CUtlVector<DmElementHandle_t>>>> {
 public:
-	CDmrElementArrayConst()
-	{
-		this->m_pAttribute = NULL;
-	}
+  CDmrElementArrayConst() { this->m_pAttribute = NULL; }
 
-	CDmrElementArrayConst( const CDmAttribute* pAttribute )
-	{
-		Init( pAttribute );
-	}
+  CDmrElementArrayConst(const CDmAttribute *pAttribute) { Init(pAttribute); }
 
-	CDmrElementArrayConst( const CDmElement *pElement, const char *pAttributeName )
-	{
-		Init( pElement, pAttributeName );
-	}
+  CDmrElementArrayConst(const CDmElement *pElement,
+                        const char *pAttributeName) {
+    Init(pElement, pAttributeName);
+  }
 
-	template< typename C > CDmrElementArrayConst( const CDmaElementArray<C>& var )
-	{
-		Init( var.GetAttribute() );
-	}
+  template <typename C> CDmrElementArrayConst(const CDmaElementArray<C> &var) {
+    Init(var.GetAttribute());
+  }
 
-	template< typename C > CDmrElementArrayConst( const CDmrElementArray<C>& var )
-	{
-		Init( var.GetAttribute() );
-	}
+  template <typename C> CDmrElementArrayConst(const CDmrElementArray<C> &var) {
+    Init(var.GetAttribute());
+  }
 
-	template< typename C > CDmrElementArrayConst( const CDmrElementArrayConst<C>& var )
-	{
-		Init( var.GetAttribute() );
-	}
+  template <typename C>
+  CDmrElementArrayConst(const CDmrElementArrayConst<C> &var) {
+    Init(var.GetAttribute());
+  }
 
-	void Init( const CDmAttribute* pAttribute )
-	{
-		if ( pAttribute && pAttribute->GetType() == AT_ELEMENT_ARRAY )
-		{
-			this->m_pAttribute = const_cast<CDmAttribute*>( pAttribute );
-			this->Attach( this->m_pAttribute->GetAttributeData() );
-		}
-		else
-		{
-			this->m_pAttribute = NULL;
-			this->Attach( NULL );
-		}
-	}
+  void Init(const CDmAttribute *pAttribute) {
+    if (pAttribute && pAttribute->GetType() == AT_ELEMENT_ARRAY) {
+      this->m_pAttribute = const_cast<CDmAttribute *>(pAttribute);
+      this->Attach(this->m_pAttribute->GetAttributeData());
+    } else {
+      this->m_pAttribute = NULL;
+      this->Attach(NULL);
+    }
+  }
 
-	void Init( const CDmElement *pElement, const char *pAttributeName )
-	{
-		const CDmAttribute *pAttribute = NULL;
-		if ( pElement && pAttributeName && pAttributeName[0] )
-		{
-			pAttribute = (CDmAttribute*)pElement->GetAttribute( pAttributeName );
-		}
-		Init( pAttribute );
-	}
+  void Init(const CDmElement *pElement, const char *pAttributeName) {
+    const CDmAttribute *pAttribute = NULL;
+    if (pElement && pAttributeName && pAttributeName[0]) {
+      pAttribute = (CDmAttribute *)pElement->GetAttribute(pAttributeName);
+    }
+    Init(pAttribute);
+  }
 
-	bool IsValid() const
-	{
-		return this->m_pAttribute != NULL;
-	}
+  bool IsValid() const { return this->m_pAttribute != NULL; }
 };
 
-template< class T = CDmElement >
-class CDmrElementArray : public CDmaElementArrayBase< T, CDmaDataExternal< CUtlVector< DmElementHandle_t > > >
-{
+template <class T = CDmElement>
+class CDmrElementArray
+    : public CDmaElementArrayBase<
+          T, CDmaDataExternal<CUtlVector<DmElementHandle_t>>> {
 public:
-	CDmrElementArray()
-	{
-		this->m_pAttribute = NULL;
-	}
+  CDmrElementArray() { this->m_pAttribute = NULL; }
 
-	CDmrElementArray( CDmAttribute* pAttribute )
-	{
-		Init( pAttribute );
-	}
+  CDmrElementArray(CDmAttribute *pAttribute) { Init(pAttribute); }
 
-	CDmrElementArray( CDmElement *pElement, const char *pAttributeName, bool bAddAttribute = false )
-	{
-		Init( pElement, pAttributeName, bAddAttribute );
-	}
+  CDmrElementArray(CDmElement *pElement, const char *pAttributeName,
+                   bool bAddAttribute = false) {
+    Init(pElement, pAttributeName, bAddAttribute);
+  }
 
-	template< typename C > CDmrElementArray( CDmaElementArray<C>& var )
-	{
-		Init( var.GetAttribute() );
-	}
+  template <typename C> CDmrElementArray(CDmaElementArray<C> &var) {
+    Init(var.GetAttribute());
+  }
 
-	template< typename C > CDmrElementArray( CDmrElementArray<C>& var )
-	{
-		Init( var.GetAttribute() );
-	}
+  template <typename C> CDmrElementArray(CDmrElementArray<C> &var) {
+    Init(var.GetAttribute());
+  }
 
-	void Init( CDmAttribute* pAttribute )
-	{
-		if ( pAttribute && pAttribute->GetType() == AT_ELEMENT_ARRAY )
-		{
-			this->m_pAttribute = pAttribute;
-			this->Attach( this->m_pAttribute->GetAttributeData() );
-		}
-		else
-		{
-			this->m_pAttribute = NULL;
-			this->Attach( NULL );
-		}
-	}
+  void Init(CDmAttribute *pAttribute) {
+    if (pAttribute && pAttribute->GetType() == AT_ELEMENT_ARRAY) {
+      this->m_pAttribute = pAttribute;
+      this->Attach(this->m_pAttribute->GetAttributeData());
+    } else {
+      this->m_pAttribute = NULL;
+      this->Attach(NULL);
+    }
+  }
 
-	void Init( CDmElement *pElement, const char *pAttributeName, bool bAddAttribute = false )
-	{
-		CDmAttribute *pAttribute = NULL;
-		if ( pElement && pAttributeName && pAttributeName[0] )
-		{
-			pAttribute = pElement->GetAttribute( pAttributeName );
-			if ( bAddAttribute && !pAttribute )
-			{
-				pAttribute = pElement->CreateAttribute( pAttributeName, AT_ELEMENT_ARRAY );
+  void Init(CDmElement *pElement, const char *pAttributeName,
+            bool bAddAttribute = false) {
+    CDmAttribute *pAttribute = NULL;
+    if (pElement && pAttributeName && pAttributeName[0]) {
+      pAttribute = pElement->GetAttribute(pAttributeName);
+      if (bAddAttribute && !pAttribute) {
+        pAttribute =
+            pElement->CreateAttribute(pAttributeName, AT_ELEMENT_ARRAY);
 
-				// FIXME: Should we do this?
-				pAttribute->SetElementTypeSymbol( T::GetStaticTypeSymbol() );
-			}
-		}
-		Init( pAttribute );
-	}
+        // FIXME: Should we do this?
+        pAttribute->SetElementTypeSymbol(T::GetStaticTypeSymbol());
+      }
+    }
+    Init(pAttribute);
+  }
 
-	bool IsValid() const
-	{
-		return this->m_pAttribute != NULL;
-	}
+  bool IsValid() const { return this->m_pAttribute != NULL; }
 
-	template< typename C > CDmrElementArray<T>& operator=( const C &val )
-	{ 
-		CopyArray( val.Base(), val.Count() ); 
-		return *this; 
-	}
+  template <typename C> CDmrElementArray<T> &operator=(const C &val) {
+    CopyArray(val.Base(), val.Count());
+    return *this;
+  }
 
-	// NOTE: The copy operator= must be defined in addition to the generic one
-	const CDmrElementArray<T>& operator=( const CDmrElementArray<T> &val )
-	{ 
-		CopyArray( val.Base(), val.Count() ); 
-		return *this; 
-	}
+  // NOTE: The copy operator= must be defined in addition to the generic one
+  const CDmrElementArray<T> &operator=(const CDmrElementArray<T> &val) {
+    CopyArray(val.Base(), val.Count());
+    return *this;
+  }
 };
 
-
 //-----------------------------------------------------------------------------
 //
 // Inline methods for CDmaVar
 //
 //-----------------------------------------------------------------------------
-template< class T > inline CDmaVar<T>::CDmaVar( )
-{
-	m_pAttribute = NULL;
-	CDmAttributeInfo<T>::SetDefaultValue( m_Storage );
+template <class T> inline CDmaVar<T>::CDmaVar() {
+  m_pAttribute = NULL;
+  CDmAttributeInfo<T>::SetDefaultValue(m_Storage);
 }
 
-template< class T > inline void CDmaVar<T>::Init( CDmElement *pOwner, const char *pAttributeName, int flags )
-{
-	Assert( pOwner );
-	m_pAttribute = pOwner->AddExternalAttribute( pAttributeName, CDmAttributeInfo<T>::AttributeType(), &m_Storage );
-	Assert( m_pAttribute );
-	if ( flags )
-	{
-		m_pAttribute->AddFlag( flags );
-	}
+template <class T>
+inline void CDmaVar<T>::Init(CDmElement *pOwner, const char *pAttributeName,
+                             int flags) {
+  Assert(pOwner);
+  m_pAttribute = pOwner->AddExternalAttribute(
+      pAttributeName, CDmAttributeInfo<T>::AttributeType(), &m_Storage);
+  Assert(m_pAttribute);
+  if (flags) {
+    m_pAttribute->AddFlag(flags);
+  }
 }
 
-template< class T > inline void CDmaVar<T>::InitAndSet( CDmElement *pOwner, const char *pAttributeName, const T &value, int flags )
-{
-	Init( pOwner, pAttributeName );
-	Set( value );
+template <class T>
+inline void CDmaVar<T>::InitAndSet(CDmElement *pOwner,
+                                   const char *pAttributeName, const T &value,
+                                   int flags) {
+  Init(pOwner, pAttributeName);
+  Set(value);
 
-	// this has to happen AFTER set so the set happens before FATTRIB_READONLY
-	if ( flags )
-	{
-		m_pAttribute->AddFlag( flags );
-	}
+  // this has to happen AFTER set so the set happens before FATTRIB_READONLY
+  if (flags) {
+    m_pAttribute->AddFlag(flags);
+  }
 }
 
-template< class T > inline const T& CDmaVar<T>::Set( const T &val )
-{
-	Assert( m_pAttribute );
-	m_pAttribute->SetValue( val );
-	return m_Storage;
+template <class T> inline const T &CDmaVar<T>::Set(const T &val) {
+  Assert(m_pAttribute);
+  m_pAttribute->SetValue(val);
+  return m_Storage;
 }
 
-template< class T > inline const T& CDmaVar<T>::operator=( const T &val ) 
-{
-	return Set( val );
+template <class T> inline const T &CDmaVar<T>::operator=(const T &val) {
+  return Set(val);
 }
 
-template< class T > inline const CDmaVar<T>& CDmaVar<T>::operator=( const CDmaVar<T>& src )
-{
-	Set( src.Get() );
-	return *this;
+template <class T>
+inline const CDmaVar<T> &CDmaVar<T>::operator=(const CDmaVar<T> &src) {
+  Set(src.Get());
+  return *this;
 }
 
-template< class T > inline const T& CDmaVar<T>::operator+=( const T &val ) 
-{
-	return Set( Value() + val );
+template <class T> inline const T &CDmaVar<T>::operator+=(const T &val) {
+  return Set(Value() + val);
 }
 
-template< class T > inline const T& CDmaVar<T>::operator-=( const T &val ) 
-{
-	return Set( Value() - val );
+template <class T> inline const T &CDmaVar<T>::operator-=(const T &val) {
+  return Set(Value() - val);
 }
 
-template< class T > inline const T& CDmaVar<T>::operator/=( const T &val ) 
-{
-	return Set( Value() / val );
+template <class T> inline const T &CDmaVar<T>::operator/=(const T &val) {
+  return Set(Value() / val);
 }
 
-template< class T > inline const T& CDmaVar<T>::operator*=( const T &val ) 
-{
-	return Set( Value() * val );
+template <class T> inline const T &CDmaVar<T>::operator*=(const T &val) {
+  return Set(Value() * val);
 }
 
-template< class T > inline const T& CDmaVar<T>::operator^=( const T &val ) 
-{
-	return Set( Value() ^ val );
+template <class T> inline const T &CDmaVar<T>::operator^=(const T &val) {
+  return Set(Value() ^ val);
 }
 
-template< class T > inline const T& CDmaVar<T>::operator|=( const T &val ) 
-{
-	return Set( Value() | val );
+template <class T> inline const T &CDmaVar<T>::operator|=(const T &val) {
+  return Set(Value() | val);
 }
 
-template< class T > inline const T& CDmaVar<T>::operator&=( const T &val ) 
-{	
-	return Set( Value() & val );
+template <class T> inline const T &CDmaVar<T>::operator&=(const T &val) {
+  return Set(Value() & val);
 }
 
-template< class T > inline T CDmaVar<T>::operator++()
-{
-	return Set( Value() + 1 );
+template <class T> inline T CDmaVar<T>::operator++() {
+  return Set(Value() + 1);
 }
 
-template< class T > inline T CDmaVar<T>::operator--()
-{
-	return Set( Value() - 1 );
+template <class T> inline T CDmaVar<T>::operator--() {
+  return Set(Value() - 1);
 }
 
-template< class T > inline T CDmaVar<T>::operator++( int ) // postfix version..
+template <class T>
+inline T CDmaVar<T>::operator++(int) // postfix version..
 {
-	T oldValue = Value();
-	Set( Value() + 1 );
-	return oldValue;
+  T oldValue = Value();
+  Set(Value() + 1);
+  return oldValue;
 }
 
-template< class T > inline T CDmaVar<T>::operator--( int ) // postfix version..
+template <class T>
+inline T CDmaVar<T>::operator--(int) // postfix version..
 {
-	T oldValue = Value();
-	Set( Value() - 1 );
-	return oldValue;
+  T oldValue = Value();
+  Set(Value() - 1);
+  return oldValue;
 }
 
-template< class T > inline CDmaVar<T>::operator const T&() const 
-{
-	return Value(); 
+template <class T> inline CDmaVar<T>::operator const T &() const {
+  return Value();
 }
 
-template< class T > inline const T& CDmaVar<T>::Get() const 
-{
-	return Value(); 
-}
+template <class T> inline const T &CDmaVar<T>::Get() const { return Value(); }
 
-template< class T > inline const T* CDmaVar<T>::operator->() const 
-{
-	return &Value(); 
+template <class T> inline const T *CDmaVar<T>::operator->() const {
+  return &Value();
 }
 
-template< class T > inline CDmAttribute *CDmaVar<T>::GetAttribute()
-{
-	Assert( m_pAttribute );
-	return m_pAttribute;
+template <class T> inline CDmAttribute *CDmaVar<T>::GetAttribute() {
+  Assert(m_pAttribute);
+  return m_pAttribute;
 }
 
-template< class T > inline const CDmAttribute *CDmaVar<T>::GetAttribute() const
-{
-	Assert( m_pAttribute );
-	return m_pAttribute;
-}
-
-template< class T > inline bool CDmaVar<T>::IsDirty() const
-{
-	Assert( m_pAttribute );
-	return m_pAttribute->IsFlagSet( FATTRIB_DIRTY );
+template <class T> inline const CDmAttribute *CDmaVar<T>::GetAttribute() const {
+  Assert(m_pAttribute);
+  return m_pAttribute;
 }
 
-template< class T > inline const T& CDmaVar<T>::Value() const 
-{ 
-	return m_Storage; 
+template <class T> inline bool CDmaVar<T>::IsDirty() const {
+  Assert(m_pAttribute);
+  return m_pAttribute->IsFlagSet(FATTRIB_DIRTY);
 }
 
-template< class T > inline T& CDmaVar<T>::Value() 
-{ 
-	return m_Storage; 
+template <class T> inline const T &CDmaVar<T>::Value() const {
+  return m_Storage;
 }
 
-template<> inline const DmElementHandle_t& CDmaVar< DmElementHandle_t >::Value() const 
-{
-	return m_Storage.m_Handle;
+template <class T> inline T &CDmaVar<T>::Value() { return m_Storage; }
+
+template <>
+inline const DmElementHandle_t &CDmaVar<DmElementHandle_t>::Value() const {
+  return m_Storage.m_Handle;
 }
 
-template<> inline DmElementHandle_t& CDmaVar< DmElementHandle_t >::Value() 
-{
-	return m_Storage.m_Handle;
+template <> inline DmElementHandle_t &CDmaVar<DmElementHandle_t>::Value() {
+  return m_Storage.m_Handle;
 }
 
-template< class T > inline const typename CDmaVar<T>::D& CDmaVar<T>::Storage() const 
-{ 
-	return m_Storage; 
+template <class T>
+inline const typename CDmaVar<T>::D &CDmaVar<T>::Storage() const {
+  return m_Storage;
 }
 
-template< class T > inline typename CDmaVar<T>::D& CDmaVar<T>::Storage() 
-{ 
-	return m_Storage; 
+template <class T> inline typename CDmaVar<T>::D &CDmaVar<T>::Storage() {
+  return m_Storage;
 }
 
-
 //-----------------------------------------------------------------------------
 //
 // Inline methods for CDmaColor
 //
 //-----------------------------------------------------------------------------
-inline void CDmaColor::SetColor( int r, int g, int b, int a )
-{
-	Color clr( r, g, b, a );
-	m_pAttribute->SetValue( clr );
+inline void CDmaColor::SetColor(int r, int g, int b, int a) {
+  Color clr(r, g, b, a);
+  m_pAttribute->SetValue(clr);
 }
 
-inline void CDmaColor::SetRed( int r )
-{
-	Color org = Value();
-	org[ 0 ] = r;
-	m_pAttribute->SetValue( org );
+inline void CDmaColor::SetRed(int r) {
+  Color org = Value();
+  org[0] = r;
+  m_pAttribute->SetValue(org);
 }
 
-inline void CDmaColor::SetGreen( int g )
-{
-	Color org = Value();
-	org[ 1 ] = g;
-	m_pAttribute->SetValue( org );
+inline void CDmaColor::SetGreen(int g) {
+  Color org = Value();
+  org[1] = g;
+  m_pAttribute->SetValue(org);
 }
 
-inline void CDmaColor::SetBlue( int b )
-{
-	Color org = Value();
-	org[ 2 ] = b;
-	m_pAttribute->SetValue( org );
+inline void CDmaColor::SetBlue(int b) {
+  Color org = Value();
+  org[2] = b;
+  m_pAttribute->SetValue(org);
 }
 
-inline void CDmaColor::SetAlpha( int a )
-{
-	Color org = Value();
-	org[ 3 ] = a;
-	m_pAttribute->SetValue( org );
+inline void CDmaColor::SetAlpha(int a) {
+  Color org = Value();
+  org[3] = a;
+  m_pAttribute->SetValue(org);
 }
 
-inline unsigned char CDmaColor::r() const
-{
-	return (unsigned char)Value().r();
-}
+inline unsigned char CDmaColor::r() const { return (unsigned char)Value().r(); }
 
-inline unsigned char CDmaColor::g() const
-{
-	return (unsigned char)Value().g();
-}
+inline unsigned char CDmaColor::g() const { return (unsigned char)Value().g(); }
 
-inline unsigned char CDmaColor::b() const
-{
-	return (unsigned char)Value().b();
-}
+inline unsigned char CDmaColor::b() const { return (unsigned char)Value().b(); }
 
-inline unsigned char CDmaColor::a() const
-{
-	return (unsigned char)Value().a();
-}
+inline unsigned char CDmaColor::a() const { return (unsigned char)Value().a(); }
 
-inline const unsigned char &CDmaColor::operator[](int index) const
-{
-	return Value()[index];
+inline const unsigned char &CDmaColor::operator[](int index) const {
+  return Value()[index];
 }
 
-inline void CDmaColor::SetRawColor( int color )
-{
-	Color clr;
-	clr.SetRawColor( color );
-	m_pAttribute->SetValue( clr );
+inline void CDmaColor::SetRawColor(int color) {
+  Color clr;
+  clr.SetRawColor(color);
+  m_pAttribute->SetValue(clr);
 }
 
-
 //-----------------------------------------------------------------------------
 //
 // Inline methods for CDmaObjectId
 //
 //-----------------------------------------------------------------------------
-inline void CDmaObjectId::CreateObjectId( )
-{ 
-	DmObjectId_t id;
-	CreateUniqueId( &id );
-	m_pAttribute->SetValue( id );
+inline void CDmaObjectId::CreateObjectId() {
+  DmObjectId_t id;
+  CreateUniqueId(&id);
+  m_pAttribute->SetValue(id);
 }
 
-inline void CDmaObjectId::Invalidate( )
-{
-	DmObjectId_t id;
-	InvalidateUniqueId( &id );
-	m_pAttribute->SetValue( id );
+inline void CDmaObjectId::Invalidate() {
+  DmObjectId_t id;
+  InvalidateUniqueId(&id);
+  m_pAttribute->SetValue(id);
 }
 
-inline bool CDmaObjectId::IsValid( ) const
-{
-	return IsUniqueIdValid( Value() );
-}
+inline bool CDmaObjectId::IsValid() const { return IsUniqueIdValid(Value()); }
 
-inline bool CDmaObjectId::IsEqual( const DmObjectId_t &id ) const
-{
-	return IsUniqueIdEqual( Value(), id );
+inline bool CDmaObjectId::IsEqual(const DmObjectId_t &id) const {
+  return IsUniqueIdEqual(Value(), id);
 }
 
-inline const DmObjectId_t &CDmaObjectId::operator=( const DmObjectId_t& src )
-{
-	m_pAttribute->SetValue( src );
-	return Value();
+inline const DmObjectId_t &CDmaObjectId::operator=(const DmObjectId_t &src) {
+  m_pAttribute->SetValue(src);
+  return Value();
 }
 
-inline const CDmaObjectId& CDmaObjectId::operator=( const CDmaObjectId& src )
-{
-	m_pAttribute->SetValue( src.Get() );
-	return *this;
+inline const CDmaObjectId &CDmaObjectId::operator=(const CDmaObjectId &src) {
+  m_pAttribute->SetValue(src.Get());
+  return *this;
 }
 
-inline const DmObjectId_t& CDmaObjectId::Set( const DmObjectId_t &src )
-{
-	m_pAttribute->SetValue( src );
-	return Value();
+inline const DmObjectId_t &CDmaObjectId::Set(const DmObjectId_t &src) {
+  m_pAttribute->SetValue(src);
+  return Value();
 }
 
-
 //-----------------------------------------------------------------------------
 //
 // Inline methods for CDmaString
 //
 //-----------------------------------------------------------------------------
-inline const char *CDmaString::Get( ) const
-{
-	return Value().Get();
-}
+inline const char *CDmaString::Get() const { return Value().Get(); }
 
-inline CDmaString::operator const char*() const
-{
-	return Value().Get();
-}
+inline CDmaString::operator const char *() const { return Value().Get(); }
 
-inline void CDmaString::Set( const char *pValue )
-{
-	CUtlString str( pValue, pValue ? Q_strlen( pValue ) + 1 : 0 );
-	m_pAttribute->SetValue( str );
+inline void CDmaString::Set(const char *pValue) {
+  CUtlString str(pValue, pValue ? Q_strlen(pValue) + 1 : 0);
+  m_pAttribute->SetValue(str);
 }
 
 // Returns strlen
-inline int CDmaString::Length() const
-{
-	return Value().Length();
-}
+inline int CDmaString::Length() const { return Value().Length(); }
 
-inline CDmaString &CDmaString::operator=( const char *src )
-{
-	Set( src );
-	return *this;
+inline CDmaString &CDmaString::operator=(const char *src) {
+  Set(src);
+  return *this;
 }
 
-inline const CDmaString& CDmaString::operator=( const CDmaString& src )
-{
-	Set( src.Get() );
-	return *this;
+inline const CDmaString &CDmaString::operator=(const CDmaString &src) {
+  Set(src.Get());
+  return *this;
 }
 
-
 //-----------------------------------------------------------------------------
 //
 // Inline methods for CDmaBinaryBlock
 //
 //-----------------------------------------------------------------------------
-inline void CDmaBinaryBlock::Get( void *pValue, int nMaxLen ) const
-{
-	Value().Get( pValue, nMaxLen );
-}
-
-inline void CDmaBinaryBlock::Set( const void *pValue, int nLen )
-{
-	CUtlBinaryBlock block( pValue, nLen );
-	m_pAttribute->SetValue( block );
+inline void CDmaBinaryBlock::Get(void *pValue, int nMaxLen) const {
+  Value().Get(pValue, nMaxLen);
 }
 
-inline const void *CDmaBinaryBlock::Get() const
-{
-	return Value().Get();
+inline void CDmaBinaryBlock::Set(const void *pValue, int nLen) {
+  CUtlBinaryBlock block(pValue, nLen);
+  m_pAttribute->SetValue(block);
 }
 
-inline const unsigned char& CDmaBinaryBlock::operator[]( int i ) const
-{
-	return Value()[i];
-}
+inline const void *CDmaBinaryBlock::Get() const { return Value().Get(); }
 
-inline int CDmaBinaryBlock::Length() const
-{
-	return Value().Length();
+inline const unsigned char &CDmaBinaryBlock::operator[](int i) const {
+  return Value()[i];
 }
 
+inline int CDmaBinaryBlock::Length() const { return Value().Length(); }
 
 //-----------------------------------------------------------------------------
 //
@@ -1120,364 +1017,305 @@
 //
 //-----------------------------------------------------------------------------
 template <class T>
-inline void CDmaElement<T>::InitAndCreate( CDmElement *pOwner, const char *pAttributeName, const char *pElementName, int flags )
-{
-	Init( pOwner, pAttributeName );
+inline void CDmaElement<T>::InitAndCreate(CDmElement *pOwner,
+                                          const char *pAttributeName,
+                                          const char *pElementName, int flags) {
+  Init(pOwner, pAttributeName);
 
-	DmElementHandle_t hElement = DMELEMENT_HANDLE_INVALID;
-	if ( !g_pDataModel->IsUnserializing() )
-	{
-		hElement = g_pDataModel->CreateElement( T::GetStaticTypeSymbol(), pElementName, pOwner->GetFileId() );
-	}
-	Assert( m_pAttribute );
-	m_pAttribute->SetValue( hElement );
+  DmElementHandle_t hElement = DMELEMENT_HANDLE_INVALID;
+  if (!g_pDataModel->IsUnserializing()) {
+    hElement = g_pDataModel->CreateElement(T::GetStaticTypeSymbol(),
+                                           pElementName, pOwner->GetFileId());
+  }
+  Assert(m_pAttribute);
+  m_pAttribute->SetValue(hElement);
 
-	// this has to happen AFTER set so the set happens before FATTRIB_READONLY
-	m_pAttribute->AddFlag( flags | FATTRIB_MUSTCOPY );
+  // this has to happen AFTER set so the set happens before FATTRIB_READONLY
+  m_pAttribute->AddFlag(flags | FATTRIB_MUSTCOPY);
 }
 
 template <class T>
-inline void CDmaElement<T>::Init( CDmElement *pOwner, const char *pAttributeName, int flags )
-{
-	BaseClass::Init( pOwner, pAttributeName );
+inline void CDmaElement<T>::Init(CDmElement *pOwner, const char *pAttributeName,
+                                 int flags) {
+  BaseClass::Init(pOwner, pAttributeName);
 
-	Assert( m_pAttribute );
-	m_pAttribute->SetElementTypeSymbol( T::GetStaticTypeSymbol() );
-	if ( flags )
-	{
-		m_pAttribute->AddFlag( flags );
-	}
+  Assert(m_pAttribute);
+  m_pAttribute->SetElementTypeSymbol(T::GetStaticTypeSymbol());
+  if (flags) {
+    m_pAttribute->AddFlag(flags);
+  }
 }
 
-/*
-template <class T>
-inline UtlSymId_t CDmaElement<T>::GetElementType() const
-{
-	return this->Data().m_ElementType;
+template <class T> inline UtlSymId_t CDmaElement<T>::GetElementType() const {
+  return this->Storage().m_ElementType;
 }
-*/
 
-template <class T>
-inline T* CDmaElement<T>::GetElement() const
-{
-	CDmElement *pElement = g_pDataModel->GetElement( Value() );
-	Assert( !pElement || pElement->IsA( T::GetStaticTypeSymbol() ) );
-	return static_cast< T* >( pElement );
+template <class T> inline T *CDmaElement<T>::GetElement() const {
+  CDmElement *pElement = g_pDataModel->GetElement(Value());
+  Assert(!pElement || pElement->IsA(T::GetStaticTypeSymbol()));
+  return static_cast<T *>(pElement);
 }
 
-template <class T>
-inline T* CDmaElement<T>::operator->() const
-{
-	return GetElement();
+template <class T> inline T *CDmaElement<T>::operator->() const {
+  return GetElement();
 }
 
-template <class T>
-inline CDmaElement<T>::operator T*() const
-{
-	return GetElement();
+template <class T> inline CDmaElement<T>::operator T *() const {
+  return GetElement();
 }
 
-template <class T>
-inline void CDmaElement<T>::Set( T* pElement )
-{
-	Assert( m_pAttribute );
-	m_pAttribute->SetValue( pElement ? pElement->GetHandle() : DMELEMENT_HANDLE_INVALID );
+template <class T> inline void CDmaElement<T>::Set(T *pElement) {
+  Assert(m_pAttribute);
+  m_pAttribute->SetValue(pElement ? pElement->GetHandle()
+                                  : DMELEMENT_HANDLE_INVALID);
 }
 
-template <class T>
-inline bool CDmaElement<T>::operator!() const
-{
-	return ( GetElement() == NULL );
+template <class T> inline bool CDmaElement<T>::operator!() const {
+  return (GetElement() == NULL);
 }
 
-
 //-----------------------------------------------------------------------------
 //
 // Inline methods for CDmaArrayBase
 //
 //-----------------------------------------------------------------------------
-template< class T, class B >
-inline const CUtlVector<T>& CDmaArrayConstBase<T,B>::Get() const
-{
-	return this->Value();
+template <class T, class B>
+inline const CUtlVector<T> &CDmaArrayConstBase<T, B>::Get() const {
+  return this->Value();
 }
 
-template< class T, class B >
-inline const T *CDmaArrayConstBase<T,B>::Base() const
-{
-	return this->Value().Base();
+template <class T, class B>
+inline const T *CDmaArrayConstBase<T, B>::Base() const {
+  return this->Value().Base();
 }
 
-template< class T, class B >
-inline const T& CDmaArrayConstBase<T,B>::operator[]( int i ) const
-{
-	return this->Value()[ i ];
+template <class T, class B>
+inline const T &CDmaArrayConstBase<T, B>::operator[](int i) const {
+  return this->Value()[i];
 }
 
-template< class T, class B >
-const T& CDmaArrayConstBase<T,B>::Element( int i ) const
-{
-	return this->Value()[ i ];
+template <class T, class B>
+const T &CDmaArrayConstBase<T, B>::Element(int i) const {
+  return this->Value()[i];
 }
 
-template< class T, class B >
-inline const T& CDmaArrayConstBase<T,B>::Get( int i ) const
-{
-	return this->Value()[ i ];
+template <class T, class B>
+inline const T &CDmaArrayConstBase<T, B>::Get(int i) const {
+  return this->Value()[i];
 }
 
-template< class T, class B >
-const void* CDmaArrayConstBase<T,B>::GetUntyped( int i ) const
-{
-	return &( this->Value()[ i ] );
+template <class T, class B>
+const void *CDmaArrayConstBase<T, B>::GetUntyped(int i) const {
+  return &(this->Value()[i]);
 }
 
-template< class T, class B >
-inline int CDmaArrayConstBase<T,B>::Count() const
-{
-	return this->Value().Count();
+template <class T, class B> inline int CDmaArrayConstBase<T, B>::Count() const {
+  return this->Value().Count();
 }
 
-template< class T, class B >
-inline bool CDmaArrayConstBase<T,B>::IsValidIndex( int i ) const
-{
-	return this->Value().IsValidIndex( i );
+template <class T, class B>
+inline bool CDmaArrayConstBase<T, B>::IsValidIndex(int i) const {
+  return this->Value().IsValidIndex(i);
 }
 
-template< class T, class B >
-inline int CDmaArrayConstBase<T,B>::InvalidIndex( void ) const
-{
-	return this->Value().InvalidIndex();
+template <class T, class B>
+inline int CDmaArrayConstBase<T, B>::InvalidIndex(void) const {
+  return this->Value().InvalidIndex();
 }
 
-template< class T, class B >
-inline const CDmAttribute *CDmaArrayConstBase<T,B>::GetAttribute() const
-{
-	Assert( m_pAttribute );
-	return m_pAttribute;
+template <class T, class B>
+inline const CDmAttribute *CDmaArrayConstBase<T, B>::GetAttribute() const {
+  Assert(m_pAttribute);
+  return m_pAttribute;
 }
 
-template< class T, class B >
-inline CDmElement *CDmaArrayConstBase<T,B>::GetOwner()
-{
-	return m_pAttribute->GetOwner();
+template <class T, class B>
+inline CDmElement *CDmaArrayConstBase<T, B>::GetOwner() {
+  return m_pAttribute->GetOwner();
 }
 
-template< class T, class B >
-inline bool CDmaArrayConstBase<T,B>::IsDirty() const
-{
-	return m_pAttribute->IsFlagSet( FATTRIB_DIRTY );
+template <class T, class B>
+inline bool CDmaArrayConstBase<T, B>::IsDirty() const {
+  return m_pAttribute->IsFlagSet(FATTRIB_DIRTY);
 }
 
-
-template< class T, class B >
-inline CDmAttribute *CDmaArrayBase<T,B>::GetAttribute()
-{
-	Assert( this->m_pAttribute );
-	return this->m_pAttribute;
+template <class T, class B>
+inline CDmAttribute *CDmaArrayBase<T, B>::GetAttribute() {
+  Assert(this->m_pAttribute);
+  return this->m_pAttribute;
 }
 
-template< class T, class B >
-inline const CDmAttribute *CDmaArrayBase<T,B>::GetAttribute() const
-{
-	Assert( this->m_pAttribute );
-	return this->m_pAttribute;
+template <class T, class B>
+inline const CDmAttribute *CDmaArrayBase<T, B>::GetAttribute() const {
+  Assert(this->m_pAttribute);
+  return this->m_pAttribute;
 }
 
-
 //-----------------------------------------------------------------------------
 //
 // Inline methods for CDmaStringArrayBase
 //
 //-----------------------------------------------------------------------------
-template< class B >
-inline const char *CDmaStringArrayConstBase<B>::operator[]( int i ) const
-{
-	return this->Value()[ i ].Get();
+template <class B>
+inline const char *CDmaStringArrayConstBase<B>::operator[](int i) const {
+  return this->Value()[i].Get();
 }
 
-template< class B >
-inline const char *CDmaStringArrayConstBase<B>::Element( int i ) const
-{
-	return this->Value()[ i ].Get();
+template <class B>
+inline const char *CDmaStringArrayConstBase<B>::Element(int i) const {
+  return this->Value()[i].Get();
 }
 
-template< class B >
-inline const char *CDmaStringArrayConstBase<B>::Get( int i ) const
-{
-	return this->Value()[ i ].Get();
+template <class B>
+inline const char *CDmaStringArrayConstBase<B>::Get(int i) const {
+  return this->Value()[i].Get();
 }
 
-template< class B >
-inline const CUtlVector< CUtlString > &CDmaStringArrayConstBase<B>::Get() const
-{
-	return this->Value();
+template <class B>
+inline const CUtlVector<CUtlString> &CDmaStringArrayConstBase<B>::Get() const {
+  return this->Value();
 }
 
 // Returns strlen of element i
-template< class B >
-inline int CDmaStringArrayConstBase<B>::Length( int i ) const
-{
-	return this->Value()[i].Length();
+template <class B> inline int CDmaStringArrayConstBase<B>::Length(int i) const {
+  return this->Value()[i].Length();
 }
 
-template< class B >
-inline void CDmaStringArrayBase<B>::Set( int i, const char * pValue )
-{
-	CUtlString str( pValue, Q_strlen( pValue ) + 1 );
-	BaseClass::Set( i, str );
+template <class B>
+inline void CDmaStringArrayBase<B>::Set(int i, const char *pValue) {
+  CUtlString str(pValue, Q_strlen(pValue) + 1);
+  BaseClass::Set(i, str);
 }
 
 // Adds an element, uses copy constructor
-template< class B >
-inline int CDmaStringArrayBase<B>::AddToTail( const char *pValue )
-{
-	CUtlString str( pValue, Q_strlen( pValue ) + 1 );
-	return BaseClass::AddToTail( str );
+template <class B>
+inline int CDmaStringArrayBase<B>::AddToTail(const char *pValue) {
+  CUtlString str(pValue, Q_strlen(pValue) + 1);
+  return BaseClass::AddToTail(str);
 }
 
-template< class B >
-inline int CDmaStringArrayBase<B>::InsertBefore( int elem, const char *pValue )
-{
-	CUtlString str( pValue, Q_strlen( pValue ) + 1 );
-	return BaseClass::InsertBefore( elem, str );
+template <class B>
+inline int CDmaStringArrayBase<B>::InsertBefore(int elem, const char *pValue) {
+  CUtlString str(pValue, Q_strlen(pValue) + 1);
+  return BaseClass::InsertBefore(elem, str);
 }
 
-
 //-----------------------------------------------------------------------------
 //
 // Inline methods for CDmaElementArrayBase
 //
 //-----------------------------------------------------------------------------
-template< class E, class B > 
-inline UtlSymId_t CDmaElementArrayConstBase<E,B>::GetElementType() const
-{
-	return this->Data().m_ElementType;
+template <class E, class B>
+inline UtlSymId_t CDmaElementArrayConstBase<E, B>::GetElementType() const {
+  return this->Storage().m_ElementType;
 }
 
-template< class E, class B >
-inline E *CDmaElementArrayConstBase<E,B>::operator[]( int i ) const
-{
-	return GetElement<E>( this->Value()[i] );
+template <class E, class B>
+inline E *CDmaElementArrayConstBase<E, B>::operator[](int i) const {
+  return GetElement<E>(this->Value()[i]);
 }
 
-template< class E, class B >
-inline E *CDmaElementArrayConstBase<E,B>::Element( int i ) const
-{
-	return GetElement<E>( this->Value()[i] );
+template <class E, class B>
+inline E *CDmaElementArrayConstBase<E, B>::Element(int i) const {
+  return GetElement<E>(this->Value()[i]);
 }
 
-template< class E, class B >
-inline E *CDmaElementArrayConstBase<E,B>::Get( int i ) const
-{
-	return GetElement<E>( this->Value()[i] );
+template <class E, class B>
+inline E *CDmaElementArrayConstBase<E, B>::Get(int i) const {
+  return GetElement<E>(this->Value()[i]);
 }
 
-template< class E, class B >
-inline const DmElementHandle_t& CDmaElementArrayConstBase<E,B>::GetHandle( int i ) const
-{
-	return this->Value()[i];
+template <class E, class B>
+inline const DmElementHandle_t &
+CDmaElementArrayConstBase<E, B>::GetHandle(int i) const {
+  return this->Value()[i];
 }
 
-template< class E, class B >
-inline const CUtlVector< DmElementHandle_t > &CDmaElementArrayConstBase<E,B>::Get() const
-{
-	return this->Value();
+template <class E, class B>
+inline const CUtlVector<DmElementHandle_t> &
+CDmaElementArrayConstBase<E, B>::Get() const {
+  return this->Value();
 }
 
 // Search
-template< class E, class B >
-inline int CDmaElementArrayConstBase<E,B>::Find( const E *pValue ) const
-{
-	if ( !pValue )
-		return -1;
-	return B::Find( pValue->GetHandle() );
+template <class E, class B>
+inline int CDmaElementArrayConstBase<E, B>::Find(const E *pValue) const {
+  if (!pValue)
+    return -1;
+  return B::Find(pValue->GetHandle());
 }
 
-template< class E, class B >
-inline int CDmaElementArrayConstBase<E,B>::Find( DmElementHandle_t h ) const
-{
-	return B::Find( h );
+template <class E, class B>
+inline int CDmaElementArrayConstBase<E, B>::Find(DmElementHandle_t h) const {
+  return B::Find(h);
 }
 
-template< class E, class B >
-inline void CDmaElementArrayBase<E,B>::SetHandle( int i, DmElementHandle_t h )
-{
-	BaseClass::Set( i, h );
+template <class E, class B>
+inline void CDmaElementArrayBase<E, B>::SetHandle(int i, DmElementHandle_t h) {
+  BaseClass::Set(i, h);
 }
 
-template< class E, class B >
-inline void CDmaElementArrayBase<E,B>::Set( int i, E *pElement )
-{
-	BaseClass::Set( i, pElement ? pElement->GetHandle() : DMELEMENT_HANDLE_INVALID );
+template <class E, class B>
+inline void CDmaElementArrayBase<E, B>::Set(int i, E *pElement) {
+  BaseClass::Set(i,
+                 pElement ? pElement->GetHandle() : DMELEMENT_HANDLE_INVALID);
 }
 
 // Adds an element, uses copy constructor
-template< class E, class B >
-inline int CDmaElementArrayBase<E,B>::AddToTail( )
-{
-	return BaseClass::AddToTail( );
+template <class E, class B> inline int CDmaElementArrayBase<E, B>::AddToTail() {
+  return BaseClass::AddToTail();
 }
 
-template< class E, class B >
-inline int CDmaElementArrayBase<E,B>::AddToTail( E *pValue )
-{
-	return BaseClass::AddToTail( pValue ? pValue->GetHandle() : DMELEMENT_HANDLE_INVALID );
+template <class E, class B>
+inline int CDmaElementArrayBase<E, B>::AddToTail(E *pValue) {
+  return BaseClass::AddToTail(pValue ? pValue->GetHandle()
+                                     : DMELEMENT_HANDLE_INVALID);
 }
 
-template< class E, class B >
-inline int CDmaElementArrayBase<E,B>::AddToTail( DmElementHandle_t src )
-{
-	return BaseClass::AddToTail( src );
+template <class E, class B>
+inline int CDmaElementArrayBase<E, B>::AddToTail(DmElementHandle_t src) {
+  return BaseClass::AddToTail(src);
 }
 
-template< class E, class B >
-inline int CDmaElementArrayBase<E,B>::InsertBefore( int elem )
-{
-	return BaseClass::InsertBefore( elem );
+template <class E, class B>
+inline int CDmaElementArrayBase<E, B>::InsertBefore(int elem) {
+  return BaseClass::InsertBefore(elem);
 }
 
-template< class E, class B >
-inline int CDmaElementArrayBase<E,B>::InsertBefore( int elem, E *pValue )
-{
-	return BaseClass::InsertBefore( elem, pValue ? pValue->GetHandle() : DMELEMENT_HANDLE_INVALID );
+template <class E, class B>
+inline int CDmaElementArrayBase<E, B>::InsertBefore(int elem, E *pValue) {
+  return BaseClass::InsertBefore(elem, pValue ? pValue->GetHandle()
+                                              : DMELEMENT_HANDLE_INVALID);
 }
 
-template< class E, class B >
-inline int CDmaElementArrayBase<E,B>::InsertBefore( int elem, DmElementHandle_t src )
-{
-	return BaseClass::InsertBefore( elem, src );
+template <class E, class B>
+inline int CDmaElementArrayBase<E, B>::InsertBefore(int elem,
+                                                    DmElementHandle_t src) {
+  return BaseClass::InsertBefore(elem, src);
 }
 
-
-
 //-----------------------------------------------------------------------------
 //
 // Inline methods for CDmrGenericArray
 //
 //-----------------------------------------------------------------------------
-inline const CDmAttribute *CDmrGenericArrayConst::GetAttribute() const
-{
-	Assert( m_pAttribute );
-	return m_pAttribute;
+inline const CDmAttribute *CDmrGenericArrayConst::GetAttribute() const {
+  Assert(m_pAttribute);
+  return m_pAttribute;
 }
 
-inline bool CDmrGenericArrayConst::IsValid() const
-{
-	return m_pAttribute != NULL;
+inline bool CDmrGenericArrayConst::IsValid() const {
+  return m_pAttribute != NULL;
 }
 
-inline CDmAttribute *CDmrGenericArray::GetAttribute()
-{
-	Assert( m_pAttribute );
-	return m_pAttribute;
+inline CDmAttribute *CDmrGenericArray::GetAttribute() {
+  Assert(m_pAttribute);
+  return m_pAttribute;
 }
 
-inline const CDmAttribute *CDmrGenericArray::GetAttribute() const
-{
-	Assert( m_pAttribute );
-	return m_pAttribute;
+inline const CDmAttribute *CDmrGenericArray::GetAttribute() const {
+  Assert(m_pAttribute);
+  return m_pAttribute;
 }
 
-
 #endif // DMATTRIBUTEVAR_H
